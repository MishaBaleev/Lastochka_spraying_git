{"ast":null,"code":"import waypointIcon from '../RouteConstructor/BRM/Waypoint/icon_map_waypoint.png';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { lineChunk, lineString, lineIntersect, lineSlice, length, point, polygon } from '@turf/turf';\nfunction getIntersectAlt(l1, l2, l3) {\n  if (l1[0] != l2[0]) {\n    let line1 = lineString([[l1[0], l1[2]], [l2[0], l2[2]]]);\n    let line2 = lineString([[l3[0], 0], [l3[0], Math.max(l1[2], l2[2])]]);\n    let intersects = lineIntersect(line1, line2);\n    return intersects.features[0].geometry.coordinates[1];\n  } else if (l1[1] != l2[1]) {\n    let line1 = lineString([[l1[1], l1[2]], [l2[1], l2[2]]]);\n    let line2 = lineString([[l3[1], 0], [l3[1], Math.max(l1[2], l2[2])]]);\n    let intersects = lineIntersect(line1, line2);\n    return intersects.features[0].geometry.coordinates[1];\n  }\n}\nfunction calcDistance(point1, point2) {\n  var line = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [{\n      \"type\": \"Feature\",\n      \"properties\": {},\n      \"geometry\": {\n        \"type\": \"LineString\",\n        \"coordinates\": [point1, point2]\n      }\n    }]\n  };\n  var start = {\n    \"type\": \"Feature\",\n    \"properties\": {},\n    \"geometry\": {\n      \"type\": \"Point\",\n      \"coordinates\": point1\n    }\n  };\n  var stop = {\n    \"type\": \"Feature\",\n    \"properties\": {},\n    \"geometry\": {\n      \"type\": \"Point\",\n      \"coordinates\": point2\n    }\n  };\n  return length(lineSlice(start, stop, line.features[0]), {\n    units: 'meters'\n  });\n}\nfunction segmentateLine(point1, point2, segmentProcent, manager3D, flag = false) {\n  let pwa1 = [point1[0], point1[1]];\n  let pwa2 = [point2[0], point2[1]];\n  let distance = calcDistance(pwa1, pwa2);\n  let interval = 0;\n  if (flag) {\n    interval = 1 / 1000;\n  } else {\n    interval = distance / 1000 * (segmentProcent / 100);\n  }\n  let cords = [];\n  let cords_AMS = [];\n  let z = [...lineChunk({\n    type: 'Feature',\n    geometry: {\n      type: 'LineString',\n      coordinates: [pwa1, pwa2]\n    },\n    properties: {}\n  }, distance / 1000 * (segmentProcent / 100)).features.map(feature => {\n    let alt;\n    //console.log(pwa1, pwa2, feature.geometry.coordinates[0])\n    if (pwa1[0] == feature.geometry.coordinates[0][0] && pwa1[1] == feature.geometry.coordinates[0][1]) {\n      alt = point1[2];\n    } else if (pwa2[0] == feature.geometry.coordinates[0][0] && pwa2[1] == feature.geometry.coordinates[0][1]) {\n      alt = point2[2];\n    } else if (point1[2] == point2[2]) {\n      alt = point1[2];\n    } else {\n      alt = getIntersectAlt(point1, point2, feature.geometry.coordinates[0]);\n    }\n    cords.push([...feature.geometry.coordinates[0], alt]);\n    cords_AMS.push([...feature.geometry.coordinates[0], alt + manager3D.getAMS({\n      lng: feature.geometry.coordinates[0][0],\n      lat: feature.geometry.coordinates[0][1]\n    })]);\n    return;\n  })];\n  cords.push(point2);\n  cords_AMS.push([point2[0], point2[1], point2[2] + manager3D.getAMS({\n    lng: point2[0],\n    lat: point2[1]\n  })]);\n  return {\n    cords: cords,\n    cords_AMS: cords_AMS\n  };\n}\nasync function getFeatures(segment, manager3d) {\n  let cords = manager3d.map.project({\n    lng: segment[0],\n    lat: segment[1]\n  });\n  cords = [cords.x, cords.y];\n  let feat = manager3d.map.queryRenderedFeatures(cords);\n  console.log(feat);\n  if (feat.length != 0 && feat[0].properties.height >= segment[2]) {\n    return {\n      feat: feat[0],\n      cords: segment,\n      featHeight: feat[0].properties.height\n    };\n  }\n}\nexport class SprayManager3d {\n  constructor(manager3d) {\n    this.manager3d = manager3d;\n    this.objects = [];\n    this.sphereArr = [];\n    this.routeLine = null;\n    this.route = null;\n    this.selected_features = [];\n    this.warnings = [];\n    this.warningsBuildings = [];\n    this.helpLines = [];\n    this.changeMode = this.changeMode.bind(this);\n  }\n  addSphere(coords, elementID) {\n    let sphereOptions = this.manager3d.getMeshOptions(\"sphere_1\");\n    let pointSphere = tb.sphere(sphereOptions);\n    pointSphere.setCoords([coords[0], coords[1], coords[2] + this.manager3d.getAMS({\n      lng: coords[0],\n      lat: coords[1]\n    })]);\n    let sphereObject = {\n      object: pointSphere,\n      id: elementID,\n      baseCoords: coords\n    };\n    tb.add(pointSphere);\n    this.objects.push(pointSphere);\n    this.sphereArr.push(sphereObject);\n    this.setCurrentSphere(elementID);\n    this.manager3d.map.setZoom(this.manager3d.map.getZoom());\n  }\n  getCoordArr(route) {\n    let currentNode = route.head;\n    let coordArr = [];\n    while (currentNode != route.tail) {\n      currentNode = currentNode.next;\n      if (currentNode == route.head.next) {\n        coordArr.push([currentNode.params.lng.value, currentNode.params.lat.value, 0]);\n      }\n      if (currentNode.params.module.name == \"Polygon\") {\n        for (let coord of currentNode.params.markup.value) {\n          coordArr.push([coord[0], coord[1], Number(currentNode.params.alt.value)]);\n        }\n      } else if (currentNode.params.module.name == \"RTL\") {\n        coordArr.push(coordArr[1]);\n        coordArr.push(coordArr[0]);\n      } else {\n        coordArr.push([currentNode.params.lng.value, currentNode.params.lat.value, Number(currentNode.params.alt.value)]);\n      }\n      if (currentNode.params.module.name == \"Land\") {\n        coordArr.push([currentNode.params.lng.value, currentNode.params.lat.value, 0]);\n      }\n    }\n    this.route = route;\n    return coordArr;\n  }\n  updateLineGeometry(route) {\n    if (this.routeLine) {\n      let coordsArr = this.getCoordArr(route);\n      let cords_AMS = [];\n      for (let item in coordsArr) {\n        if (item < coordsArr.length - 1) {\n          if (coordsArr[item][2] == 0) {\n            cords_AMS.push([coordsArr[item][0], coordsArr[item][1], this.manager3d.getAMS({\n              lng: coordsArr[item][0],\n              lat: coordsArr[item][1]\n            })]);\n          } else if (coordsArr[Number(item) + 1][2] == 0) {\n            cords_AMS.push([coordsArr[Number(item) + 1][0], coordsArr[Number(item) + 1][1], this.manager3d.getAMS({\n              lng: coordsArr[Number(item) + 1][0],\n              lat: coordsArr[Number(item) + 1][1]\n            })]);\n          } else if (coordsArr[item][2] != 0 && coordsArr[Number(item) + 1][2] != 0) {\n            let segmCoords = segmentateLine(coordsArr[item], coordsArr[Number(item) + 1], 10, this.manager3d);\n            cords_AMS = cords_AMS.concat(segmCoords.cords_AMS);\n          }\n        }\n      }\n      this.routeLine.setGeometry_(cords_AMS, this.routeLine);\n    }\n  }\n  unitSpheres(route, arr = null) {\n    let coordsArr = arr ? arr : this.getCoordArr(route);\n    if (this.routeLine) {\n      tb.remove(this.routeLine);\n      for (let i in this.objects) {\n        if (this.objects[i] == this.routeLine) {\n          this.objects.splice(i, 1);\n        }\n      }\n    }\n    if (coordsArr.length > 1) {\n      let cords_AMS = [];\n      for (let item in coordsArr) {\n        if (item < coordsArr.length - 1) {\n          if (coordsArr[item][2] == 0) {\n            cords_AMS.push([coordsArr[item][0], coordsArr[item][1], this.manager3d.getAMS({\n              lng: coordsArr[item][0],\n              lat: coordsArr[item][1]\n            })]);\n          } else if (coordsArr[Number(item) + 1][2] == 0) {\n            cords_AMS.push([coordsArr[Number(item) + 1][0], coordsArr[Number(item) + 1][1], this.manager3d.getAMS({\n              lng: coordsArr[Number(item) + 1][0],\n              lat: coordsArr[Number(item) + 1][1]\n            })]);\n          } else if (coordsArr[item][2] != 0 && coordsArr[Number(item) + 1][2] != 0) {\n            let segmCoords = segmentateLine(coordsArr[item], coordsArr[Number(item) + 1], 10, this.manager3d);\n            cords_AMS = cords_AMS.concat(segmCoords.cords_AMS);\n          }\n        }\n      }\n      let routeLineOptions = this.manager3d.getMeshOptions(\"line_1\");\n      routeLineOptions.geometry = cords_AMS;\n      this.routeLine = tb.line(routeLineOptions);\n      tb.add(this.routeLine, \"custom-layer\");\n      this.objects.push(this.routeLine);\n    }\n  }\n  changeAlt(value, id, route) {\n    let sphereCoords = [];\n    for (let sphere of this.sphereArr) {\n      if (sphere.id == id) {\n        sphere.object.setCoords([sphere.object.coordinates[0], sphere.object.coordinates[1], Number(value) + this.manager3d.getAMS({\n          lng: sphere.object.coordinates[0],\n          lat: sphere.object.coordinates[1]\n        })]);\n        sphereCoords.push([sphere.object.coordinates[0], sphere.object.coordinates[1]]);\n        sphere.baseCoords[2] = Number(value);\n      }\n    }\n    this.updateLineGeometry(route);\n  }\n  changeCoords(coords, id) {\n    for (let sphere of this.sphereArr) {\n      if (sphere.id == id) {\n        sphere.object.setCoords([coords[0], coords[1], sphere.baseCoords[2] + this.manager3d.getAMS({\n          lng: coords[0],\n          lat: coords[1]\n        })]);\n        sphere.baseCoords = [coords[0], coords[1], sphere.baseCoords[2]];\n      }\n    }\n  }\n  clearTb(deleteAll = false) {\n    for (let object of this.objects) {\n      tb.remove(object);\n    }\n    ;\n    this.idSphereArr = [];\n    this.routeLine = null;\n    this.sphereArr = [];\n    this.objects = [];\n    if (deleteAll) {\n      this.map.removeLayer('custom_layer');\n    }\n  }\n  deleteObject(id) {\n    for (let element of this.sphereArr) {\n      if (element.id == id) {\n        tb.remove(element.object);\n      }\n    }\n  }\n  changeMode() {\n    for (let id in this.sphereArr) {\n      let z = [this.sphereArr[id].baseCoords[0], this.sphereArr[id].baseCoords[1], this.sphereArr[id].baseCoords[2] + this.manager3d.getAMS({\n        lng: this.sphereArr[id].baseCoords[0],\n        lat: this.sphereArr[id].baseCoords[1]\n      })];\n      this.sphereArr[id].object.setCoords(z);\n    }\n    if (this.route) {\n      this.unitSpheres(this.route);\n    }\n  }\n  changeScale() {}\n}","map":{"version":3,"names":["waypointIcon","booleanPointInPolygon","lineChunk","lineString","lineIntersect","lineSlice","length","point","polygon","getIntersectAlt","l1","l2","l3","line1","line2","Math","max","intersects","features","geometry","coordinates","calcDistance","point1","point2","line","start","stop","units","segmentateLine","segmentProcent","manager3D","flag","pwa1","pwa2","distance","interval","cords","cords_AMS","z","type","properties","map","feature","alt","push","getAMS","lng","lat","getFeatures","segment","manager3d","project","x","y","feat","queryRenderedFeatures","console","log","height","featHeight","SprayManager3d","constructor","objects","sphereArr","routeLine","route","selected_features","warnings","warningsBuildings","helpLines","changeMode","bind","addSphere","coords","elementID","sphereOptions","getMeshOptions","pointSphere","tb","sphere","setCoords","sphereObject","object","id","baseCoords","add","setCurrentSphere","setZoom","getZoom","getCoordArr","currentNode","head","coordArr","tail","next","params","value","module","name","coord","markup","Number","updateLineGeometry","coordsArr","item","segmCoords","concat","setGeometry_","unitSpheres","arr","remove","i","splice","routeLineOptions","changeAlt","sphereCoords","changeCoords","clearTb","deleteAll","idSphereArr","removeLayer","deleteObject","element","changeScale"],"sources":["/Users/mihailbaleev/Documents/GitHub/lastochka_spraying/src/Spraying/manager3D.js"],"sourcesContent":["import waypointIcon from '../RouteConstructor/BRM/Waypoint/icon_map_waypoint.png';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\n\nimport { lineChunk, lineString, lineIntersect, lineSlice, length, point, polygon } from '@turf/turf'\nfunction getIntersectAlt(l1, l2, l3) {\n    if(l1[0] != l2[0]){\n        let line1 = lineString([\n            [l1[0], l1[2]],\n            [l2[0], l2[2]]\n        ])\n        let line2 = lineString([\n            [l3[0], 0],\n            [l3[0], Math.max(l1[2], l2[2])]\n        ])\n        let intersects = lineIntersect(line1, line2)\n        return intersects.features[0].geometry.coordinates[1]\n    }\n    else if(l1[1] != l2[1]){\n        let line1 = lineString([\n            [l1[1], l1[2]],\n            [l2[1], l2[2]]\n        ])\n        let line2 = lineString([\n            [l3[1], 0],\n            [l3[1], Math.max(l1[2], l2[2])]\n        ])\n        let intersects = lineIntersect(line1, line2)\n        return intersects.features[0].geometry.coordinates[1]\n    }\n}\n\nfunction calcDistance(point1, point2) {\n    var line = {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n          {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\n              \"type\": \"LineString\",\n              \"coordinates\": [\n                point1, \n                point2\n              ]\n            }\n          }\n        ]\n      };\n      \n      var start = {\n        \"type\": \"Feature\",\n        \"properties\": {},\n        \"geometry\": {\n          \"type\": \"Point\",\n          \"coordinates\": point1\n        }\n      };\n      var stop = {\n        \"type\": \"Feature\",\n        \"properties\": {},\n        \"geometry\": {\n          \"type\": \"Point\",\n          \"coordinates\": point2\n        }\n      };\n      return length(lineSlice(start, stop, line.features[0]), {units: 'meters'})\n}\nfunction segmentateLine(point1, point2, segmentProcent, manager3D, flag=false) {\n    let pwa1 = [\n        point1[0],\n        point1[1]\n    ]\n    let pwa2 = [\n        point2[0],\n        point2[1]\n    ]\n\n    let distance = calcDistance(\n        pwa1, \n        pwa2\n        )\n    let interval = 0;\n    if(flag){\n        interval = 1/1000\n    }\n    else{\n        interval = distance/1000*(segmentProcent/100)\n    }\n    let cords = []\n    let cords_AMS = []\n\n    let z = [...lineChunk({\n        type: 'Feature',\n        geometry: {\n            type: 'LineString',\n            coordinates: [\n                pwa1,\n                pwa2\n            ]\n        },\n        properties: {}\n        }, distance/1000*(segmentProcent/100)).features.map((feature) => {\n            let alt;\n            //console.log(pwa1, pwa2, feature.geometry.coordinates[0])\n            if(pwa1[0] == feature.geometry.coordinates[0][0] && pwa1[1] == feature.geometry.coordinates[0][1]){\n                alt = point1[2]\n            }\n            else if(pwa2[0] == feature.geometry.coordinates[0][0] && pwa2[1] == feature.geometry.coordinates[0][1]){\n                alt = point2[2]\n            }\n            else if(point1[2] == point2[2]){\n                alt = point1[2]\n            }\n            else{\n                alt = getIntersectAlt(\n                    point1, \n                    point2, \n                    feature.geometry.coordinates[0]\n                )\n            }\n\n            cords.push([\n                ...feature.geometry.coordinates[0],\n                alt\n            ])\n            cords_AMS.push([\n                ...feature.geometry.coordinates[0],\n                alt+manager3D.getAMS({\n                    lng:feature.geometry.coordinates[0][0],\n                    lat:feature.geometry.coordinates[0][1]\n                })\n            ])\n            return \n    \n        })\n    ]\n\n    cords.push(point2)\n    cords_AMS.push([\n        point2[0],\n        point2[1],\n        point2[2]+manager3D.getAMS({\n            lng:point2[0],\n            lat:point2[1]\n        })\n    ])\n\n    return {\n        cords:cords,\n        cords_AMS:cords_AMS\n    }\n}\n\nasync function getFeatures(segment, manager3d) {\n    let cords = manager3d.map.project({lng:segment[0], lat:segment[1]})\n    cords = [cords.x, cords.y]\n    let feat = manager3d.map.queryRenderedFeatures(cords)\n    console.log(feat)\n    if (feat.length != 0 && feat[0].properties.height >= segment[2]){\n        return {\n            feat: feat[0],\n            cords: segment,\n            featHeight: feat[0].properties.height\n        }\n    }\n}\n\nexport class SprayManager3d{\n    constructor(manager3d){\n        this.manager3d = manager3d;\n        this.objects = [];\n        this.sphereArr = [];\n        this.routeLine = null;\n        this.route = null\n        this.selected_features = []\n        this.warnings = []\n        this.warningsBuildings = []\n        this.helpLines = []\n        this.changeMode = this.changeMode.bind(this);\n    }\n\n    addSphere(coords, elementID){\n        let sphereOptions = this.manager3d.getMeshOptions(\"sphere_1\")\n        let pointSphere = tb.sphere(sphereOptions)\n        pointSphere.setCoords([\n            coords[0],\n            coords[1], \n            coords[2]+this.manager3d.getAMS({\n                lng:coords[0],\n                lat:coords[1]\n            })\n        ])\n\n        let sphereObject = {\n            object: pointSphere,\n            id: elementID,\n            baseCoords: coords\n        }\n        \n        tb.add(pointSphere)\n        this.objects.push(pointSphere)\n        this.sphereArr.push(sphereObject)\n        this.setCurrentSphere(elementID);\n\n        this.manager3d.map.setZoom(this.manager3d.map.getZoom())\n    }\n\n    getCoordArr(route){\n        let currentNode = route.head\n        let coordArr = [] \n        while (currentNode != route.tail){\n            currentNode = currentNode.next \n            if(currentNode == route.head.next){\n                coordArr.push([\n                    currentNode.params.lng.value,\n                    currentNode.params.lat.value,\n                    0\n                ])\n            }\n\n            if (currentNode.params.module.name == \"Polygon\"){\n                for (let coord of currentNode.params.markup.value){\n                    coordArr.push([\n                        coord[0], \n                        coord[1], \n                        Number(currentNode.params.alt.value)\n                    ])\n                }\n            }else if (currentNode.params.module.name == \"RTL\"){\n             coordArr.push(coordArr[1])\n             coordArr.push(coordArr[0])\n            }else{\n                coordArr.push([\n                    currentNode.params.lng.value,\n                    currentNode.params.lat.value,\n                    Number(currentNode.params.alt.value)\n                ])\n            }\n            if(currentNode.params.module.name == \"Land\"){\n                coordArr.push([\n                    currentNode.params.lng.value,\n                    currentNode.params.lat.value,\n                    0\n                ])\n            }\n        }\n        this.route = route\n        return coordArr\n    }\n\n    updateLineGeometry(route){\n        if (this.routeLine){\n            let coordsArr = this.getCoordArr(route)\n            let cords_AMS = []\n            for (let item in coordsArr){\n                if (item < coordsArr.length-1){\n                    \n                    \n                    if(coordsArr[item][2] == 0){\n                        cords_AMS.push([\n                            coordsArr[item][0],\n                            coordsArr[item][1],\n                            this.manager3d.getAMS({\n                                lng:coordsArr[item][0],\n                                lat:coordsArr[item][1]\n                            })\n                        ])\n                    }\n                    else if(coordsArr[Number(item)+1][2] == 0){\n                        cords_AMS.push([\n                            coordsArr[Number(item)+1][0],\n                            coordsArr[Number(item)+1][1],\n                            this.manager3d.getAMS({\n                                lng:coordsArr[Number(item)+1][0],\n                                lat:coordsArr[Number(item)+1][1]\n                            })\n                        ])\n                    }\n                    else if(coordsArr[item][2] != 0 && coordsArr[Number(item)+1][2] != 0){\n                        let segmCoords = segmentateLine(coordsArr[item], coordsArr[Number(item)+1], 10, this.manager3d)\n                        cords_AMS = cords_AMS.concat(segmCoords.cords_AMS)\n                    }\n                }\n            }\n            this.routeLine.setGeometry_(cords_AMS, this.routeLine)\n        }\n    }\n\n    unitSpheres(route, arr = null){\n        let coordsArr = (arr)?arr:this.getCoordArr(route)\n        if (this.routeLine){\n            tb.remove(this.routeLine)\n            for (let i in this.objects){\n                if (this.objects[i] == this.routeLine){\n                    this.objects.splice(i, 1)\n                }\n            }\n        }\n        if (coordsArr.length > 1){\n            let cords_AMS = []\n            for (let item in coordsArr){\n                if (item < coordsArr.length-1){\n                    if(coordsArr[item][2] == 0){\n                        cords_AMS.push([\n                            coordsArr[item][0],\n                            coordsArr[item][1],\n                            this.manager3d.getAMS({\n                                lng:coordsArr[item][0],\n                                lat:coordsArr[item][1]\n                            })\n                        ])\n                    }\n                    else if(coordsArr[Number(item)+1][2] == 0){\n                        cords_AMS.push([\n                            coordsArr[Number(item)+1][0],\n                            coordsArr[Number(item)+1][1],\n                            this.manager3d.getAMS({\n                                lng:coordsArr[Number(item)+1][0],\n                                lat:coordsArr[Number(item)+1][1]\n                            })\n                        ])\n                    }\n                    else if(coordsArr[item][2] != 0 && coordsArr[Number(item)+1][2] != 0){\n                        let segmCoords = segmentateLine(coordsArr[item], coordsArr[Number(item)+1], 10, this.manager3d)\n                        cords_AMS = cords_AMS.concat(segmCoords.cords_AMS)\n                    }\n                }\n            }\n            let routeLineOptions = this.manager3d.getMeshOptions(\"line_1\")\n            routeLineOptions.geometry = cords_AMS\n            this.routeLine = tb.line(routeLineOptions)\n            tb.add(this.routeLine, \"custom-layer\")\n            this.objects.push(this.routeLine)\n        }\n    }\n\n    changeAlt(value, id, route){\n        let sphereCoords = []\n        for (let sphere of this.sphereArr){\n            if (sphere.id == id){\n                sphere.object.setCoords([\n                    sphere.object.coordinates[0], \n                    sphere.object.coordinates[1], \n                    Number(value)+this.manager3d.getAMS({\n                        lng: sphere.object.coordinates[0],\n                        lat: sphere.object.coordinates[1]\n                    })])\n                sphereCoords.push([sphere.object.coordinates[0], sphere.object.coordinates[1]])\n                sphere.baseCoords[2] = Number(value)\n            }\n        }\n        this.updateLineGeometry(route)\n    }\n    changeCoords(coords, id){\n        for (let sphere of this.sphereArr){\n            if (sphere.id == id){\n                sphere.object.setCoords([\n                    coords[0], \n                    coords[1], \n                    sphere.baseCoords[2]+this.manager3d.getAMS({\n                        lng:coords[0],\n                        lat:coords[1]\n                    })\n                ])\n                sphere.baseCoords = [coords[0], coords[1], sphere.baseCoords[2]]\n            }\n        }\n    }\n    clearTb(deleteAll = false){\n        for (let object of this.objects){\n            tb.remove(object)\n        };\n        this.idSphereArr = []\n        this.routeLine = null;\n        this.sphereArr = []\n        this.objects = []\n        if (deleteAll){\n            this.map.removeLayer('custom_layer')\n        }\n    }\n    deleteObject(id){\n        for (let element of this.sphereArr){\n            if (element.id == id){\n                tb.remove(element.object)\n            }\n        }\n    }\n    changeMode(){\n        for (let id in this.sphereArr){\n            let z = [\n                this.sphereArr[id].baseCoords[0],\n                this.sphereArr[id].baseCoords[1],\n                this.sphereArr[id].baseCoords[2]+this.manager3d.getAMS({\n                    lng:this.sphereArr[id].baseCoords[0],\n                    lat:this.sphereArr[id].baseCoords[1]\n                })\n            ]\n            this.sphereArr[id].object.setCoords(z)\n        }\n        if (this.route){\n            this.unitSpheres(this.route)\n        }\n    }\n    changeScale(){\n        \n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
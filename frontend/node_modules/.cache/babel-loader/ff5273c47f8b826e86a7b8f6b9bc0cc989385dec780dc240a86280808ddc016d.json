{"ast":null,"code":"/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\nconst THREE = require('../../three.js');\n(function () {\n  const _object_pattern = /^[og]\\s*(.+)?/; // mtllib file_reference\n\n  const _material_library_pattern = /^mtllib /; // usemtl material_name\n\n  const _material_use_pattern = /^usemtl /; // usemap map_name\n\n  const _map_use_pattern = /^usemap /;\n  const _vA = new THREE.Vector3();\n  const _vB = new THREE.Vector3();\n  const _vC = new THREE.Vector3();\n  const _ab = new THREE.Vector3();\n  const _cb = new THREE.Vector3();\n  function ParserState() {\n    const state = {\n      objects: [],\n      object: {},\n      vertices: [],\n      normals: [],\n      colors: [],\n      uvs: [],\n      materials: {},\n      materialLibraries: [],\n      startObject: function (name, fromDeclaration) {\n        // If the current object (initial from reset) is not from a g/o declaration in the parsed\n        // file. We need to use it for the first parsed g/o to keep things in sync.\n        if (this.object && this.object.fromDeclaration === false) {\n          this.object.name = name;\n          this.object.fromDeclaration = fromDeclaration !== false;\n          return;\n        }\n        const previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n        if (this.object && typeof this.object._finalize === 'function') {\n          this.object._finalize(true);\n        }\n        this.object = {\n          name: name || '',\n          fromDeclaration: fromDeclaration !== false,\n          geometry: {\n            vertices: [],\n            normals: [],\n            colors: [],\n            uvs: [],\n            hasUVIndices: false\n          },\n          materials: [],\n          smooth: true,\n          startMaterial: function (name, libraries) {\n            const previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared\n            // after the material, then it must be preserved for proper MultiMaterial continuation.\n\n            if (previous && (previous.inherited || previous.groupCount <= 0)) {\n              this.materials.splice(previous.index, 1);\n            }\n            const material = {\n              index: this.materials.length,\n              name: name || '',\n              mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n              smooth: previous !== undefined ? previous.smooth : this.smooth,\n              groupStart: previous !== undefined ? previous.groupEnd : 0,\n              groupEnd: -1,\n              groupCount: -1,\n              inherited: false,\n              clone: function (index) {\n                const cloned = {\n                  index: typeof index === 'number' ? index : this.index,\n                  name: this.name,\n                  mtllib: this.mtllib,\n                  smooth: this.smooth,\n                  groupStart: 0,\n                  groupEnd: -1,\n                  groupCount: -1,\n                  inherited: false\n                };\n                cloned.clone = this.clone.bind(cloned);\n                return cloned;\n              }\n            };\n            this.materials.push(material);\n            return material;\n          },\n          currentMaterial: function () {\n            if (this.materials.length > 0) {\n              return this.materials[this.materials.length - 1];\n            }\n            return undefined;\n          },\n          _finalize: function (end) {\n            const lastMultiMaterial = this.currentMaterial();\n            if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n              lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n              lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n              lastMultiMaterial.inherited = false;\n            } // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\n            if (end && this.materials.length > 1) {\n              for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n                if (this.materials[mi].groupCount <= 0) {\n                  this.materials.splice(mi, 1);\n                }\n              }\n            } // Guarantee at least one empty material, this makes the creation later more straight forward.\n\n            if (end && this.materials.length === 0) {\n              this.materials.push({\n                name: '',\n                smooth: this.smooth\n              });\n            }\n            return lastMultiMaterial;\n          }\n        }; // Inherit previous objects material.\n        // Spec tells us that a declared material must be set to all objects until a new material is declared.\n        // If a usemtl declaration is encountered while this new object is being parsed, it will\n        // overwrite the inherited material. Exception being that there was already face declarations\n        // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n        if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n          const declared = previousMaterial.clone(0);\n          declared.inherited = true;\n          this.object.materials.push(declared);\n        }\n        this.objects.push(this.object);\n      },\n      finalize: function () {\n        if (this.object && typeof this.object._finalize === 'function') {\n          this.object._finalize(true);\n        }\n      },\n      parseVertexIndex: function (value, len) {\n        const index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 3) * 3;\n      },\n      parseNormalIndex: function (value, len) {\n        const index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 3) * 3;\n      },\n      parseUVIndex: function (value, len) {\n        const index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 2) * 2;\n      },\n      addVertex: function (a, b, c) {\n        const src = this.vertices;\n        const dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addVertexPoint: function (a) {\n        const src = this.vertices;\n        const dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      },\n      addVertexLine: function (a) {\n        const src = this.vertices;\n        const dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      },\n      addNormal: function (a, b, c) {\n        const src = this.normals;\n        const dst = this.object.geometry.normals;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addFaceNormal: function (a, b, c) {\n        const src = this.vertices;\n        const dst = this.object.geometry.normals;\n        _vA.fromArray(src, a);\n        _vB.fromArray(src, b);\n        _vC.fromArray(src, c);\n        _cb.subVectors(_vC, _vB);\n        _ab.subVectors(_vA, _vB);\n        _cb.cross(_ab);\n        _cb.normalize();\n        dst.push(_cb.x, _cb.y, _cb.z);\n        dst.push(_cb.x, _cb.y, _cb.z);\n        dst.push(_cb.x, _cb.y, _cb.z);\n      },\n      addColor: function (a, b, c) {\n        const src = this.colors;\n        const dst = this.object.geometry.colors;\n        if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addUV: function (a, b, c) {\n        const src = this.uvs;\n        const dst = this.object.geometry.uvs;\n        dst.push(src[a + 0], src[a + 1]);\n        dst.push(src[b + 0], src[b + 1]);\n        dst.push(src[c + 0], src[c + 1]);\n      },\n      addDefaultUV: function () {\n        const dst = this.object.geometry.uvs;\n        dst.push(0, 0);\n        dst.push(0, 0);\n        dst.push(0, 0);\n      },\n      addUVLine: function (a) {\n        const src = this.uvs;\n        const dst = this.object.geometry.uvs;\n        dst.push(src[a + 0], src[a + 1]);\n      },\n      addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n        const vLen = this.vertices.length;\n        let ia = this.parseVertexIndex(a, vLen);\n        let ib = this.parseVertexIndex(b, vLen);\n        let ic = this.parseVertexIndex(c, vLen);\n        this.addVertex(ia, ib, ic);\n        this.addColor(ia, ib, ic); // normals\n\n        if (na !== undefined && na !== '') {\n          const nLen = this.normals.length;\n          ia = this.parseNormalIndex(na, nLen);\n          ib = this.parseNormalIndex(nb, nLen);\n          ic = this.parseNormalIndex(nc, nLen);\n          this.addNormal(ia, ib, ic);\n        } else {\n          this.addFaceNormal(ia, ib, ic);\n        } // uvs\n\n        if (ua !== undefined && ua !== '') {\n          const uvLen = this.uvs.length;\n          ia = this.parseUVIndex(ua, uvLen);\n          ib = this.parseUVIndex(ub, uvLen);\n          ic = this.parseUVIndex(uc, uvLen);\n          this.addUV(ia, ib, ic);\n          this.object.geometry.hasUVIndices = true;\n        } else {\n          // add placeholder values (for inconsistent face definitions)\n          this.addDefaultUV();\n        }\n      },\n      addPointGeometry: function (vertices) {\n        this.object.geometry.type = 'Points';\n        const vLen = this.vertices.length;\n        for (let vi = 0, l = vertices.length; vi < l; vi++) {\n          const index = this.parseVertexIndex(vertices[vi], vLen);\n          this.addVertexPoint(index);\n          this.addColor(index);\n        }\n      },\n      addLineGeometry: function (vertices, uvs) {\n        this.object.geometry.type = 'Line';\n        const vLen = this.vertices.length;\n        const uvLen = this.uvs.length;\n        for (let vi = 0, l = vertices.length; vi < l; vi++) {\n          this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n        }\n        for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n          this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n        }\n      }\n    };\n    state.startObject('', false);\n    return state;\n  } //\n\n  class OBJLoader extends THREE.Loader {\n    constructor(manager) {\n      super(manager);\n      this.materials = null;\n    }\n    load(url, onLoad, onProgress, onError) {\n      const scope = this;\n      const loader = new THREE.FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n    setMaterials(materials) {\n      this.materials = materials;\n      return this;\n    }\n    parse(text) {\n      const state = new ParserState();\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n      if (text.indexOf('\\\\\\n') !== -1) {\n        // join lines separated by a line continuation character (\\)\n        text = text.replace(/\\\\\\n/g, '');\n      }\n      const lines = text.split('\\n');\n      let line = '',\n        lineFirstChar = '';\n      let lineLength = 0;\n      let result = []; // Faster to just trim left side of the line. Use if available.\n\n      const trimLeft = typeof ''.trimLeft === 'function';\n      for (let i = 0, l = lines.length; i < l; i++) {\n        line = lines[i];\n        line = trimLeft ? line.trimLeft() : line.trim();\n        lineLength = line.length;\n        if (lineLength === 0) continue;\n        lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any\n\n        if (lineFirstChar === '#') continue;\n        if (lineFirstChar === 'v') {\n          const data = line.split(/\\s+/);\n          switch (data[0]) {\n            case 'v':\n              state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n              if (data.length >= 7) {\n                state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n              } else {\n                // if no colors are defined, add placeholders so color and vertex indices match\n                state.colors.push(undefined, undefined, undefined);\n              }\n              break;\n            case 'vn':\n              state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n              break;\n            case 'vt':\n              state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n              break;\n          }\n        } else if (lineFirstChar === 'f') {\n          const lineData = line.substr(1).trim();\n          const vertexData = lineData.split(/\\s+/);\n          const faceVertices = []; // Parse the face vertex data into an easy to work with format\n\n          for (let j = 0, jl = vertexData.length; j < jl; j++) {\n            const vertex = vertexData[j];\n            if (vertex.length > 0) {\n              const vertexParts = vertex.split('/');\n              faceVertices.push(vertexParts);\n            }\n          } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n          const v1 = faceVertices[0];\n          for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n            const v2 = faceVertices[j];\n            const v3 = faceVertices[j + 1];\n            state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n          }\n        } else if (lineFirstChar === 'l') {\n          const lineParts = line.substring(1).trim().split(' ');\n          let lineVertices = [];\n          const lineUVs = [];\n          if (line.indexOf('/') === -1) {\n            lineVertices = lineParts;\n          } else {\n            for (let li = 0, llen = lineParts.length; li < llen; li++) {\n              const parts = lineParts[li].split('/');\n              if (parts[0] !== '') lineVertices.push(parts[0]);\n              if (parts[1] !== '') lineUVs.push(parts[1]);\n            }\n          }\n          state.addLineGeometry(lineVertices, lineUVs);\n        } else if (lineFirstChar === 'p') {\n          const lineData = line.substr(1).trim();\n          const pointData = lineData.split(' ');\n          state.addPointGeometry(pointData);\n        } else if ((result = _object_pattern.exec(line)) !== null) {\n          // o object_name\n          // or\n          // g group_name\n          // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n          // let name = result[ 0 ].substr( 1 ).trim();\n          const name = (' ' + result[0].substr(1).trim()).substr(1);\n          state.startObject(name);\n        } else if (_material_use_pattern.test(line)) {\n          // material\n          state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n        } else if (_material_library_pattern.test(line)) {\n          // mtl file\n          state.materialLibraries.push(line.substring(7).trim());\n        } else if (_map_use_pattern.test(line)) {\n          // the line is parsed but ignored since the loader assumes textures are defined MTL files\n          // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n          console.warn('THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.');\n        } else if (lineFirstChar === 's') {\n          result = line.split(' '); // smooth shading\n          // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n          // but does not define a usemtl for each face set.\n          // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n          // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n          // where explicit usemtl defines geometry groups.\n          // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n          /*\r\n          * http://paulbourke.net/dataformats/obj/\r\n          * or\r\n          * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\r\n          *\r\n          * From chapter \"Grouping\" Syntax explanation \"s group_number\":\r\n          * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\r\n          * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\r\n          * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\r\n          * than 0.\"\r\n          */\n\n          if (result.length > 1) {\n            const value = result[1].trim().toLowerCase();\n            state.object.smooth = value !== '0' && value !== 'off';\n          } else {\n            // ZBrush can produce \"s\" lines #11707\n            state.object.smooth = true;\n          }\n          const material = state.object.currentMaterial();\n          if (material) material.smooth = state.object.smooth;\n        } else {\n          // Handle null terminated files without exception\n          if (line === '\\0') continue;\n          console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n        }\n      }\n      state.finalize();\n      const container = new THREE.Group();\n      container.materialLibraries = [].concat(state.materialLibraries);\n      const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);\n      if (hasPrimitives === true) {\n        for (let i = 0, l = state.objects.length; i < l; i++) {\n          const object = state.objects[i];\n          const geometry = object.geometry;\n          const materials = object.materials;\n          const isLine = geometry.type === 'Line';\n          const isPoints = geometry.type === 'Points';\n          let hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces\n\n          if (geometry.vertices.length === 0) continue;\n          const buffergeometry = new THREE.BufferGeometry();\n          buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));\n          if (geometry.normals.length > 0) {\n            buffergeometry.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));\n          }\n          if (geometry.colors.length > 0) {\n            hasVertexColors = true;\n            buffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));\n          }\n          if (geometry.hasUVIndices === true) {\n            buffergeometry.setAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));\n          } // Create materials\n\n          const createdMaterials = [];\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            const sourceMaterial = materials[mi];\n            const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n            let material = state.materials[materialHash];\n            if (this.materials !== null) {\n              material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\n              if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {\n                const materialLine = new THREE.LineBasicMaterial();\n                THREE.Material.prototype.copy.call(materialLine, material);\n                materialLine.color.copy(material.color);\n                material = materialLine;\n              } else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {\n                const materialPoints = new THREE.PointsMaterial({\n                  size: 10,\n                  sizeAttenuation: false\n                });\n                THREE.Material.prototype.copy.call(materialPoints, material);\n                materialPoints.color.copy(material.color);\n                materialPoints.map = material.map;\n                material = materialPoints;\n              }\n            }\n            if (material === undefined) {\n              if (isLine) {\n                material = new THREE.LineBasicMaterial();\n              } else if (isPoints) {\n                material = new THREE.PointsMaterial({\n                  size: 1,\n                  sizeAttenuation: false\n                });\n              } else {\n                material = new THREE.MeshPhongMaterial();\n              }\n              material.name = sourceMaterial.name;\n              material.flatShading = sourceMaterial.smooth ? false : true;\n              material.vertexColors = hasVertexColors;\n              state.materials[materialHash] = material;\n            }\n            createdMaterials.push(material);\n          } // Create mesh\n\n          let mesh;\n          if (createdMaterials.length > 1) {\n            for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n              const sourceMaterial = materials[mi];\n              buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n            }\n            if (isLine) {\n              mesh = new THREE.LineSegments(buffergeometry, createdMaterials);\n            } else if (isPoints) {\n              mesh = new THREE.Points(buffergeometry, createdMaterials);\n            } else {\n              mesh = new THREE.Mesh(buffergeometry, createdMaterials);\n            }\n          } else {\n            if (isLine) {\n              mesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);\n            } else if (isPoints) {\n              mesh = new THREE.Points(buffergeometry, createdMaterials[0]);\n            } else {\n              mesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);\n            }\n          }\n          mesh.name = object.name;\n          container.add(mesh);\n        }\n      } else {\n        // if there is only the default parser state object with no geometry data, interpret data as point cloud\n        if (state.vertices.length > 0) {\n          const material = new THREE.PointsMaterial({\n            size: 1,\n            sizeAttenuation: false\n          });\n          const buffergeometry = new THREE.BufferGeometry();\n          buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(state.vertices, 3));\n          if (state.colors.length > 0 && state.colors[0] !== undefined) {\n            buffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(state.colors, 3));\n            material.vertexColors = true;\n          }\n          const points = new THREE.Points(buffergeometry, material);\n          container.add(points);\n        }\n      }\n      return container;\n    }\n  }\n  THREE.OBJLoader = OBJLoader;\n})();\nmodule.exports = exports = THREE.OBJLoader;","map":{"version":3,"names":["THREE","require","_object_pattern","_material_library_pattern","_material_use_pattern","_map_use_pattern","_vA","Vector3","_vB","_vC","_ab","_cb","ParserState","state","objects","object","vertices","normals","colors","uvs","materials","materialLibraries","startObject","name","fromDeclaration","previousMaterial","currentMaterial","undefined","_finalize","geometry","hasUVIndices","smooth","startMaterial","libraries","previous","inherited","groupCount","splice","index","material","length","mtllib","Array","isArray","groupStart","groupEnd","clone","cloned","bind","push","end","lastMultiMaterial","mi","declared","finalize","parseVertexIndex","value","len","parseInt","parseNormalIndex","parseUVIndex","addVertex","a","b","c","src","dst","addVertexPoint","addVertexLine","addNormal","addFaceNormal","fromArray","subVectors","cross","normalize","x","y","z","addColor","addUV","addDefaultUV","addUVLine","addFace","ua","ub","uc","na","nb","nc","vLen","ia","ib","ic","nLen","uvLen","addPointGeometry","type","vi","l","addLineGeometry","uvi","OBJLoader","Loader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterials","indexOf","replace","lines","split","line","lineFirstChar","lineLength","result","trimLeft","i","trim","charAt","data","parseFloat","lineData","substr","vertexData","faceVertices","j","jl","vertex","vertexParts","v1","v2","v3","lineParts","substring","lineVertices","lineUVs","li","llen","parts","pointData","exec","test","warn","toLowerCase","container","Group","concat","hasPrimitives","isLine","isPoints","hasVertexColors","buffergeometry","BufferGeometry","setAttribute","Float32BufferAttribute","createdMaterials","miLen","sourceMaterial","materialHash","create","LineBasicMaterial","materialLine","Material","prototype","copy","call","color","PointsMaterial","materialPoints","size","sizeAttenuation","map","MeshPhongMaterial","flatShading","vertexColors","mesh","addGroup","LineSegments","Points","Mesh","add","points","module","exports"],"sources":["/Users/mihailbaleev/Documents/GitHub/Lastochka_spraying/frontend/node_modules/threebox-plugin/src/objects/loaders/OBJLoader.js"],"sourcesContent":["/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nconst THREE = require('../../three.js');\r\n\r\n(function () {\r\n\r\n\tconst _object_pattern = /^[og]\\s*(.+)?/; // mtllib file_reference\r\n\r\n\tconst _material_library_pattern = /^mtllib /; // usemtl material_name\r\n\r\n\tconst _material_use_pattern = /^usemtl /; // usemap map_name\r\n\r\n\tconst _map_use_pattern = /^usemap /;\r\n\r\n\tconst _vA = new THREE.Vector3();\r\n\r\n\tconst _vB = new THREE.Vector3();\r\n\r\n\tconst _vC = new THREE.Vector3();\r\n\r\n\tconst _ab = new THREE.Vector3();\r\n\r\n\tconst _cb = new THREE.Vector3();\r\n\r\n\tfunction ParserState() {\r\n\r\n\t\tconst state = {\r\n\t\t\tobjects: [],\r\n\t\t\tobject: {},\r\n\t\t\tvertices: [],\r\n\t\t\tnormals: [],\r\n\t\t\tcolors: [],\r\n\t\t\tuvs: [],\r\n\t\t\tmaterials: {},\r\n\t\t\tmaterialLibraries: [],\r\n\t\t\tstartObject: function (name, fromDeclaration) {\r\n\r\n\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\r\n\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\r\n\t\t\t\tif (this.object && this.object.fromDeclaration === false) {\r\n\r\n\t\t\t\t\tthis.object.name = name;\r\n\t\t\t\t\tthis.object.fromDeclaration = fromDeclaration !== false;\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\r\n\r\n\t\t\t\tif (this.object && typeof this.object._finalize === 'function') {\r\n\r\n\t\t\t\t\tthis.object._finalize(true);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.object = {\r\n\t\t\t\t\tname: name || '',\r\n\t\t\t\t\tfromDeclaration: fromDeclaration !== false,\r\n\t\t\t\t\tgeometry: {\r\n\t\t\t\t\t\tvertices: [],\r\n\t\t\t\t\t\tnormals: [],\r\n\t\t\t\t\t\tcolors: [],\r\n\t\t\t\t\t\tuvs: [],\r\n\t\t\t\t\t\thasUVIndices: false\r\n\t\t\t\t\t},\r\n\t\t\t\t\tmaterials: [],\r\n\t\t\t\t\tsmooth: true,\r\n\t\t\t\t\tstartMaterial: function (name, libraries) {\r\n\r\n\t\t\t\t\t\tconst previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared\r\n\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\r\n\r\n\r\n\t\t\t\t\t\tif (previous && (previous.inherited || previous.groupCount <= 0)) {\r\n\r\n\t\t\t\t\t\t\tthis.materials.splice(previous.index, 1);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tconst material = {\r\n\t\t\t\t\t\t\tindex: this.materials.length,\r\n\t\t\t\t\t\t\tname: name || '',\r\n\t\t\t\t\t\t\tmtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\r\n\t\t\t\t\t\t\tsmooth: previous !== undefined ? previous.smooth : this.smooth,\r\n\t\t\t\t\t\t\tgroupStart: previous !== undefined ? previous.groupEnd : 0,\r\n\t\t\t\t\t\t\tgroupEnd: - 1,\r\n\t\t\t\t\t\t\tgroupCount: - 1,\r\n\t\t\t\t\t\t\tinherited: false,\r\n\t\t\t\t\t\t\tclone: function (index) {\r\n\r\n\t\t\t\t\t\t\t\tconst cloned = {\r\n\t\t\t\t\t\t\t\t\tindex: typeof index === 'number' ? index : this.index,\r\n\t\t\t\t\t\t\t\t\tname: this.name,\r\n\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\r\n\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\r\n\t\t\t\t\t\t\t\t\tgroupStart: 0,\r\n\t\t\t\t\t\t\t\t\tgroupEnd: - 1,\r\n\t\t\t\t\t\t\t\t\tgroupCount: - 1,\r\n\t\t\t\t\t\t\t\t\tinherited: false\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind(cloned);\r\n\t\t\t\t\t\t\t\treturn cloned;\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tthis.materials.push(material);\r\n\t\t\t\t\t\treturn material;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tcurrentMaterial: function () {\r\n\r\n\t\t\t\t\t\tif (this.materials.length > 0) {\r\n\r\n\t\t\t\t\t\t\treturn this.materials[this.materials.length - 1];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn undefined;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\t_finalize: function (end) {\r\n\r\n\t\t\t\t\t\tconst lastMultiMaterial = this.currentMaterial();\r\n\r\n\t\t\t\t\t\tif (lastMultiMaterial && lastMultiMaterial.groupEnd === - 1) {\r\n\r\n\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\r\n\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\r\n\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\r\n\r\n\t\t\t\t\t\t} // Ignore objects tail materials if no face declarations followed them before a new o/g started.\r\n\r\n\r\n\t\t\t\t\t\tif (end && this.materials.length > 1) {\r\n\r\n\t\t\t\t\t\t\tfor (let mi = this.materials.length - 1; mi >= 0; mi--) {\r\n\r\n\t\t\t\t\t\t\t\tif (this.materials[mi].groupCount <= 0) {\r\n\r\n\t\t\t\t\t\t\t\t\tthis.materials.splice(mi, 1);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} // Guarantee at least one empty material, this makes the creation later more straight forward.\r\n\r\n\r\n\t\t\t\t\t\tif (end && this.materials.length === 0) {\r\n\r\n\t\t\t\t\t\t\tthis.materials.push({\r\n\t\t\t\t\t\t\t\tname: '',\r\n\t\t\t\t\t\t\t\tsmooth: this.smooth\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn lastMultiMaterial;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}; // Inherit previous objects material.\r\n\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\r\n\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\r\n\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\r\n\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\r\n\r\n\t\t\t\tif (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\r\n\r\n\t\t\t\t\tconst declared = previousMaterial.clone(0);\r\n\t\t\t\t\tdeclared.inherited = true;\r\n\t\t\t\t\tthis.object.materials.push(declared);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.objects.push(this.object);\r\n\r\n\t\t\t},\r\n\t\t\tfinalize: function () {\r\n\r\n\t\t\t\tif (this.object && typeof this.object._finalize === 'function') {\r\n\r\n\t\t\t\t\tthis.object._finalize(true);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\t\t\tparseVertexIndex: function (value, len) {\r\n\r\n\t\t\t\tconst index = parseInt(value, 10);\r\n\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 3) * 3;\r\n\r\n\t\t\t},\r\n\t\t\tparseNormalIndex: function (value, len) {\r\n\r\n\t\t\t\tconst index = parseInt(value, 10);\r\n\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 3) * 3;\r\n\r\n\t\t\t},\r\n\t\t\tparseUVIndex: function (value, len) {\r\n\r\n\t\t\t\tconst index = parseInt(value, 10);\r\n\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 2) * 2;\r\n\r\n\t\t\t},\r\n\t\t\taddVertex: function (a, b, c) {\r\n\r\n\t\t\t\tconst src = this.vertices;\r\n\t\t\t\tconst dst = this.object.geometry.vertices;\r\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\r\n\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\r\n\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\r\n\r\n\t\t\t},\r\n\t\t\taddVertexPoint: function (a) {\r\n\r\n\t\t\t\tconst src = this.vertices;\r\n\t\t\t\tconst dst = this.object.geometry.vertices;\r\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\r\n\r\n\t\t\t},\r\n\t\t\taddVertexLine: function (a) {\r\n\r\n\t\t\t\tconst src = this.vertices;\r\n\t\t\t\tconst dst = this.object.geometry.vertices;\r\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\r\n\r\n\t\t\t},\r\n\t\t\taddNormal: function (a, b, c) {\r\n\r\n\t\t\t\tconst src = this.normals;\r\n\t\t\t\tconst dst = this.object.geometry.normals;\r\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\r\n\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\r\n\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\r\n\r\n\t\t\t},\r\n\t\t\taddFaceNormal: function (a, b, c) {\r\n\r\n\t\t\t\tconst src = this.vertices;\r\n\t\t\t\tconst dst = this.object.geometry.normals;\r\n\r\n\t\t\t\t_vA.fromArray(src, a);\r\n\r\n\t\t\t\t_vB.fromArray(src, b);\r\n\r\n\t\t\t\t_vC.fromArray(src, c);\r\n\r\n\t\t\t\t_cb.subVectors(_vC, _vB);\r\n\r\n\t\t\t\t_ab.subVectors(_vA, _vB);\r\n\r\n\t\t\t\t_cb.cross(_ab);\r\n\r\n\t\t\t\t_cb.normalize();\r\n\r\n\t\t\t\tdst.push(_cb.x, _cb.y, _cb.z);\r\n\t\t\t\tdst.push(_cb.x, _cb.y, _cb.z);\r\n\t\t\t\tdst.push(_cb.x, _cb.y, _cb.z);\r\n\r\n\t\t\t},\r\n\t\t\taddColor: function (a, b, c) {\r\n\r\n\t\t\t\tconst src = this.colors;\r\n\t\t\t\tconst dst = this.object.geometry.colors;\r\n\t\t\t\tif (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);\r\n\t\t\t\tif (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);\r\n\t\t\t\tif (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);\r\n\r\n\t\t\t},\r\n\t\t\taddUV: function (a, b, c) {\r\n\r\n\t\t\t\tconst src = this.uvs;\r\n\t\t\t\tconst dst = this.object.geometry.uvs;\r\n\t\t\t\tdst.push(src[a + 0], src[a + 1]);\r\n\t\t\t\tdst.push(src[b + 0], src[b + 1]);\r\n\t\t\t\tdst.push(src[c + 0], src[c + 1]);\r\n\r\n\t\t\t},\r\n\t\t\taddDefaultUV: function () {\r\n\r\n\t\t\t\tconst dst = this.object.geometry.uvs;\r\n\t\t\t\tdst.push(0, 0);\r\n\t\t\t\tdst.push(0, 0);\r\n\t\t\t\tdst.push(0, 0);\r\n\r\n\t\t\t},\r\n\t\t\taddUVLine: function (a) {\r\n\r\n\t\t\t\tconst src = this.uvs;\r\n\t\t\t\tconst dst = this.object.geometry.uvs;\r\n\t\t\t\tdst.push(src[a + 0], src[a + 1]);\r\n\r\n\t\t\t},\r\n\t\t\taddFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\r\n\r\n\t\t\t\tconst vLen = this.vertices.length;\r\n\t\t\t\tlet ia = this.parseVertexIndex(a, vLen);\r\n\t\t\t\tlet ib = this.parseVertexIndex(b, vLen);\r\n\t\t\t\tlet ic = this.parseVertexIndex(c, vLen);\r\n\t\t\t\tthis.addVertex(ia, ib, ic);\r\n\t\t\t\tthis.addColor(ia, ib, ic); // normals\r\n\r\n\t\t\t\tif (na !== undefined && na !== '') {\r\n\r\n\t\t\t\t\tconst nLen = this.normals.length;\r\n\t\t\t\t\tia = this.parseNormalIndex(na, nLen);\r\n\t\t\t\t\tib = this.parseNormalIndex(nb, nLen);\r\n\t\t\t\t\tic = this.parseNormalIndex(nc, nLen);\r\n\t\t\t\t\tthis.addNormal(ia, ib, ic);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.addFaceNormal(ia, ib, ic);\r\n\r\n\t\t\t\t} // uvs\r\n\r\n\r\n\t\t\t\tif (ua !== undefined && ua !== '') {\r\n\r\n\t\t\t\t\tconst uvLen = this.uvs.length;\r\n\t\t\t\t\tia = this.parseUVIndex(ua, uvLen);\r\n\t\t\t\t\tib = this.parseUVIndex(ub, uvLen);\r\n\t\t\t\t\tic = this.parseUVIndex(uc, uvLen);\r\n\t\t\t\t\tthis.addUV(ia, ib, ic);\r\n\t\t\t\t\tthis.object.geometry.hasUVIndices = true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// add placeholder values (for inconsistent face definitions)\r\n\t\t\t\t\tthis.addDefaultUV();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\t\t\taddPointGeometry: function (vertices) {\r\n\r\n\t\t\t\tthis.object.geometry.type = 'Points';\r\n\t\t\t\tconst vLen = this.vertices.length;\r\n\r\n\t\t\t\tfor (let vi = 0, l = vertices.length; vi < l; vi++) {\r\n\r\n\t\t\t\t\tconst index = this.parseVertexIndex(vertices[vi], vLen);\r\n\t\t\t\t\tthis.addVertexPoint(index);\r\n\t\t\t\t\tthis.addColor(index);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\t\t\taddLineGeometry: function (vertices, uvs) {\r\n\r\n\t\t\t\tthis.object.geometry.type = 'Line';\r\n\t\t\t\tconst vLen = this.vertices.length;\r\n\t\t\t\tconst uvLen = this.uvs.length;\r\n\r\n\t\t\t\tfor (let vi = 0, l = vertices.length; vi < l; vi++) {\r\n\r\n\t\t\t\t\tthis.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\r\n\r\n\t\t\t\t\tthis.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t};\r\n\t\tstate.startObject('', false);\r\n\t\treturn state;\r\n\r\n\t} //\r\n\r\n\r\n\tclass OBJLoader extends THREE.Loader {\r\n\r\n\t\tconstructor(manager) {\r\n\r\n\t\t\tsuper(manager);\r\n\t\t\tthis.materials = null;\r\n\r\n\t\t}\r\n\r\n\t\tload(url, onLoad, onProgress, onError) {\r\n\r\n\t\t\tconst scope = this;\r\n\t\t\tconst loader = new THREE.FileLoader(this.manager);\r\n\t\t\tloader.setPath(this.path);\r\n\t\t\tloader.setRequestHeader(this.requestHeader);\r\n\t\t\tloader.setWithCredentials(this.withCredentials);\r\n\t\t\tloader.load(url, function (text) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tonLoad(scope.parse(text));\r\n\r\n\t\t\t\t} catch (e) {\r\n\r\n\t\t\t\t\tif (onError) {\r\n\r\n\t\t\t\t\t\tonError(e);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.error(e);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.manager.itemError(url);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, onError);\r\n\r\n\t\t}\r\n\r\n\t\tsetMaterials(materials) {\r\n\r\n\t\t\tthis.materials = materials;\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tparse(text) {\r\n\r\n\t\t\tconst state = new ParserState();\r\n\r\n\t\t\tif (text.indexOf('\\r\\n') !== - 1) {\r\n\r\n\t\t\t\t// This is faster than String.split with regex that splits on both\r\n\t\t\t\ttext = text.replace(/\\r\\n/g, '\\n');\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (text.indexOf('\\\\\\n') !== - 1) {\r\n\r\n\t\t\t\t// join lines separated by a line continuation character (\\)\r\n\t\t\t\ttext = text.replace(/\\\\\\n/g, '');\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst lines = text.split('\\n');\r\n\t\t\tlet line = '',\r\n\t\t\t\tlineFirstChar = '';\r\n\t\t\tlet lineLength = 0;\r\n\t\t\tlet result = []; // Faster to just trim left side of the line. Use if available.\r\n\r\n\t\t\tconst trimLeft = typeof ''.trimLeft === 'function';\r\n\r\n\t\t\tfor (let i = 0, l = lines.length; i < l; i++) {\r\n\r\n\t\t\t\tline = lines[i];\r\n\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\r\n\t\t\t\tlineLength = line.length;\r\n\t\t\t\tif (lineLength === 0) continue;\r\n\t\t\t\tlineFirstChar = line.charAt(0); // @todo invoke passed in handler if any\r\n\r\n\t\t\t\tif (lineFirstChar === '#') continue;\r\n\r\n\t\t\t\tif (lineFirstChar === 'v') {\r\n\r\n\t\t\t\t\tconst data = line.split(/\\s+/);\r\n\r\n\t\t\t\t\tswitch (data[0]) {\r\n\r\n\t\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\t\tstate.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\r\n\r\n\t\t\t\t\t\t\tif (data.length >= 7) {\r\n\r\n\t\t\t\t\t\t\t\tstate.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// if no colors are defined, add placeholders so color and vertex indices match\r\n\t\t\t\t\t\t\t\tstate.colors.push(undefined, undefined, undefined);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'vn':\r\n\t\t\t\t\t\t\tstate.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'vt':\r\n\t\t\t\t\t\t\tstate.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if (lineFirstChar === 'f') {\r\n\r\n\t\t\t\t\tconst lineData = line.substr(1).trim();\r\n\t\t\t\t\tconst vertexData = lineData.split(/\\s+/);\r\n\t\t\t\t\tconst faceVertices = []; // Parse the face vertex data into an easy to work with format\r\n\r\n\t\t\t\t\tfor (let j = 0, jl = vertexData.length; j < jl; j++) {\r\n\r\n\t\t\t\t\t\tconst vertex = vertexData[j];\r\n\r\n\t\t\t\t\t\tif (vertex.length > 0) {\r\n\r\n\t\t\t\t\t\t\tconst vertexParts = vertex.split('/');\r\n\t\t\t\t\t\t\tfaceVertices.push(vertexParts);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\r\n\r\n\r\n\t\t\t\t\tconst v1 = faceVertices[0];\r\n\r\n\t\t\t\t\tfor (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\r\n\r\n\t\t\t\t\t\tconst v2 = faceVertices[j];\r\n\t\t\t\t\t\tconst v3 = faceVertices[j + 1];\r\n\t\t\t\t\t\tstate.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if (lineFirstChar === 'l') {\r\n\r\n\t\t\t\t\tconst lineParts = line.substring(1).trim().split(' ');\r\n\t\t\t\t\tlet lineVertices = [];\r\n\t\t\t\t\tconst lineUVs = [];\r\n\r\n\t\t\t\t\tif (line.indexOf('/') === - 1) {\r\n\r\n\t\t\t\t\t\tlineVertices = lineParts;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor (let li = 0, llen = lineParts.length; li < llen; li++) {\r\n\r\n\t\t\t\t\t\t\tconst parts = lineParts[li].split('/');\r\n\t\t\t\t\t\t\tif (parts[0] !== '') lineVertices.push(parts[0]);\r\n\t\t\t\t\t\t\tif (parts[1] !== '') lineUVs.push(parts[1]);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tstate.addLineGeometry(lineVertices, lineUVs);\r\n\r\n\t\t\t\t} else if (lineFirstChar === 'p') {\r\n\r\n\t\t\t\t\tconst lineData = line.substr(1).trim();\r\n\t\t\t\t\tconst pointData = lineData.split(' ');\r\n\t\t\t\t\tstate.addPointGeometry(pointData);\r\n\r\n\t\t\t\t} else if ((result = _object_pattern.exec(line)) !== null) {\r\n\r\n\t\t\t\t\t// o object_name\r\n\t\t\t\t\t// or\r\n\t\t\t\t\t// g group_name\r\n\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\r\n\t\t\t\t\t// let name = result[ 0 ].substr( 1 ).trim();\r\n\t\t\t\t\tconst name = (' ' + result[0].substr(1).trim()).substr(1);\r\n\t\t\t\t\tstate.startObject(name);\r\n\r\n\t\t\t\t} else if (_material_use_pattern.test(line)) {\r\n\r\n\t\t\t\t\t// material\r\n\t\t\t\t\tstate.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\r\n\r\n\t\t\t\t} else if (_material_library_pattern.test(line)) {\r\n\r\n\t\t\t\t\t// mtl file\r\n\t\t\t\t\tstate.materialLibraries.push(line.substring(7).trim());\r\n\r\n\t\t\t\t} else if (_map_use_pattern.test(line)) {\r\n\r\n\t\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files\r\n\t\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\r\n\t\t\t\t\tconsole.warn('THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.');\r\n\r\n\t\t\t\t} else if (lineFirstChar === 's') {\r\n\r\n\t\t\t\t\tresult = line.split(' '); // smooth shading\r\n\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\r\n\t\t\t\t\t// but does not define a usemtl for each face set.\r\n\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\r\n\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\r\n\t\t\t\t\t// where explicit usemtl defines geometry groups.\r\n\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t * http://paulbourke.net/dataformats/obj/\r\n\t\t\t * or\r\n\t\t\t * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\r\n\t\t\t *\r\n\t\t\t * From chapter \"Grouping\" Syntax explanation \"s group_number\":\r\n\t\t\t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\r\n\t\t\t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\r\n\t\t\t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\r\n\t\t\t * than 0.\"\r\n\t\t\t */\r\n\r\n\t\t\t\t\tif (result.length > 1) {\r\n\r\n\t\t\t\t\t\tconst value = result[1].trim().toLowerCase();\r\n\t\t\t\t\t\tstate.object.smooth = value !== '0' && value !== 'off';\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\r\n\t\t\t\t\t\tstate.object.smooth = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst material = state.object.currentMaterial();\r\n\t\t\t\t\tif (material) material.smooth = state.object.smooth;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Handle null terminated files without exception\r\n\t\t\t\t\tif (line === '\\0') continue;\r\n\t\t\t\t\tconsole.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstate.finalize();\r\n\t\t\tconst container = new THREE.Group();\r\n\t\t\tcontainer.materialLibraries = [].concat(state.materialLibraries);\r\n\t\t\tconst hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);\r\n\r\n\t\t\tif (hasPrimitives === true) {\r\n\r\n\t\t\t\tfor (let i = 0, l = state.objects.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst object = state.objects[i];\r\n\t\t\t\t\tconst geometry = object.geometry;\r\n\t\t\t\t\tconst materials = object.materials;\r\n\t\t\t\t\tconst isLine = geometry.type === 'Line';\r\n\t\t\t\t\tconst isPoints = geometry.type === 'Points';\r\n\t\t\t\t\tlet hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces\r\n\r\n\t\t\t\t\tif (geometry.vertices.length === 0) continue;\r\n\t\t\t\t\tconst buffergeometry = new THREE.BufferGeometry();\r\n\t\t\t\t\tbuffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));\r\n\r\n\t\t\t\t\tif (geometry.normals.length > 0) {\r\n\r\n\t\t\t\t\t\tbuffergeometry.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (geometry.colors.length > 0) {\r\n\r\n\t\t\t\t\t\thasVertexColors = true;\r\n\t\t\t\t\t\tbuffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (geometry.hasUVIndices === true) {\r\n\r\n\t\t\t\t\t\tbuffergeometry.setAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));\r\n\r\n\t\t\t\t\t} // Create materials\r\n\r\n\r\n\t\t\t\t\tconst createdMaterials = [];\r\n\r\n\t\t\t\t\tfor (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\r\n\r\n\t\t\t\t\t\tconst sourceMaterial = materials[mi];\r\n\t\t\t\t\t\tconst materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\r\n\t\t\t\t\t\tlet material = state.materials[materialHash];\r\n\r\n\t\t\t\t\t\tif (this.materials !== null) {\r\n\r\n\t\t\t\t\t\t\tmaterial = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\r\n\r\n\t\t\t\t\t\t\tif (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {\r\n\r\n\t\t\t\t\t\t\t\tconst materialLine = new THREE.LineBasicMaterial();\r\n\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call(materialLine, material);\r\n\t\t\t\t\t\t\t\tmaterialLine.color.copy(material.color);\r\n\t\t\t\t\t\t\t\tmaterial = materialLine;\r\n\r\n\t\t\t\t\t\t\t} else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {\r\n\r\n\t\t\t\t\t\t\t\tconst materialPoints = new THREE.PointsMaterial({\r\n\t\t\t\t\t\t\t\t\tsize: 10,\r\n\t\t\t\t\t\t\t\t\tsizeAttenuation: false\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call(materialPoints, material);\r\n\t\t\t\t\t\t\t\tmaterialPoints.color.copy(material.color);\r\n\t\t\t\t\t\t\t\tmaterialPoints.map = material.map;\r\n\t\t\t\t\t\t\t\tmaterial = materialPoints;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (material === undefined) {\r\n\r\n\t\t\t\t\t\t\tif (isLine) {\r\n\r\n\t\t\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial();\r\n\r\n\t\t\t\t\t\t\t} else if (isPoints) {\r\n\r\n\t\t\t\t\t\t\t\tmaterial = new THREE.PointsMaterial({\r\n\t\t\t\t\t\t\t\t\tsize: 1,\r\n\t\t\t\t\t\t\t\t\tsizeAttenuation: false\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\r\n\t\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\r\n\t\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;\r\n\t\t\t\t\t\t\tstate.materials[materialHash] = material;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcreatedMaterials.push(material);\r\n\r\n\t\t\t\t\t} // Create mesh\r\n\r\n\r\n\t\t\t\t\tlet mesh;\r\n\r\n\t\t\t\t\tif (createdMaterials.length > 1) {\r\n\r\n\t\t\t\t\t\tfor (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\r\n\r\n\t\t\t\t\t\t\tconst sourceMaterial = materials[mi];\r\n\t\t\t\t\t\t\tbuffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (isLine) {\r\n\r\n\t\t\t\t\t\t\tmesh = new THREE.LineSegments(buffergeometry, createdMaterials);\r\n\r\n\t\t\t\t\t\t} else if (isPoints) {\r\n\r\n\t\t\t\t\t\t\tmesh = new THREE.Points(buffergeometry, createdMaterials);\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tmesh = new THREE.Mesh(buffergeometry, createdMaterials);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif (isLine) {\r\n\r\n\t\t\t\t\t\t\tmesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);\r\n\r\n\t\t\t\t\t\t} else if (isPoints) {\r\n\r\n\t\t\t\t\t\t\tmesh = new THREE.Points(buffergeometry, createdMaterials[0]);\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tmesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmesh.name = object.name;\r\n\t\t\t\t\tcontainer.add(mesh);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// if there is only the default parser state object with no geometry data, interpret data as point cloud\r\n\t\t\t\tif (state.vertices.length > 0) {\r\n\r\n\t\t\t\t\tconst material = new THREE.PointsMaterial({\r\n\t\t\t\t\t\tsize: 1,\r\n\t\t\t\t\t\tsizeAttenuation: false\r\n\t\t\t\t\t});\r\n\t\t\t\t\tconst buffergeometry = new THREE.BufferGeometry();\r\n\t\t\t\t\tbuffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(state.vertices, 3));\r\n\r\n\t\t\t\t\tif (state.colors.length > 0 && state.colors[0] !== undefined) {\r\n\r\n\t\t\t\t\t\tbuffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(state.colors, 3));\r\n\t\t\t\t\t\tmaterial.vertexColors = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst points = new THREE.Points(buffergeometry, material);\r\n\t\t\t\t\tcontainer.add(points);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn container;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.OBJLoader = OBJLoader;\r\n\r\n})();\r\n\r\nmodule.exports = exports = THREE.OBJLoader;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
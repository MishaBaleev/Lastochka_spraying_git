{"ast":null,"code":"const THREE = require('../../three.js');\n(function () {\n  /**\r\n  * Loads a Wavefront .mtl file specifying materials\r\n  */\n\n  class MTLLoader extends THREE.Loader {\n    constructor(manager) {\n      super(manager);\n    }\n    /**\r\n     * Loads and parses a MTL asset from a URL.\r\n     *\r\n     * @param {String} url - URL to the MTL file.\r\n     * @param {Function} [onLoad] - Callback invoked with the loaded object.\r\n     * @param {Function} [onProgress] - Callback for download progress.\r\n     * @param {Function} [onError] - Callback for download errors.\r\n     *\r\n     * @see setPath setResourcePath\r\n     *\r\n     * @note In order for relative texture references to resolve correctly\r\n     * you must call setResourcePath() explicitly prior to load.\r\n     */\n\n    load(url, onLoad, onProgress, onError) {\n      const scope = this;\n      const path = this.path === '' ? THREE.LoaderUtils.extractUrlBase(url || '') : this.path;\n      const loader = new THREE.FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n    setMaterialOptions(value) {\n      this.materialOptions = value;\n      return this;\n    }\n    /**\r\n     * Parses a MTL file.\r\n     *\r\n     * @param {String} text - Content of MTL file\r\n     * @return {MaterialCreator}\r\n     *\r\n     * @see setPath setResourcePath\r\n     *\r\n     * @note In order for relative texture references to resolve correctly\r\n     * you must call setResourcePath() explicitly prior to parse.\r\n     */\n\n    parse(text, path) {\n      const lines = text.split('\\n');\n      let info = {};\n      const delimiter_pattern = /\\s+/;\n      const materialsInfo = {};\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line.length === 0 || line.charAt(0) === '#') {\n          // Blank line or comment ignore\n          continue;\n        }\n        const pos = line.indexOf(' ');\n        let key = pos >= 0 ? line.substring(0, pos) : line;\n        key = key.toLowerCase();\n        let value = pos >= 0 ? line.substring(pos + 1) : '';\n        value = value.trim();\n        if (key === 'newmtl') {\n          // New material\n          info = {\n            name: value\n          };\n          materialsInfo[value] = info;\n        } else {\n          if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {\n            const ss = value.split(delimiter_pattern, 3);\n            info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n          } else {\n            info[key] = value;\n          }\n        }\n      }\n      const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n      materialCreator.setCrossOrigin(this.crossOrigin);\n      materialCreator.setManager(this.manager);\n      materialCreator.setMaterials(materialsInfo);\n      return materialCreator;\n    }\n  }\n  /**\r\n  * Create a new MTLLoader.MaterialCreator\r\n  * @param baseUrl - Url relative to which textures are loaded\r\n  * @param options - Set of options on how to construct the materials\r\n  *                  side: Which side to apply the material\r\n  *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\r\n  *                  wrap: What type of wrapping to apply for textures\r\n  *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\r\n  *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\r\n  *                                Default: false, assumed to be already normalized\r\n  *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\r\n  *                                  Default: false\r\n  * @constructor\r\n  */\n\n  class MaterialCreator {\n    constructor(baseUrl = '', options = {}) {\n      this.baseUrl = baseUrl;\n      this.options = options;\n      this.materialsInfo = {};\n      this.materials = {};\n      this.materialsArray = [];\n      this.nameLookup = {};\n      this.crossOrigin = 'anonymous';\n      this.side = this.options.side !== undefined ? this.options.side : THREE.FrontSide;\n      this.wrap = this.options.wrap !== undefined ? this.options.wrap : THREE.RepeatWrapping;\n    }\n    setCrossOrigin(value) {\n      this.crossOrigin = value;\n      return this;\n    }\n    setManager(value) {\n      this.manager = value;\n    }\n    setMaterials(materialsInfo) {\n      this.materialsInfo = this.convert(materialsInfo);\n      this.materials = {};\n      this.materialsArray = [];\n      this.nameLookup = {};\n    }\n    convert(materialsInfo) {\n      if (!this.options) return materialsInfo;\n      const converted = {};\n      for (const mn in materialsInfo) {\n        // Convert materials info into normalized form based on options\n        const mat = materialsInfo[mn];\n        const covmat = {};\n        converted[mn] = covmat;\n        for (const prop in mat) {\n          let save = true;\n          let value = mat[prop];\n          const lprop = prop.toLowerCase();\n          switch (lprop) {\n            case 'kd':\n            case 'ka':\n            case 'ks':\n              // Diffuse color (color under white light) using RGB values\n              if (this.options && this.options.normalizeRGB) {\n                value = [value[0] / 255, value[1] / 255, value[2] / 255];\n              }\n              if (this.options && this.options.ignoreZeroRGBs) {\n                if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                  // ignore\n                  save = false;\n                }\n              }\n              break;\n            default:\n              break;\n          }\n          if (save) {\n            covmat[lprop] = value;\n          }\n        }\n      }\n      return converted;\n    }\n    preload() {\n      for (const mn in this.materialsInfo) {\n        this.create(mn);\n      }\n    }\n    getIndex(materialName) {\n      return this.nameLookup[materialName];\n    }\n    getAsArray() {\n      let index = 0;\n      for (const mn in this.materialsInfo) {\n        this.materialsArray[index] = this.create(mn);\n        this.nameLookup[mn] = index;\n        index++;\n      }\n      return this.materialsArray;\n    }\n    create(materialName) {\n      if (this.materials[materialName] === undefined) {\n        this.createMaterial_(materialName);\n      }\n      return this.materials[materialName];\n    }\n    createMaterial_(materialName) {\n      // Create material\n      const scope = this;\n      const mat = this.materialsInfo[materialName];\n      const params = {\n        name: materialName,\n        side: this.side\n      };\n      function resolveURL(baseUrl, url) {\n        if (typeof url !== 'string' || url === '') return ''; // Absolute URL\n\n        if (/^https?:\\/\\//i.test(url)) return url;\n        return baseUrl + url;\n      }\n      function setMapForType(mapType, value) {\n        if (params[mapType]) return; // Keep the first encountered texture\n\n        const texParams = scope.getTextureParams(value, params);\n        const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n        map.repeat.copy(texParams.scale);\n        map.offset.copy(texParams.offset);\n        map.wrapS = scope.wrap;\n        map.wrapT = scope.wrap;\n        params[mapType] = map;\n      }\n      for (const prop in mat) {\n        const value = mat[prop];\n        let n;\n        if (value === '') continue;\n        switch (prop.toLowerCase()) {\n          // Ns is material specular exponent\n          case 'kd':\n            // Diffuse color (color under white light) using RGB values\n            params.color = new THREE.Color().fromArray(value);\n            break;\n          case 'ks':\n            // Specular color (color when light is reflected from shiny surface) using RGB values\n            params.specular = new THREE.Color().fromArray(value);\n            break;\n          case 'ke':\n            // Emissive using RGB values\n            params.emissive = new THREE.Color().fromArray(value);\n            break;\n          case 'map_kd':\n            // Diffuse texture map\n            setMapForType('map', value);\n            break;\n          case 'map_ks':\n            // Specular map\n            setMapForType('specularMap', value);\n            break;\n          case 'map_ke':\n            // Emissive map\n            setMapForType('emissiveMap', value);\n            break;\n          case 'norm':\n            setMapForType('normalMap', value);\n            break;\n          case 'map_bump':\n          case 'bump':\n            // Bump texture map\n            setMapForType('bumpMap', value);\n            break;\n          case 'map_d':\n            // Alpha map\n            setMapForType('alphaMap', value);\n            params.transparent = true;\n            break;\n          case 'ns':\n            // The specular exponent (defines the focus of the specular highlight)\n            // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n            params.shininess = parseFloat(value);\n            break;\n          case 'd':\n            n = parseFloat(value);\n            if (n < 1) {\n              params.opacity = n;\n              params.transparent = true;\n            }\n            break;\n          case 'tr':\n            n = parseFloat(value);\n            if (this.options && this.options.invertTrProperty) n = 1 - n;\n            if (n > 0) {\n              params.opacity = 1 - n;\n              params.transparent = true;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      this.materials[materialName] = new THREE.MeshPhongMaterial(params);\n      return this.materials[materialName];\n    }\n    getTextureParams(value, matParams) {\n      const texParams = {\n        scale: new THREE.Vector2(1, 1),\n        offset: new THREE.Vector2(0, 0)\n      };\n      const items = value.split(/\\s+/);\n      let pos;\n      pos = items.indexOf('-bm');\n      if (pos >= 0) {\n        matParams.bumpScale = parseFloat(items[pos + 1]);\n        items.splice(pos, 2);\n      }\n      pos = items.indexOf('-s');\n      if (pos >= 0) {\n        texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n        items.splice(pos, 4); // we expect 3 parameters here!\n      }\n      pos = items.indexOf('-o');\n      if (pos >= 0) {\n        texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n        items.splice(pos, 4); // we expect 3 parameters here!\n      }\n      texParams.url = items.join(' ').trim();\n      return texParams;\n    }\n    loadTexture(url, mapping, onLoad, onProgress, onError) {\n      const manager = this.manager !== undefined ? this.manager : THREE.DefaultLoadingManager;\n      let loader = manager.getHandler(url);\n      if (loader === null) {\n        loader = new THREE.TextureLoader(manager);\n      }\n      if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n      const texture = loader.load(url, onLoad, onProgress, onError);\n      if (mapping !== undefined) texture.mapping = mapping;\n      return texture;\n    }\n  }\n  THREE.MTLLoader = MTLLoader;\n})();\nmodule.exports = exports = THREE.MTLLoader;","map":{"version":3,"names":["THREE","require","MTLLoader","Loader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterialOptions","value","materialOptions","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","name","ss","parseFloat","materialCreator","MaterialCreator","resourcePath","setCrossOrigin","crossOrigin","setManager","setMaterials","baseUrl","options","materials","materialsArray","nameLookup","side","undefined","FrontSide","wrap","RepeatWrapping","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","preload","create","getIndex","materialName","getAsArray","index","createMaterial_","params","resolveURL","test","setMapForType","mapType","texParams","getTextureParams","map","loadTexture","repeat","copy","scale","offset","wrapS","wrapT","n","color","Color","fromArray","specular","emissive","transparent","shininess","opacity","invertTrProperty","MeshPhongMaterial","matParams","Vector2","items","bumpScale","splice","set","join","mapping","DefaultLoadingManager","getHandler","TextureLoader","texture","module","exports"],"sources":["/Users/mihailbaleev/Documents/GitHub/lastochka_spraying/node_modules/threebox-plugin/src/objects/loaders/MTLLoader.js"],"sourcesContent":["const THREE = require('../../three.js');\r\n\r\n(function () {\r\n\r\n\t/**\r\n * Loads a Wavefront .mtl file specifying materials\r\n */\r\n\r\n\tclass MTLLoader extends THREE.Loader {\r\n\r\n\t\tconstructor(manager) {\r\n\r\n\t\t\tsuper(manager);\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Loads and parses a MTL asset from a URL.\r\n   *\r\n   * @param {String} url - URL to the MTL file.\r\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\r\n   * @param {Function} [onProgress] - Callback for download progress.\r\n   * @param {Function} [onError] - Callback for download errors.\r\n   *\r\n   * @see setPath setResourcePath\r\n   *\r\n   * @note In order for relative texture references to resolve correctly\r\n   * you must call setResourcePath() explicitly prior to load.\r\n   */\r\n\r\n\r\n\t\tload(url, onLoad, onProgress, onError) {\r\n\r\n\t\t\tconst scope = this;\r\n\t\t\tconst path = this.path === '' ? THREE.LoaderUtils.extractUrlBase(url || '') : this.path;\r\n\t\t\tconst loader = new THREE.FileLoader(this.manager);\r\n\t\t\tloader.setPath(this.path);\r\n\t\t\tloader.setRequestHeader(this.requestHeader);\r\n\t\t\tloader.setWithCredentials(this.withCredentials);\r\n\t\t\tloader.load(url, function (text) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tonLoad(scope.parse(text, path));\r\n\r\n\t\t\t\t} catch (e) {\r\n\r\n\t\t\t\t\tif (onError) {\r\n\r\n\t\t\t\t\t\tonError(e);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.error(e);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.manager.itemError(url);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, onError);\r\n\r\n\t\t}\r\n\r\n\t\tsetMaterialOptions(value) {\r\n\r\n\t\t\tthis.materialOptions = value;\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Parses a MTL file.\r\n   *\r\n   * @param {String} text - Content of MTL file\r\n   * @return {MaterialCreator}\r\n   *\r\n   * @see setPath setResourcePath\r\n   *\r\n   * @note In order for relative texture references to resolve correctly\r\n   * you must call setResourcePath() explicitly prior to parse.\r\n   */\r\n\r\n\r\n\t\tparse(text, path) {\r\n\r\n\t\t\tconst lines = text.split('\\n');\r\n\t\t\tlet info = {};\r\n\t\t\tconst delimiter_pattern = /\\s+/;\r\n\t\t\tconst materialsInfo = {};\r\n\r\n\t\t\tfor (let i = 0; i < lines.length; i++) {\r\n\r\n\t\t\t\tlet line = lines[i];\r\n\t\t\t\tline = line.trim();\r\n\r\n\t\t\t\tif (line.length === 0 || line.charAt(0) === '#') {\r\n\r\n\t\t\t\t\t// Blank line or comment ignore\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst pos = line.indexOf(' ');\r\n\t\t\t\tlet key = pos >= 0 ? line.substring(0, pos) : line;\r\n\t\t\t\tkey = key.toLowerCase();\r\n\t\t\t\tlet value = pos >= 0 ? line.substring(pos + 1) : '';\r\n\t\t\t\tvalue = value.trim();\r\n\r\n\t\t\t\tif (key === 'newmtl') {\r\n\r\n\t\t\t\t\t// New material\r\n\t\t\t\t\tinfo = {\r\n\t\t\t\t\t\tname: value\r\n\t\t\t\t\t};\r\n\t\t\t\t\tmaterialsInfo[value] = info;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {\r\n\r\n\t\t\t\t\t\tconst ss = value.split(delimiter_pattern, 3);\r\n\t\t\t\t\t\tinfo[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tinfo[key] = value;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\r\n\t\t\tmaterialCreator.setCrossOrigin(this.crossOrigin);\r\n\t\t\tmaterialCreator.setManager(this.manager);\r\n\t\t\tmaterialCreator.setMaterials(materialsInfo);\r\n\t\t\treturn materialCreator;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * Create a new MTLLoader.MaterialCreator\r\n * @param baseUrl - Url relative to which textures are loaded\r\n * @param options - Set of options on how to construct the materials\r\n *                  side: Which side to apply the material\r\n *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\r\n *                  wrap: What type of wrapping to apply for textures\r\n *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\r\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\r\n *                                Default: false, assumed to be already normalized\r\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\r\n *                                  Default: false\r\n * @constructor\r\n */\r\n\r\n\r\n\tclass MaterialCreator {\r\n\r\n\t\tconstructor(baseUrl = '', options = {}) {\r\n\r\n\t\t\tthis.baseUrl = baseUrl;\r\n\t\t\tthis.options = options;\r\n\t\t\tthis.materialsInfo = {};\r\n\t\t\tthis.materials = {};\r\n\t\t\tthis.materialsArray = [];\r\n\t\t\tthis.nameLookup = {};\r\n\t\t\tthis.crossOrigin = 'anonymous';\r\n\t\t\tthis.side = this.options.side !== undefined ? this.options.side : THREE.FrontSide;\r\n\t\t\tthis.wrap = this.options.wrap !== undefined ? this.options.wrap : THREE.RepeatWrapping;\r\n\r\n\t\t}\r\n\r\n\t\tsetCrossOrigin(value) {\r\n\r\n\t\t\tthis.crossOrigin = value;\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tsetManager(value) {\r\n\r\n\t\t\tthis.manager = value;\r\n\r\n\t\t}\r\n\r\n\t\tsetMaterials(materialsInfo) {\r\n\r\n\t\t\tthis.materialsInfo = this.convert(materialsInfo);\r\n\t\t\tthis.materials = {};\r\n\t\t\tthis.materialsArray = [];\r\n\t\t\tthis.nameLookup = {};\r\n\r\n\t\t}\r\n\r\n\t\tconvert(materialsInfo) {\r\n\r\n\t\t\tif (!this.options) return materialsInfo;\r\n\t\t\tconst converted = {};\r\n\r\n\t\t\tfor (const mn in materialsInfo) {\r\n\r\n\t\t\t\t// Convert materials info into normalized form based on options\r\n\t\t\t\tconst mat = materialsInfo[mn];\r\n\t\t\t\tconst covmat = {};\r\n\t\t\t\tconverted[mn] = covmat;\r\n\r\n\t\t\t\tfor (const prop in mat) {\r\n\r\n\t\t\t\t\tlet save = true;\r\n\t\t\t\t\tlet value = mat[prop];\r\n\t\t\t\t\tconst lprop = prop.toLowerCase();\r\n\r\n\t\t\t\t\tswitch (lprop) {\r\n\r\n\t\t\t\t\t\tcase 'kd':\r\n\t\t\t\t\t\tcase 'ka':\r\n\t\t\t\t\t\tcase 'ks':\r\n\t\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\r\n\t\t\t\t\t\t\tif (this.options && this.options.normalizeRGB) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = [value[0] / 255, value[1] / 255, value[2] / 255];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (this.options && this.options.ignoreZeroRGBs) {\r\n\r\n\t\t\t\t\t\t\t\tif (value[0] === 0 && value[1] === 0 && value[2] === 0) {\r\n\r\n\t\t\t\t\t\t\t\t\t// ignore\r\n\t\t\t\t\t\t\t\t\tsave = false;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (save) {\r\n\r\n\t\t\t\t\t\tcovmat[lprop] = value;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn converted;\r\n\r\n\t\t}\r\n\r\n\t\tpreload() {\r\n\r\n\t\t\tfor (const mn in this.materialsInfo) {\r\n\r\n\t\t\t\tthis.create(mn);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgetIndex(materialName) {\r\n\r\n\t\t\treturn this.nameLookup[materialName];\r\n\r\n\t\t}\r\n\r\n\t\tgetAsArray() {\r\n\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\tfor (const mn in this.materialsInfo) {\r\n\r\n\t\t\t\tthis.materialsArray[index] = this.create(mn);\r\n\t\t\t\tthis.nameLookup[mn] = index;\r\n\t\t\t\tindex++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.materialsArray;\r\n\r\n\t\t}\r\n\r\n\t\tcreate(materialName) {\r\n\r\n\t\t\tif (this.materials[materialName] === undefined) {\r\n\r\n\t\t\t\tthis.createMaterial_(materialName);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.materials[materialName];\r\n\r\n\t\t}\r\n\r\n\t\tcreateMaterial_(materialName) {\r\n\r\n\t\t\t// Create material\r\n\t\t\tconst scope = this;\r\n\t\t\tconst mat = this.materialsInfo[materialName];\r\n\t\t\tconst params = {\r\n\t\t\t\tname: materialName,\r\n\t\t\t\tside: this.side\r\n\t\t\t};\r\n\r\n\t\t\tfunction resolveURL(baseUrl, url) {\r\n\r\n\t\t\t\tif (typeof url !== 'string' || url === '') return ''; // Absolute URL\r\n\r\n\t\t\t\tif (/^https?:\\/\\//i.test(url)) return url;\r\n\t\t\t\treturn baseUrl + url;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction setMapForType(mapType, value) {\r\n\r\n\t\t\t\tif (params[mapType]) return; // Keep the first encountered texture\r\n\r\n\t\t\t\tconst texParams = scope.getTextureParams(value, params);\r\n\t\t\t\tconst map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\r\n\t\t\t\tmap.repeat.copy(texParams.scale);\r\n\t\t\t\tmap.offset.copy(texParams.offset);\r\n\t\t\t\tmap.wrapS = scope.wrap;\r\n\t\t\t\tmap.wrapT = scope.wrap;\r\n\t\t\t\tparams[mapType] = map;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor (const prop in mat) {\r\n\r\n\t\t\t\tconst value = mat[prop];\r\n\t\t\t\tlet n;\r\n\t\t\t\tif (value === '') continue;\r\n\r\n\t\t\t\tswitch (prop.toLowerCase()) {\r\n\r\n\t\t\t\t\t// Ns is material specular exponent\r\n\t\t\t\t\tcase 'kd':\r\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\r\n\t\t\t\t\t\tparams.color = new THREE.Color().fromArray(value);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'ks':\r\n\t\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\r\n\t\t\t\t\t\tparams.specular = new THREE.Color().fromArray(value);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'ke':\r\n\t\t\t\t\t\t// Emissive using RGB values\r\n\t\t\t\t\t\tparams.emissive = new THREE.Color().fromArray(value);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'map_kd':\r\n\t\t\t\t\t\t// Diffuse texture map\r\n\t\t\t\t\t\tsetMapForType('map', value);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'map_ks':\r\n\t\t\t\t\t\t// Specular map\r\n\t\t\t\t\t\tsetMapForType('specularMap', value);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'map_ke':\r\n\t\t\t\t\t\t// Emissive map\r\n\t\t\t\t\t\tsetMapForType('emissiveMap', value);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'norm':\r\n\t\t\t\t\t\tsetMapForType('normalMap', value);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'map_bump':\r\n\t\t\t\t\tcase 'bump':\r\n\t\t\t\t\t\t// Bump texture map\r\n\t\t\t\t\t\tsetMapForType('bumpMap', value);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'map_d':\r\n\t\t\t\t\t\t// Alpha map\r\n\t\t\t\t\t\tsetMapForType('alphaMap', value);\r\n\t\t\t\t\t\tparams.transparent = true;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'ns':\r\n\t\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\r\n\t\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\r\n\t\t\t\t\t\tparams.shininess = parseFloat(value);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'd':\r\n\t\t\t\t\t\tn = parseFloat(value);\r\n\r\n\t\t\t\t\t\tif (n < 1) {\r\n\r\n\t\t\t\t\t\t\tparams.opacity = n;\r\n\t\t\t\t\t\t\tparams.transparent = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'tr':\r\n\t\t\t\t\t\tn = parseFloat(value);\r\n\t\t\t\t\t\tif (this.options && this.options.invertTrProperty) n = 1 - n;\r\n\r\n\t\t\t\t\t\tif (n > 0) {\r\n\r\n\t\t\t\t\t\t\tparams.opacity = 1 - n;\r\n\t\t\t\t\t\t\tparams.transparent = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.materials[materialName] = new THREE.MeshPhongMaterial(params);\r\n\t\t\treturn this.materials[materialName];\r\n\r\n\t\t}\r\n\r\n\t\tgetTextureParams(value, matParams) {\r\n\r\n\t\t\tconst texParams = {\r\n\t\t\t\tscale: new THREE.Vector2(1, 1),\r\n\t\t\t\toffset: new THREE.Vector2(0, 0)\r\n\t\t\t};\r\n\t\t\tconst items = value.split(/\\s+/);\r\n\t\t\tlet pos;\r\n\t\t\tpos = items.indexOf('-bm');\r\n\r\n\t\t\tif (pos >= 0) {\r\n\r\n\t\t\t\tmatParams.bumpScale = parseFloat(items[pos + 1]);\r\n\t\t\t\titems.splice(pos, 2);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tpos = items.indexOf('-s');\r\n\r\n\t\t\tif (pos >= 0) {\r\n\r\n\t\t\t\ttexParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\r\n\t\t\t\titems.splice(pos, 4); // we expect 3 parameters here!\r\n\r\n\t\t\t}\r\n\r\n\t\t\tpos = items.indexOf('-o');\r\n\r\n\t\t\tif (pos >= 0) {\r\n\r\n\t\t\t\ttexParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\r\n\t\t\t\titems.splice(pos, 4); // we expect 3 parameters here!\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexParams.url = items.join(' ').trim();\r\n\t\t\treturn texParams;\r\n\r\n\t\t}\r\n\r\n\t\tloadTexture(url, mapping, onLoad, onProgress, onError) {\r\n\r\n\t\t\tconst manager = this.manager !== undefined ? this.manager : THREE.DefaultLoadingManager;\r\n\t\t\tlet loader = manager.getHandler(url);\r\n\r\n\t\t\tif (loader === null) {\r\n\r\n\t\t\t\tloader = new THREE.TextureLoader(manager);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\r\n\t\t\tconst texture = loader.load(url, onLoad, onProgress, onError);\r\n\t\t\tif (mapping !== undefined) texture.mapping = mapping;\r\n\t\t\treturn texture;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.MTLLoader = MTLLoader;\r\n\r\n})();\r\n\r\nmodule.exports = exports = THREE.MTLLoader;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
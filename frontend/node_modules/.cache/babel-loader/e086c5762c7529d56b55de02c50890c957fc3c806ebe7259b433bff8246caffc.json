{"ast":null,"code":"const THREE = require('../../three.js');\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\n\n(function () {\n  class ColladaLoader extends THREE.Loader {\n    constructor(manager) {\n      super(manager);\n    }\n    load(url, onLoad, onProgress, onError) {\n      const scope = this;\n      const path = scope.path === '' ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;\n      const loader = new THREE.FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n    parse(text, path) {\n      function getElementsByTagName(xml, name) {\n        // Non recursive xml.getElementsByTagName() ...\n        const array = [];\n        const childNodes = xml.childNodes;\n        for (let i = 0, l = childNodes.length; i < l; i++) {\n          const child = childNodes[i];\n          if (child.nodeName === name) {\n            array.push(child);\n          }\n        }\n        return array;\n      }\n      function parseStrings(text) {\n        if (text.length === 0) return [];\n        const parts = text.trim().split(/\\s+/);\n        const array = new Array(parts.length);\n        for (let i = 0, l = parts.length; i < l; i++) {\n          array[i] = parts[i];\n        }\n        return array;\n      }\n      function parseFloats(text) {\n        if (text.length === 0) return [];\n        const parts = text.trim().split(/\\s+/);\n        const array = new Array(parts.length);\n        for (let i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseFloat(parts[i]);\n        }\n        return array;\n      }\n      function parseInts(text) {\n        if (text.length === 0) return [];\n        const parts = text.trim().split(/\\s+/);\n        const array = new Array(parts.length);\n        for (let i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseInt(parts[i]);\n        }\n        return array;\n      }\n      function parseId(text) {\n        return text.substring(1);\n      }\n      function generateId() {\n        return 'three_default_' + count++;\n      }\n      function isEmpty(object) {\n        return Object.keys(object).length === 0;\n      } // asset\n\n      function parseAsset(xml) {\n        return {\n          unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n          upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n        };\n      }\n      function parseAssetUnit(xml) {\n        if (xml !== undefined && xml.hasAttribute('meter') === true) {\n          return parseFloat(xml.getAttribute('meter'));\n        } else {\n          return 1; // default 1 meter\n        }\n      }\n      function parseAssetUpAxis(xml) {\n        return xml !== undefined ? xml.textContent : 'Y_UP';\n      } // library\n\n      function parseLibrary(xml, libraryName, nodeName, parser) {\n        const library = getElementsByTagName(xml, libraryName)[0];\n        if (library !== undefined) {\n          const elements = getElementsByTagName(library, nodeName);\n          for (let i = 0; i < elements.length; i++) {\n            parser(elements[i]);\n          }\n        }\n      }\n      function buildLibrary(data, builder) {\n        for (const name in data) {\n          const object = data[name];\n          object.build = builder(data[name]);\n        }\n      } // get\n\n      function getBuild(data, builder) {\n        if (data.build !== undefined) return data.build;\n        data.build = builder(data);\n        return data.build;\n      } // animation\n\n      function parseAnimation(xml) {\n        const data = {\n          sources: {},\n          samplers: {},\n          channels: {}\n        };\n        let hasChildren = false;\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          let id;\n          switch (child.nodeName) {\n            case 'source':\n              id = child.getAttribute('id');\n              data.sources[id] = parseSource(child);\n              break;\n            case 'sampler':\n              id = child.getAttribute('id');\n              data.samplers[id] = parseAnimationSampler(child);\n              break;\n            case 'channel':\n              id = child.getAttribute('target');\n              data.channels[id] = parseAnimationChannel(child);\n              break;\n            case 'animation':\n              // hierarchy of related animations\n              parseAnimation(child);\n              hasChildren = true;\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        if (hasChildren === false) {\n          // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n          library.animations[xml.getAttribute('id') || THREE.MathUtils.generateUUID()] = data;\n        }\n      }\n      function parseAnimationSampler(xml) {\n        const data = {\n          inputs: {}\n        };\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              const id = parseId(child.getAttribute('source'));\n              const semantic = child.getAttribute('semantic');\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseAnimationChannel(xml) {\n        const data = {};\n        const target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n        let parts = target.split('/');\n        const id = parts.shift();\n        let sid = parts.shift(); // check selection syntax\n\n        const arraySyntax = sid.indexOf('(') !== -1;\n        const memberSyntax = sid.indexOf('.') !== -1;\n        if (memberSyntax) {\n          //  member selection access\n          parts = sid.split('.');\n          sid = parts.shift();\n          data.member = parts.shift();\n        } else if (arraySyntax) {\n          // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n          const indices = sid.split('(');\n          sid = indices.shift();\n          for (let i = 0; i < indices.length; i++) {\n            indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n          }\n          data.indices = indices;\n        }\n        data.id = id;\n        data.sid = sid;\n        data.arraySyntax = arraySyntax;\n        data.memberSyntax = memberSyntax;\n        data.sampler = parseId(xml.getAttribute('source'));\n        return data;\n      }\n      function buildAnimation(data) {\n        const tracks = [];\n        const channels = data.channels;\n        const samplers = data.samplers;\n        const sources = data.sources;\n        for (const target in channels) {\n          if (channels.hasOwnProperty(target)) {\n            const channel = channels[target];\n            const sampler = samplers[channel.sampler];\n            const inputId = sampler.inputs.INPUT;\n            const outputId = sampler.inputs.OUTPUT;\n            const inputSource = sources[inputId];\n            const outputSource = sources[outputId];\n            const animation = buildAnimationChannel(channel, inputSource, outputSource);\n            createKeyframeTracks(animation, tracks);\n          }\n        }\n        return tracks;\n      }\n      function getAnimation(id) {\n        return getBuild(library.animations[id], buildAnimation);\n      }\n      function buildAnimationChannel(channel, inputSource, outputSource) {\n        const node = library.nodes[channel.id];\n        const object3D = getNode(node.id);\n        const transform = node.transforms[channel.sid];\n        const defaultMatrix = node.matrix.clone().transpose();\n        let time, stride;\n        let i, il, j, jl;\n        const data = {}; // the collada spec allows the animation of data in various ways.\n        // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n        switch (transform) {\n          case 'matrix':\n            for (i = 0, il = inputSource.array.length; i < il; i++) {\n              time = inputSource.array[i];\n              stride = i * outputSource.stride;\n              if (data[time] === undefined) data[time] = {};\n              if (channel.arraySyntax === true) {\n                const value = outputSource.array[stride];\n                const index = channel.indices[0] + 4 * channel.indices[1];\n                data[time][index] = value;\n              } else {\n                for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                  data[time][j] = outputSource.array[stride + j];\n                }\n              }\n            }\n            break;\n          case 'translate':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n          case 'rotate':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n          case 'scale':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n        }\n        const keyframes = prepareAnimationData(data, defaultMatrix);\n        const animation = {\n          name: object3D.uuid,\n          keyframes: keyframes\n        };\n        return animation;\n      }\n      function prepareAnimationData(data, defaultMatrix) {\n        const keyframes = []; // transfer data into a sortable array\n\n        for (const time in data) {\n          keyframes.push({\n            time: parseFloat(time),\n            value: data[time]\n          });\n        } // ensure keyframes are sorted by time\n\n        keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n        for (let i = 0; i < 16; i++) {\n          transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n        }\n        return keyframes; // array sort function\n\n        function ascending(a, b) {\n          return a.time - b.time;\n        }\n      }\n      const position = new THREE.Vector3();\n      const scale = new THREE.Vector3();\n      const quaternion = new THREE.Quaternion();\n      function createKeyframeTracks(animation, tracks) {\n        const keyframes = animation.keyframes;\n        const name = animation.name;\n        const times = [];\n        const positionData = [];\n        const quaternionData = [];\n        const scaleData = [];\n        for (let i = 0, l = keyframes.length; i < l; i++) {\n          const keyframe = keyframes[i];\n          const time = keyframe.time;\n          const value = keyframe.value;\n          matrix.fromArray(value).transpose();\n          matrix.decompose(position, quaternion, scale);\n          times.push(time);\n          positionData.push(position.x, position.y, position.z);\n          quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n          scaleData.push(scale.x, scale.y, scale.z);\n        }\n        if (positionData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.position', times, positionData));\n        if (quaternionData.length > 0) tracks.push(new THREE.QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n        if (scaleData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.scale', times, scaleData));\n        return tracks;\n      }\n      function transformAnimationData(keyframes, property, defaultValue) {\n        let keyframe;\n        let empty = true;\n        let i, l; // check, if values of a property are missing in our keyframes\n\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          if (keyframe.value[property] === undefined) {\n            keyframe.value[property] = null; // mark as missing\n          } else {\n            empty = false;\n          }\n        }\n        if (empty === true) {\n          // no values at all, so we set a default value\n          for (i = 0, l = keyframes.length; i < l; i++) {\n            keyframe = keyframes[i];\n            keyframe.value[property] = defaultValue;\n          }\n        } else {\n          // filling gaps\n          createMissingKeyframes(keyframes, property);\n        }\n      }\n      function createMissingKeyframes(keyframes, property) {\n        let prev, next;\n        for (let i = 0, l = keyframes.length; i < l; i++) {\n          const keyframe = keyframes[i];\n          if (keyframe.value[property] === null) {\n            prev = getPrev(keyframes, i, property);\n            next = getNext(keyframes, i, property);\n            if (prev === null) {\n              keyframe.value[property] = next.value[property];\n              continue;\n            }\n            if (next === null) {\n              keyframe.value[property] = prev.value[property];\n              continue;\n            }\n            interpolate(keyframe, prev, next, property);\n          }\n        }\n      }\n      function getPrev(keyframes, i, property) {\n        while (i >= 0) {\n          const keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i--;\n        }\n        return null;\n      }\n      function getNext(keyframes, i, property) {\n        while (i < keyframes.length) {\n          const keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i++;\n        }\n        return null;\n      }\n      function interpolate(key, prev, next, property) {\n        if (next.time - prev.time === 0) {\n          key.value[property] = prev.value[property];\n          return;\n        }\n        key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n      } // animation clips\n\n      function parseAnimationClip(xml) {\n        const data = {\n          name: xml.getAttribute('id') || 'default',\n          start: parseFloat(xml.getAttribute('start') || 0),\n          end: parseFloat(xml.getAttribute('end') || 0),\n          animations: []\n        };\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'instance_animation':\n              data.animations.push(parseId(child.getAttribute('url')));\n              break;\n          }\n        }\n        library.clips[xml.getAttribute('id')] = data;\n      }\n      function buildAnimationClip(data) {\n        const tracks = [];\n        const name = data.name;\n        const duration = data.end - data.start || -1;\n        const animations = data.animations;\n        for (let i = 0, il = animations.length; i < il; i++) {\n          const animationTracks = getAnimation(animations[i]);\n          for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n            tracks.push(animationTracks[j]);\n          }\n        }\n        return new THREE.AnimationClip(name, duration, tracks);\n      }\n      function getAnimationClip(id) {\n        return getBuild(library.clips[id], buildAnimationClip);\n      } // controller\n\n      function parseController(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'skin':\n              // there is exactly one skin per controller\n              data.id = parseId(child.getAttribute('source'));\n              data.skin = parseSkin(child);\n              break;\n            case 'morph':\n              data.id = parseId(child.getAttribute('source'));\n              console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n              break;\n          }\n        }\n        library.controllers[xml.getAttribute('id')] = data;\n      }\n      function parseSkin(xml) {\n        const data = {\n          sources: {}\n        };\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'bind_shape_matrix':\n              data.bindShapeMatrix = parseFloats(child.textContent);\n              break;\n            case 'source':\n              const id = child.getAttribute('id');\n              data.sources[id] = parseSource(child);\n              break;\n            case 'joints':\n              data.joints = parseJoints(child);\n              break;\n            case 'vertex_weights':\n              data.vertexWeights = parseVertexWeights(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseJoints(xml) {\n        const data = {\n          inputs: {}\n        };\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              const semantic = child.getAttribute('semantic');\n              const id = parseId(child.getAttribute('source'));\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseVertexWeights(xml) {\n        const data = {\n          inputs: {}\n        };\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              const semantic = child.getAttribute('semantic');\n              const id = parseId(child.getAttribute('source'));\n              const offset = parseInt(child.getAttribute('offset'));\n              data.inputs[semantic] = {\n                id: id,\n                offset: offset\n              };\n              break;\n            case 'vcount':\n              data.vcount = parseInts(child.textContent);\n              break;\n            case 'v':\n              data.v = parseInts(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildController(data) {\n        const build = {\n          id: data.id\n        };\n        const geometry = library.geometries[build.id];\n        if (data.skin !== undefined) {\n          build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n          geometry.sources.skinIndices = build.skin.indices;\n          geometry.sources.skinWeights = build.skin.weights;\n        }\n        return build;\n      }\n      function buildSkin(data) {\n        const BONE_LIMIT = 4;\n        const build = {\n          joints: [],\n          // this must be an array to preserve the joint order\n          indices: {\n            array: [],\n            stride: BONE_LIMIT\n          },\n          weights: {\n            array: [],\n            stride: BONE_LIMIT\n          }\n        };\n        const sources = data.sources;\n        const vertexWeights = data.vertexWeights;\n        const vcount = vertexWeights.vcount;\n        const v = vertexWeights.v;\n        const jointOffset = vertexWeights.inputs.JOINT.offset;\n        const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n        const jointSource = data.sources[data.joints.inputs.JOINT];\n        const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n        const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n        let stride = 0;\n        let i, j, l; // procces skin data for each vertex\n\n        for (i = 0, l = vcount.length; i < l; i++) {\n          const jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n          const vertexSkinData = [];\n          for (j = 0; j < jointCount; j++) {\n            const skinIndex = v[stride + jointOffset];\n            const weightId = v[stride + weightOffset];\n            const skinWeight = weights[weightId];\n            vertexSkinData.push({\n              index: skinIndex,\n              weight: skinWeight\n            });\n            stride += 2;\n          } // we sort the joints in descending order based on the weights.\n          // this ensures, we only procced the most important joints of the vertex\n\n          vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n          // the order of the skin data matches the order of vertices\n\n          for (j = 0; j < BONE_LIMIT; j++) {\n            const d = vertexSkinData[j];\n            if (d !== undefined) {\n              build.indices.array.push(d.index);\n              build.weights.array.push(d.weight);\n            } else {\n              build.indices.array.push(0);\n              build.weights.array.push(0);\n            }\n          }\n        } // setup bind matrix\n\n        if (data.bindShapeMatrix) {\n          build.bindMatrix = new THREE.Matrix4().fromArray(data.bindShapeMatrix).transpose();\n        } else {\n          build.bindMatrix = new THREE.Matrix4().identity();\n        } // process bones and inverse bind matrix data\n\n        for (i = 0, l = jointSource.array.length; i < l; i++) {\n          const name = jointSource.array[i];\n          const boneInverse = new THREE.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n          build.joints.push({\n            name: name,\n            boneInverse: boneInverse\n          });\n        }\n        return build; // array sort function\n\n        function descending(a, b) {\n          return b.weight - a.weight;\n        }\n      }\n      function getController(id) {\n        return getBuild(library.controllers[id], buildController);\n      } // image\n\n      function parseImage(xml) {\n        const data = {\n          init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n        };\n        library.images[xml.getAttribute('id')] = data;\n      }\n      function buildImage(data) {\n        if (data.build !== undefined) return data.build;\n        return data.init_from;\n      }\n      function getImage(id) {\n        const data = library.images[id];\n        if (data !== undefined) {\n          return getBuild(data, buildImage);\n        }\n        console.warn('THREE.ColladaLoader: Couldn\\'t find image with ID:', id);\n        return null;\n      } // effect\n\n      function parseEffect(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'profile_COMMON':\n              data.profile = parseEffectProfileCOMMON(child);\n              break;\n          }\n        }\n        library.effects[xml.getAttribute('id')] = data;\n      }\n      function parseEffectProfileCOMMON(xml) {\n        const data = {\n          surfaces: {},\n          samplers: {}\n        };\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'newparam':\n              parseEffectNewparam(child, data);\n              break;\n            case 'technique':\n              data.technique = parseEffectTechnique(child);\n              break;\n            case 'extra':\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectNewparam(xml, data) {\n        const sid = xml.getAttribute('sid');\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'surface':\n              data.surfaces[sid] = parseEffectSurface(child);\n              break;\n            case 'sampler2D':\n              data.samplers[sid] = parseEffectSampler(child);\n              break;\n          }\n        }\n      }\n      function parseEffectSurface(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'init_from':\n              data.init_from = child.textContent;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectSampler(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'source':\n              data.source = child.textContent;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectTechnique(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'constant':\n            case 'lambert':\n            case 'blinn':\n            case 'phong':\n              data.type = child.nodeName;\n              data.parameters = parseEffectParameters(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameters(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'emission':\n            case 'diffuse':\n            case 'specular':\n            case 'bump':\n            case 'ambient':\n            case 'shininess':\n            case 'transparency':\n              data[child.nodeName] = parseEffectParameter(child);\n              break;\n            case 'transparent':\n              data[child.nodeName] = {\n                opaque: child.getAttribute('opaque'),\n                data: parseEffectParameter(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameter(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'color':\n              data[child.nodeName] = parseFloats(child.textContent);\n              break;\n            case 'float':\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n            case 'texture':\n              data[child.nodeName] = {\n                id: child.getAttribute('texture'),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameterTexture(xml) {\n        const data = {\n          technique: {}\n        };\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'extra':\n              parseEffectParameterTextureExtra(child, data);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameterTextureExtra(xml, data) {\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique':\n              parseEffectParameterTextureExtraTechnique(child, data);\n              break;\n          }\n        }\n      }\n      function parseEffectParameterTextureExtraTechnique(xml, data) {\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'repeatU':\n            case 'repeatV':\n            case 'offsetU':\n            case 'offsetV':\n              data.technique[child.nodeName] = parseFloat(child.textContent);\n              break;\n            case 'wrapU':\n            case 'wrapV':\n              // some files have values for wrapU/wrapV which become NaN via parseInt\n              if (child.textContent.toUpperCase() === 'TRUE') {\n                data.technique[child.nodeName] = 1;\n              } else if (child.textContent.toUpperCase() === 'FALSE') {\n                data.technique[child.nodeName] = 0;\n              } else {\n                data.technique[child.nodeName] = parseInt(child.textContent);\n              }\n              break;\n          }\n        }\n      }\n      function parseEffectExtra(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique':\n              data.technique = parseEffectExtraTechnique(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectExtraTechnique(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'double_sided':\n              data[child.nodeName] = parseInt(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildEffect(data) {\n        return data;\n      }\n      function getEffect(id) {\n        return getBuild(library.effects[id], buildEffect);\n      } // material\n\n      function parseMaterial(xml) {\n        const data = {\n          name: xml.getAttribute('name')\n        };\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'instance_effect':\n              data.url = parseId(child.getAttribute('url'));\n              break;\n          }\n        }\n        library.materials[xml.getAttribute('id')] = data;\n      }\n      function getTextureLoader(image) {\n        let loader;\n        let extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n        extension = extension.toLowerCase();\n        switch (extension) {\n          case 'tga':\n            loader = tgaLoader;\n            break;\n          default:\n            loader = textureLoader;\n        }\n        return loader;\n      }\n      function buildMaterial(data) {\n        const effect = getEffect(data.url);\n        const technique = effect.profile.technique;\n        const extra = effect.profile.extra;\n        let material;\n        switch (technique.type) {\n          case 'phong':\n          case 'blinn':\n            material = new THREE.MeshPhongMaterial();\n            break;\n          case 'lambert':\n            material = new THREE.MeshLambertMaterial();\n            break;\n          default:\n            material = new THREE.MeshBasicMaterial();\n            break;\n        }\n        material.name = data.name || '';\n        function getTexture(textureObject) {\n          const sampler = effect.profile.samplers[textureObject.id];\n          let image = null; // get image\n\n          if (sampler !== undefined) {\n            const surface = effect.profile.surfaces[sampler.source];\n            image = getImage(surface.init_from);\n          } else {\n            console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n            image = getImage(textureObject.id);\n          } // create texture if image is avaiable\n\n          if (image !== null) {\n            const loader = getTextureLoader(image);\n            if (loader !== undefined) {\n              const texture = loader.load(image);\n              const extra = textureObject.extra;\n              if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n                const technique = extra.technique;\n                texture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n                texture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n                texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n                texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n              } else {\n                texture.wrapS = THREE.RepeatWrapping;\n                texture.wrapT = THREE.RepeatWrapping;\n              }\n              return texture;\n            } else {\n              console.warn('THREE.ColladaLoader: THREE.Loader for texture %s not found.', image);\n              return null;\n            }\n          } else {\n            console.warn('THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id);\n            return null;\n          }\n        }\n        const parameters = technique.parameters;\n        for (const key in parameters) {\n          const parameter = parameters[key];\n          switch (key) {\n            case 'diffuse':\n              if (parameter.color) material.color.fromArray(parameter.color);\n              if (parameter.texture) material.map = getTexture(parameter.texture);\n              break;\n            case 'specular':\n              if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n              if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n              break;\n            case 'bump':\n              if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n              break;\n            case 'ambient':\n              if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n              break;\n            case 'shininess':\n              if (parameter.float && material.shininess) material.shininess = parameter.float;\n              break;\n            case 'emission':\n              if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n              if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n              break;\n          }\n        } //\n\n        let transparent = parameters['transparent'];\n        let transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n        if (transparency === undefined && transparent) {\n          transparency = {\n            float: 1\n          };\n        } // <transparent> does not exist but <transparency>\n\n        if (transparent === undefined && transparency) {\n          transparent = {\n            opaque: 'A_ONE',\n            data: {\n              color: [1, 1, 1, 1]\n            }\n          };\n        }\n        if (transparent && transparency) {\n          // handle case if a texture exists but no color\n          if (transparent.data.texture) {\n            // we do not set an alpha map (see #13792)\n            material.transparent = true;\n          } else {\n            const color = transparent.data.color;\n            switch (transparent.opaque) {\n              case 'A_ONE':\n                material.opacity = color[3] * transparency.float;\n                break;\n              case 'RGB_ZERO':\n                material.opacity = 1 - color[0] * transparency.float;\n                break;\n              case 'A_ZERO':\n                material.opacity = 1 - color[3] * transparency.float;\n                break;\n              case 'RGB_ONE':\n                material.opacity = color[0] * transparency.float;\n                break;\n              default:\n                console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n            }\n            if (material.opacity < 1) material.transparent = true;\n          }\n        } //\n\n        if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n          material.side = THREE.DoubleSide;\n        }\n        return material;\n      }\n      function getMaterial(id) {\n        return getBuild(library.materials[id], buildMaterial);\n      } // camera\n\n      function parseCamera(xml) {\n        const data = {\n          name: xml.getAttribute('name')\n        };\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'optics':\n              data.optics = parseCameraOptics(child);\n              break;\n          }\n        }\n        library.cameras[xml.getAttribute('id')] = data;\n      }\n      function parseCameraOptics(xml) {\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'technique_common':\n              return parseCameraTechnique(child);\n          }\n        }\n        return {};\n      }\n      function parseCameraTechnique(xml) {\n        const data = {};\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'perspective':\n            case 'orthographic':\n              data.technique = child.nodeName;\n              data.parameters = parseCameraParameters(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseCameraParameters(xml) {\n        const data = {};\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'xfov':\n            case 'yfov':\n            case 'xmag':\n            case 'ymag':\n            case 'znear':\n            case 'zfar':\n            case 'aspect_ratio':\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildCamera(data) {\n        let camera;\n        switch (data.optics.technique) {\n          case 'perspective':\n            camera = new THREE.PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n          case 'orthographic':\n            let ymag = data.optics.parameters.ymag;\n            let xmag = data.optics.parameters.xmag;\n            const aspectRatio = data.optics.parameters.aspect_ratio;\n            xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n            ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n            xmag *= 0.5;\n            ymag *= 0.5;\n            camera = new THREE.OrthographicCamera(-xmag, xmag, ymag, -ymag,\n            // left, right, top, bottom\n            data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n          default:\n            camera = new THREE.PerspectiveCamera();\n            break;\n        }\n        camera.name = data.name || '';\n        return camera;\n      }\n      function getCamera(id) {\n        const data = library.cameras[id];\n        if (data !== undefined) {\n          return getBuild(data, buildCamera);\n        }\n        console.warn('THREE.ColladaLoader: Couldn\\'t find camera with ID:', id);\n        return null;\n      } // light\n\n      function parseLight(xml) {\n        let data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique_common':\n              data = parseLightTechnique(child);\n              break;\n          }\n        }\n        library.lights[xml.getAttribute('id')] = data;\n      }\n      function parseLightTechnique(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'directional':\n            case 'point':\n            case 'spot':\n            case 'ambient':\n              data.technique = child.nodeName;\n              data.parameters = parseLightParameters(child);\n          }\n        }\n        return data;\n      }\n      function parseLightParameters(xml) {\n        const data = {};\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'color':\n              const array = parseFloats(child.textContent);\n              data.color = new THREE.Color().fromArray(array);\n              break;\n            case 'falloff_angle':\n              data.falloffAngle = parseFloat(child.textContent);\n              break;\n            case 'quadratic_attenuation':\n              const f = parseFloat(child.textContent);\n              data.distance = f ? Math.sqrt(1 / f) : 0;\n              break;\n          }\n        }\n        return data;\n      }\n      function buildLight(data) {\n        let light;\n        switch (data.technique) {\n          case 'directional':\n            light = new THREE.DirectionalLight();\n            break;\n          case 'point':\n            light = new THREE.PointLight();\n            break;\n          case 'spot':\n            light = new THREE.SpotLight();\n            break;\n          case 'ambient':\n            light = new THREE.AmbientLight();\n            break;\n        }\n        if (data.parameters.color) light.color.copy(data.parameters.color);\n        if (data.parameters.distance) light.distance = data.parameters.distance;\n        return light;\n      }\n      function getLight(id) {\n        const data = library.lights[id];\n        if (data !== undefined) {\n          return getBuild(data, buildLight);\n        }\n        console.warn('THREE.ColladaLoader: Couldn\\'t find light with ID:', id);\n        return null;\n      } // geometry\n\n      function parseGeometry(xml) {\n        const data = {\n          name: xml.getAttribute('name'),\n          sources: {},\n          vertices: {},\n          primitives: []\n        };\n        const mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n        if (mesh === undefined) return;\n        for (let i = 0; i < mesh.childNodes.length; i++) {\n          const child = mesh.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          const id = child.getAttribute('id');\n          switch (child.nodeName) {\n            case 'source':\n              data.sources[id] = parseSource(child);\n              break;\n            case 'vertices':\n              // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n              data.vertices = parseGeometryVertices(child);\n              break;\n            case 'polygons':\n              console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n              break;\n            case 'lines':\n            case 'linestrips':\n            case 'polylist':\n            case 'triangles':\n              data.primitives.push(parseGeometryPrimitive(child));\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        library.geometries[xml.getAttribute('id')] = data;\n      }\n      function parseSource(xml) {\n        const data = {\n          array: [],\n          stride: 3\n        };\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'float_array':\n              data.array = parseFloats(child.textContent);\n              break;\n            case 'Name_array':\n              data.array = parseStrings(child.textContent);\n              break;\n            case 'technique_common':\n              const accessor = getElementsByTagName(child, 'accessor')[0];\n              if (accessor !== undefined) {\n                data.stride = parseInt(accessor.getAttribute('stride'));\n              }\n              break;\n          }\n        }\n        return data;\n      }\n      function parseGeometryVertices(xml) {\n        const data = {};\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n        }\n        return data;\n      }\n      function parseGeometryPrimitive(xml) {\n        const primitive = {\n          type: xml.nodeName,\n          material: xml.getAttribute('material'),\n          count: parseInt(xml.getAttribute('count')),\n          inputs: {},\n          stride: 0,\n          hasUV: false\n        };\n        for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'input':\n              const id = parseId(child.getAttribute('source'));\n              const semantic = child.getAttribute('semantic');\n              const offset = parseInt(child.getAttribute('offset'));\n              const set = parseInt(child.getAttribute('set'));\n              const inputname = set > 0 ? semantic + set : semantic;\n              primitive.inputs[inputname] = {\n                id: id,\n                offset: offset\n              };\n              primitive.stride = Math.max(primitive.stride, offset + 1);\n              if (semantic === 'TEXCOORD') primitive.hasUV = true;\n              break;\n            case 'vcount':\n              primitive.vcount = parseInts(child.textContent);\n              break;\n            case 'p':\n              primitive.p = parseInts(child.textContent);\n              break;\n          }\n        }\n        return primitive;\n      }\n      function groupPrimitives(primitives) {\n        const build = {};\n        for (let i = 0; i < primitives.length; i++) {\n          const primitive = primitives[i];\n          if (build[primitive.type] === undefined) build[primitive.type] = [];\n          build[primitive.type].push(primitive);\n        }\n        return build;\n      }\n      function checkUVCoordinates(primitives) {\n        let count = 0;\n        for (let i = 0, l = primitives.length; i < l; i++) {\n          const primitive = primitives[i];\n          if (primitive.hasUV === true) {\n            count++;\n          }\n        }\n        if (count > 0 && count < primitives.length) {\n          primitives.uvsNeedsFix = true;\n        }\n      }\n      function buildGeometry(data) {\n        const build = {};\n        const sources = data.sources;\n        const vertices = data.vertices;\n        const primitives = data.primitives;\n        if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n        // first, we group all primitives by their type\n\n        const groupedPrimitives = groupPrimitives(primitives);\n        for (const type in groupedPrimitives) {\n          const primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n          checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n          build[type] = buildGeometryType(primitiveType, sources, vertices);\n        }\n        return build;\n      }\n      function buildGeometryType(primitives, sources, vertices) {\n        const build = {};\n        const position = {\n          array: [],\n          stride: 0\n        };\n        const normal = {\n          array: [],\n          stride: 0\n        };\n        const uv = {\n          array: [],\n          stride: 0\n        };\n        const uv2 = {\n          array: [],\n          stride: 0\n        };\n        const color = {\n          array: [],\n          stride: 0\n        };\n        const skinIndex = {\n          array: [],\n          stride: 4\n        };\n        const skinWeight = {\n          array: [],\n          stride: 4\n        };\n        const geometry = new THREE.BufferGeometry();\n        const materialKeys = [];\n        let start = 0;\n        for (let p = 0; p < primitives.length; p++) {\n          const primitive = primitives[p];\n          const inputs = primitive.inputs; // groups\n\n          let count = 0;\n          switch (primitive.type) {\n            case 'lines':\n            case 'linestrips':\n              count = primitive.count * 2;\n              break;\n            case 'triangles':\n              count = primitive.count * 3;\n              break;\n            case 'polylist':\n              for (let g = 0; g < primitive.count; g++) {\n                const vc = primitive.vcount[g];\n                switch (vc) {\n                  case 3:\n                    count += 3; // single triangle\n\n                    break;\n                  case 4:\n                    count += 6; // quad, subdivided into two triangles\n\n                    break;\n                  default:\n                    count += (vc - 2) * 3; // polylist with more than four vertices\n\n                    break;\n                }\n              }\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n          }\n          geometry.addGroup(start, count, p);\n          start += count; // material\n\n          if (primitive.material) {\n            materialKeys.push(primitive.material);\n          } // geometry data\n\n          for (const name in inputs) {\n            const input = inputs[name];\n            switch (name) {\n              case 'VERTEX':\n                for (const key in vertices) {\n                  const id = vertices[key];\n                  switch (key) {\n                    case 'POSITION':\n                      const prevLength = position.array.length;\n                      buildGeometryData(primitive, sources[id], input.offset, position.array);\n                      position.stride = sources[id].stride;\n                      if (sources.skinWeights && sources.skinIndices) {\n                        buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                        buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                      } // see #3803\n\n                      if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                        const count = (position.array.length - prevLength) / position.stride;\n                        for (let i = 0; i < count; i++) {\n                          // fill missing uv coordinates\n                          uv.array.push(0, 0);\n                        }\n                      }\n                      break;\n                    case 'NORMAL':\n                      buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                      normal.stride = sources[id].stride;\n                      break;\n                    case 'COLOR':\n                      buildGeometryData(primitive, sources[id], input.offset, color.array);\n                      color.stride = sources[id].stride;\n                      break;\n                    case 'TEXCOORD':\n                      buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                      uv.stride = sources[id].stride;\n                      break;\n                    case 'TEXCOORD1':\n                      buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                      uv.stride = sources[id].stride;\n                      break;\n                    default:\n                      console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                  }\n                }\n                break;\n              case 'NORMAL':\n                buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n                normal.stride = sources[input.id].stride;\n                break;\n              case 'COLOR':\n                buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n                color.stride = sources[input.id].stride;\n                break;\n              case 'TEXCOORD':\n                buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n                uv.stride = sources[input.id].stride;\n                break;\n              case 'TEXCOORD1':\n                buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n                uv2.stride = sources[input.id].stride;\n                break;\n            }\n          }\n        } // build geometry\n\n        if (position.array.length > 0) geometry.setAttribute('position', new THREE.Float32BufferAttribute(position.array, position.stride));\n        if (normal.array.length > 0) geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normal.array, normal.stride));\n        if (color.array.length > 0) geometry.setAttribute('color', new THREE.Float32BufferAttribute(color.array, color.stride));\n        if (uv.array.length > 0) geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uv.array, uv.stride));\n        if (uv2.array.length > 0) geometry.setAttribute('uv2', new THREE.Float32BufferAttribute(uv2.array, uv2.stride));\n        if (skinIndex.array.length > 0) geometry.setAttribute('skinIndex', new THREE.Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n        if (skinWeight.array.length > 0) geometry.setAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n        build.data = geometry;\n        build.type = primitives[0].type;\n        build.materialKeys = materialKeys;\n        return build;\n      }\n      function buildGeometryData(primitive, source, offset, array) {\n        const indices = primitive.p;\n        const stride = primitive.stride;\n        const vcount = primitive.vcount;\n        function pushVector(i) {\n          let index = indices[i + offset] * sourceStride;\n          const length = index + sourceStride;\n          for (; index < length; index++) {\n            array.push(sourceArray[index]);\n          }\n        }\n        const sourceArray = source.array;\n        const sourceStride = source.stride;\n        if (primitive.vcount !== undefined) {\n          let index = 0;\n          for (let i = 0, l = vcount.length; i < l; i++) {\n            const count = vcount[i];\n            if (count === 4) {\n              const a = index + stride * 0;\n              const b = index + stride * 1;\n              const c = index + stride * 2;\n              const d = index + stride * 3;\n              pushVector(a);\n              pushVector(b);\n              pushVector(d);\n              pushVector(b);\n              pushVector(c);\n              pushVector(d);\n            } else if (count === 3) {\n              const a = index + stride * 0;\n              const b = index + stride * 1;\n              const c = index + stride * 2;\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            } else if (count > 4) {\n              for (let k = 1, kl = count - 2; k <= kl; k++) {\n                const a = index + stride * 0;\n                const b = index + stride * k;\n                const c = index + stride * (k + 1);\n                pushVector(a);\n                pushVector(b);\n                pushVector(c);\n              }\n            }\n            index += stride * count;\n          }\n        } else {\n          for (let i = 0, l = indices.length; i < l; i += stride) {\n            pushVector(i);\n          }\n        }\n      }\n      function getGeometry(id) {\n        return getBuild(library.geometries[id], buildGeometry);\n      } // kinematics\n\n      function parseKinematicsModel(xml) {\n        const data = {\n          name: xml.getAttribute('name') || '',\n          joints: {},\n          links: []\n        };\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique_common':\n              parseKinematicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n        library.kinematicsModels[xml.getAttribute('id')] = data;\n      }\n      function buildKinematicsModel(data) {\n        if (data.build !== undefined) return data.build;\n        return data;\n      }\n      function getKinematicsModel(id) {\n        return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n      }\n      function parseKinematicsTechniqueCommon(xml, data) {\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'joint':\n              data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n              break;\n            case 'link':\n              data.links.push(parseKinematicsLink(child));\n              break;\n          }\n        }\n      }\n      function parseKinematicsJoint(xml) {\n        let data;\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'prismatic':\n            case 'revolute':\n              data = parseKinematicsJointParameter(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsJointParameter(xml) {\n        const data = {\n          sid: xml.getAttribute('sid'),\n          name: xml.getAttribute('name') || '',\n          axis: new THREE.Vector3(),\n          limits: {\n            min: 0,\n            max: 0\n          },\n          type: xml.nodeName,\n          static: false,\n          zeroPosition: 0,\n          middlePosition: 0\n        };\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'axis':\n              const array = parseFloats(child.textContent);\n              data.axis.fromArray(array);\n              break;\n            case 'limits':\n              const max = child.getElementsByTagName('max')[0];\n              const min = child.getElementsByTagName('min')[0];\n              data.limits.max = parseFloat(max.textContent);\n              data.limits.min = parseFloat(min.textContent);\n              break;\n          }\n        } // if min is equal to or greater than max, consider the joint static\n\n        if (data.limits.min >= data.limits.max) {\n          data.static = true;\n        } // calculate middle position\n\n        data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n        return data;\n      }\n      function parseKinematicsLink(xml) {\n        const data = {\n          sid: xml.getAttribute('sid'),\n          name: xml.getAttribute('name') || '',\n          attachments: [],\n          transforms: []\n        };\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'attachment_full':\n              data.attachments.push(parseKinematicsAttachment(child));\n              break;\n            case 'matrix':\n            case 'translate':\n            case 'rotate':\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsAttachment(xml) {\n        const data = {\n          joint: xml.getAttribute('joint').split('/').pop(),\n          transforms: [],\n          links: []\n        };\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'link':\n              data.links.push(parseKinematicsLink(child));\n              break;\n            case 'matrix':\n            case 'translate':\n            case 'rotate':\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsTransform(xml) {\n        const data = {\n          type: xml.nodeName\n        };\n        const array = parseFloats(xml.textContent);\n        switch (data.type) {\n          case 'matrix':\n            data.obj = new THREE.Matrix4();\n            data.obj.fromArray(array).transpose();\n            break;\n          case 'translate':\n            data.obj = new THREE.Vector3();\n            data.obj.fromArray(array);\n            break;\n          case 'rotate':\n            data.obj = new THREE.Vector3();\n            data.obj.fromArray(array);\n            data.angle = THREE.MathUtils.degToRad(array[3]);\n            break;\n        }\n        return data;\n      } // physics\n\n      function parsePhysicsModel(xml) {\n        const data = {\n          name: xml.getAttribute('name') || '',\n          rigidBodies: {}\n        };\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'rigid_body':\n              data.rigidBodies[child.getAttribute('name')] = {};\n              parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n              break;\n          }\n        }\n        library.physicsModels[xml.getAttribute('id')] = data;\n      }\n      function parsePhysicsRigidBody(xml, data) {\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'technique_common':\n              parsePhysicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n      }\n      function parsePhysicsTechniqueCommon(xml, data) {\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'inertia':\n              data.inertia = parseFloats(child.textContent);\n              break;\n            case 'mass':\n              data.mass = parseFloats(child.textContent)[0];\n              break;\n          }\n        }\n      } // scene\n\n      function parseKinematicsScene(xml) {\n        const data = {\n          bindJointAxis: []\n        };\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'bind_joint_axis':\n              data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n              break;\n          }\n        }\n        library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n      }\n      function parseKinematicsBindJointAxis(xml) {\n        const data = {\n          target: xml.getAttribute('target').split('/').pop()\n        };\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case 'axis':\n              const param = child.getElementsByTagName('param')[0];\n              data.axis = param.textContent;\n              const tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n              data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildKinematicsScene(data) {\n        if (data.build !== undefined) return data.build;\n        return data;\n      }\n      function getKinematicsScene(id) {\n        return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n      }\n      function setupKinematics() {\n        const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n        const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n        const visualSceneId = Object.keys(library.visualScenes)[0];\n        if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n        const kinematicsModel = getKinematicsModel(kinematicsModelId);\n        const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n        const visualScene = getVisualScene(visualSceneId);\n        const bindJointAxis = kinematicsScene.bindJointAxis;\n        const jointMap = {};\n        for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n          const axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n          const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n          if (targetElement) {\n            // get the parent of the transform element\n            const parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n            connect(axis.jointIndex, parentVisualElement);\n          }\n        }\n        function connect(jointIndex, visualElement) {\n          const visualElementName = visualElement.getAttribute('name');\n          const joint = kinematicsModel.joints[jointIndex];\n          visualScene.traverse(function (object) {\n            if (object.name === visualElementName) {\n              jointMap[jointIndex] = {\n                object: object,\n                transforms: buildTransformList(visualElement),\n                joint: joint,\n                position: joint.zeroPosition\n              };\n            }\n          });\n        }\n        const m0 = new THREE.Matrix4();\n        kinematics = {\n          joints: kinematicsModel && kinematicsModel.joints,\n          getJointValue: function (jointIndex) {\n            const jointData = jointMap[jointIndex];\n            if (jointData) {\n              return jointData.position;\n            } else {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.');\n            }\n          },\n          setJointValue: function (jointIndex, value) {\n            const jointData = jointMap[jointIndex];\n            if (jointData) {\n              const joint = jointData.joint;\n              if (value > joint.limits.max || value < joint.limits.min) {\n                console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n              } else if (joint.static) {\n                console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n              } else {\n                const object = jointData.object;\n                const axis = joint.axis;\n                const transforms = jointData.transforms;\n                matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n                for (let i = 0; i < transforms.length; i++) {\n                  const transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                  if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                    switch (joint.type) {\n                      case 'revolute':\n                        matrix.multiply(m0.makeRotationAxis(axis, THREE.MathUtils.degToRad(value)));\n                        break;\n                      case 'prismatic':\n                        matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                        break;\n                      default:\n                        console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                        break;\n                    }\n                  } else {\n                    switch (transform.type) {\n                      case 'matrix':\n                        matrix.multiply(transform.obj);\n                        break;\n                      case 'translate':\n                        matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                        break;\n                      case 'scale':\n                        matrix.scale(transform.obj);\n                        break;\n                      case 'rotate':\n                        matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                        break;\n                    }\n                  }\n                }\n                object.matrix.copy(matrix);\n                object.matrix.decompose(object.position, object.quaternion, object.scale);\n                jointMap[jointIndex].position = value;\n              }\n            } else {\n              console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n            }\n          }\n        };\n      }\n      function buildTransformList(node) {\n        const transforms = [];\n        const xml = collada.querySelector('[id=\"' + node.id + '\"]');\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          let array, vector;\n          switch (child.nodeName) {\n            case 'matrix':\n              array = parseFloats(child.textContent);\n              const matrix = new THREE.Matrix4().fromArray(array).transpose();\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: matrix\n              });\n              break;\n            case 'translate':\n            case 'scale':\n              array = parseFloats(child.textContent);\n              vector = new THREE.Vector3().fromArray(array);\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: vector\n              });\n              break;\n            case 'rotate':\n              array = parseFloats(child.textContent);\n              vector = new THREE.Vector3().fromArray(array);\n              const angle = THREE.MathUtils.degToRad(array[3]);\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: vector,\n                angle: angle\n              });\n              break;\n          }\n        }\n        return transforms;\n      } // nodes\n\n      function prepareNodes(xml) {\n        const elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n        for (let i = 0; i < elements.length; i++) {\n          const element = elements[i];\n          if (element.hasAttribute('id') === false) {\n            element.setAttribute('id', generateId());\n          }\n        }\n      }\n      const matrix = new THREE.Matrix4();\n      const vector = new THREE.Vector3();\n      function parseNode(xml) {\n        const data = {\n          name: xml.getAttribute('name') || '',\n          type: xml.getAttribute('type'),\n          id: xml.getAttribute('id'),\n          sid: xml.getAttribute('sid'),\n          matrix: new THREE.Matrix4(),\n          nodes: [],\n          instanceCameras: [],\n          instanceControllers: [],\n          instanceLights: [],\n          instanceGeometries: [],\n          instanceNodes: [],\n          transforms: {}\n        };\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          let array;\n          switch (child.nodeName) {\n            case 'node':\n              data.nodes.push(child.getAttribute('id'));\n              parseNode(child);\n              break;\n            case 'instance_camera':\n              data.instanceCameras.push(parseId(child.getAttribute('url')));\n              break;\n            case 'instance_controller':\n              data.instanceControllers.push(parseNodeInstance(child));\n              break;\n            case 'instance_light':\n              data.instanceLights.push(parseId(child.getAttribute('url')));\n              break;\n            case 'instance_geometry':\n              data.instanceGeometries.push(parseNodeInstance(child));\n              break;\n            case 'instance_node':\n              data.instanceNodes.push(parseId(child.getAttribute('url')));\n              break;\n            case 'matrix':\n              array = parseFloats(child.textContent);\n              data.matrix.multiply(matrix.fromArray(array).transpose());\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'translate':\n              array = parseFloats(child.textContent);\n              vector.fromArray(array);\n              data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'rotate':\n              array = parseFloats(child.textContent);\n              const angle = THREE.MathUtils.degToRad(array[3]);\n              data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'scale':\n              array = parseFloats(child.textContent);\n              data.matrix.scale(vector.fromArray(array));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n            case 'extra':\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        if (hasNode(data.id)) {\n          console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n        } else {\n          library.nodes[data.id] = data;\n        }\n        return data;\n      }\n      function parseNodeInstance(xml) {\n        const data = {\n          id: parseId(xml.getAttribute('url')),\n          materials: {},\n          skeletons: []\n        };\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const child = xml.childNodes[i];\n          switch (child.nodeName) {\n            case 'bind_material':\n              const instances = child.getElementsByTagName('instance_material');\n              for (let j = 0; j < instances.length; j++) {\n                const instance = instances[j];\n                const symbol = instance.getAttribute('symbol');\n                const target = instance.getAttribute('target');\n                data.materials[symbol] = parseId(target);\n              }\n              break;\n            case 'skeleton':\n              data.skeletons.push(parseId(child.textContent));\n              break;\n            default:\n              break;\n          }\n        }\n        return data;\n      }\n      function buildSkeleton(skeletons, joints) {\n        const boneData = [];\n        const sortedBoneData = [];\n        let i, j, data; // a skeleton can have multiple root bones. collada expresses this\n        // situtation with multiple \"skeleton\" tags per controller instance\n\n        for (i = 0; i < skeletons.length; i++) {\n          const skeleton = skeletons[i];\n          let root;\n          if (hasNode(skeleton)) {\n            root = getNode(skeleton);\n            buildBoneHierarchy(root, joints, boneData);\n          } else if (hasVisualScene(skeleton)) {\n            // handle case where the skeleton refers to the visual scene (#13335)\n            const visualScene = library.visualScenes[skeleton];\n            const children = visualScene.children;\n            for (let j = 0; j < children.length; j++) {\n              const child = children[j];\n              if (child.type === 'JOINT') {\n                const root = getNode(child.id);\n                buildBoneHierarchy(root, joints, boneData);\n              }\n            }\n          } else {\n            console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n          }\n        } // sort bone data (the order is defined in the corresponding controller)\n\n        for (i = 0; i < joints.length; i++) {\n          for (j = 0; j < boneData.length; j++) {\n            data = boneData[j];\n            if (data.bone.name === joints[i].name) {\n              sortedBoneData[i] = data;\n              data.processed = true;\n              break;\n            }\n          }\n        } // add unprocessed bone data at the end of the list\n\n        for (i = 0; i < boneData.length; i++) {\n          data = boneData[i];\n          if (data.processed === false) {\n            sortedBoneData.push(data);\n            data.processed = true;\n          }\n        } // setup arrays for skeleton creation\n\n        const bones = [];\n        const boneInverses = [];\n        for (i = 0; i < sortedBoneData.length; i++) {\n          data = sortedBoneData[i];\n          bones.push(data.bone);\n          boneInverses.push(data.boneInverse);\n        }\n        return new THREE.Skeleton(bones, boneInverses);\n      }\n      function buildBoneHierarchy(root, joints, boneData) {\n        // setup bone data from visual scene\n        root.traverse(function (object) {\n          if (object.isBone === true) {\n            let boneInverse; // retrieve the boneInverse from the controller data\n\n            for (let i = 0; i < joints.length; i++) {\n              const joint = joints[i];\n              if (joint.name === object.name) {\n                boneInverse = joint.boneInverse;\n                break;\n              }\n            }\n            if (boneInverse === undefined) {\n              // Unfortunately, there can be joints in the visual scene that are not part of the\n              // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n              // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n              // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n              // ensure a correct animation of the model.\n              boneInverse = new THREE.Matrix4();\n            }\n            boneData.push({\n              bone: object,\n              boneInverse: boneInverse,\n              processed: false\n            });\n          }\n        });\n      }\n      function buildNode(data) {\n        const objects = [];\n        const matrix = data.matrix;\n        const nodes = data.nodes;\n        const type = data.type;\n        const instanceCameras = data.instanceCameras;\n        const instanceControllers = data.instanceControllers;\n        const instanceLights = data.instanceLights;\n        const instanceGeometries = data.instanceGeometries;\n        const instanceNodes = data.instanceNodes; // nodes\n\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          objects.push(getNode(nodes[i]));\n        } // instance cameras\n\n        for (let i = 0, l = instanceCameras.length; i < l; i++) {\n          const instanceCamera = getCamera(instanceCameras[i]);\n          if (instanceCamera !== null) {\n            objects.push(instanceCamera.clone());\n          }\n        } // instance controllers\n\n        for (let i = 0, l = instanceControllers.length; i < l; i++) {\n          const instance = instanceControllers[i];\n          const controller = getController(instance.id);\n          const geometries = getGeometry(controller.id);\n          const newObjects = buildObjects(geometries, instance.materials);\n          const skeletons = instance.skeletons;\n          const joints = controller.skin.joints;\n          const skeleton = buildSkeleton(skeletons, joints);\n          for (let j = 0, jl = newObjects.length; j < jl; j++) {\n            const object = newObjects[j];\n            if (object.isSkinnedMesh) {\n              object.bind(skeleton, controller.skin.bindMatrix);\n              object.normalizeSkinWeights();\n            }\n            objects.push(object);\n          }\n        } // instance lights\n\n        for (let i = 0, l = instanceLights.length; i < l; i++) {\n          const instanceLight = getLight(instanceLights[i]);\n          if (instanceLight !== null) {\n            objects.push(instanceLight.clone());\n          }\n        } // instance geometries\n\n        for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n          const instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\n          // this is the case when primitives are combined like triangles and lines\n\n          const geometries = getGeometry(instance.id);\n          const newObjects = buildObjects(geometries, instance.materials);\n          for (let j = 0, jl = newObjects.length; j < jl; j++) {\n            objects.push(newObjects[j]);\n          }\n        } // instance nodes\n\n        for (let i = 0, l = instanceNodes.length; i < l; i++) {\n          objects.push(getNode(instanceNodes[i]).clone());\n        }\n        let object;\n        if (nodes.length === 0 && objects.length === 1) {\n          object = objects[0];\n        } else {\n          object = type === 'JOINT' ? new THREE.Bone() : new THREE.Group();\n          for (let i = 0; i < objects.length; i++) {\n            object.add(objects[i]);\n          }\n        }\n        object.name = type === 'JOINT' ? data.sid : data.name;\n        object.matrix.copy(matrix);\n        object.matrix.decompose(object.position, object.quaternion, object.scale);\n        return object;\n      }\n      const fallbackMaterial = new THREE.MeshBasicMaterial({\n        color: 0xff00ff\n      });\n      function resolveMaterialBinding(keys, instanceMaterials) {\n        const materials = [];\n        for (let i = 0, l = keys.length; i < l; i++) {\n          const id = instanceMaterials[keys[i]];\n          if (id === undefined) {\n            console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n            materials.push(fallbackMaterial);\n          } else {\n            materials.push(getMaterial(id));\n          }\n        }\n        return materials;\n      }\n      function buildObjects(geometries, instanceMaterials) {\n        const objects = [];\n        for (const type in geometries) {\n          const geometry = geometries[type];\n          const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n          if (materials.length === 0) {\n            if (type === 'lines' || type === 'linestrips') {\n              materials.push(new THREE.LineBasicMaterial());\n            } else {\n              materials.push(new THREE.MeshPhongMaterial());\n            }\n          } // regard skinning\n\n          const skinning = geometry.data.attributes.skinIndex !== undefined; // choose between a single or multi materials (material array)\n\n          const material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n          let object;\n          switch (type) {\n            case 'lines':\n              object = new THREE.LineSegments(geometry.data, material);\n              break;\n            case 'linestrips':\n              object = new THREE.Line(geometry.data, material);\n              break;\n            case 'triangles':\n            case 'polylist':\n              if (skinning) {\n                object = new THREE.SkinnedMesh(geometry.data, material);\n              } else {\n                object = new THREE.Mesh(geometry.data, material);\n              }\n              break;\n          }\n          objects.push(object);\n        }\n        return objects;\n      }\n      function hasNode(id) {\n        return library.nodes[id] !== undefined;\n      }\n      function getNode(id) {\n        return getBuild(library.nodes[id], buildNode);\n      } // visual scenes\n\n      function parseVisualScene(xml) {\n        const data = {\n          name: xml.getAttribute('name'),\n          children: []\n        };\n        prepareNodes(xml);\n        const elements = getElementsByTagName(xml, 'node');\n        for (let i = 0; i < elements.length; i++) {\n          data.children.push(parseNode(elements[i]));\n        }\n        library.visualScenes[xml.getAttribute('id')] = data;\n      }\n      function buildVisualScene(data) {\n        const group = new THREE.Group();\n        group.name = data.name;\n        const children = data.children;\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          group.add(getNode(child.id));\n        }\n        return group;\n      }\n      function hasVisualScene(id) {\n        return library.visualScenes[id] !== undefined;\n      }\n      function getVisualScene(id) {\n        return getBuild(library.visualScenes[id], buildVisualScene);\n      } // scenes\n\n      function parseScene(xml) {\n        const instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n        return getVisualScene(parseId(instance.getAttribute('url')));\n      }\n      function setupAnimations() {\n        const clips = library.clips;\n        if (isEmpty(clips) === true) {\n          if (isEmpty(library.animations) === false) {\n            // if there are animations but no clips, we create a default clip for playback\n            const tracks = [];\n            for (const id in library.animations) {\n              const animationTracks = getAnimation(id);\n              for (let i = 0, l = animationTracks.length; i < l; i++) {\n                tracks.push(animationTracks[i]);\n              }\n            }\n            animations.push(new THREE.AnimationClip('default', -1, tracks));\n          }\n        } else {\n          for (const id in clips) {\n            animations.push(getAnimationClip(id));\n          }\n        }\n      } // convert the parser error element into text with each child elements text\n      // separated by new lines.\n\n      function parserErrorToText(parserError) {\n        let result = '';\n        const stack = [parserError];\n        while (stack.length) {\n          const node = stack.shift();\n          if (node.nodeType === Node.TEXT_NODE) {\n            result += node.textContent;\n          } else {\n            result += '\\n';\n            stack.push.apply(stack, node.childNodes);\n          }\n        }\n        return result.trim();\n      }\n      if (text.length === 0) {\n        return {\n          scene: new THREE.Scene()\n        };\n      }\n      const xml = new DOMParser().parseFromString(text, 'application/xml');\n      const collada = getElementsByTagName(xml, 'COLLADA')[0];\n      const parserError = xml.getElementsByTagName('parsererror')[0];\n      if (parserError !== undefined) {\n        // Chrome will return parser error with a div in it\n        const errorElement = getElementsByTagName(parserError, 'div')[0];\n        let errorText;\n        if (errorElement) {\n          errorText = errorElement.textContent;\n        } else {\n          errorText = parserErrorToText(parserError);\n        }\n        console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n        return null;\n      } // metadata\n\n      const version = collada.getAttribute('version');\n      console.log('THREE.ColladaLoader: File version', version);\n      const asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n      const textureLoader = new THREE.TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      let tgaLoader;\n      if (THREE.TGALoader) {\n        tgaLoader = new THREE.TGALoader(this.manager);\n        tgaLoader.setPath(this.resourcePath || path);\n      } //\n\n      const animations = [];\n      let kinematics = {};\n      let count = 0; //\n\n      const library = {\n        animations: {},\n        clips: {},\n        controllers: {},\n        images: {},\n        effects: {},\n        materials: {},\n        cameras: {},\n        lights: {},\n        geometries: {},\n        nodes: {},\n        visualScenes: {},\n        kinematicsModels: {},\n        physicsModels: {},\n        kinematicsScenes: {}\n      };\n      parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n      parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n      parseLibrary(collada, 'library_controllers', 'controller', parseController);\n      parseLibrary(collada, 'library_images', 'image', parseImage);\n      parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n      parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n      parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n      parseLibrary(collada, 'library_lights', 'light', parseLight);\n      parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n      parseLibrary(collada, 'library_nodes', 'node', parseNode);\n      parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n      parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n      parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n      parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n      buildLibrary(library.animations, buildAnimation);\n      buildLibrary(library.clips, buildAnimationClip);\n      buildLibrary(library.controllers, buildController);\n      buildLibrary(library.images, buildImage);\n      buildLibrary(library.effects, buildEffect);\n      buildLibrary(library.materials, buildMaterial);\n      buildLibrary(library.cameras, buildCamera);\n      buildLibrary(library.lights, buildLight);\n      buildLibrary(library.geometries, buildGeometry);\n      buildLibrary(library.visualScenes, buildVisualScene);\n      setupAnimations();\n      setupKinematics();\n      const scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n      scene.animations = animations;\n      if (asset.upAxis === 'Z_UP') {\n        scene.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));\n      }\n      scene.scale.multiplyScalar(asset.unit);\n      return {\n        get animations() {\n          console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n          return animations;\n        },\n        kinematics: kinematics,\n        library: library,\n        scene: scene\n      };\n    }\n  }\n  THREE.ColladaLoader = ColladaLoader;\n})();\nmodule.exports = exports = THREE.ColladaLoader;","map":{"version":3,"names":["THREE","require","ColladaLoader","Loader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","undefined","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","animations","MathUtils","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","value","index","warn","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","Vector3","scale","quaternion","Quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","VectorKeyframeTrack","QuaternionKeyframeTrack","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","key","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animationTracks","AnimationClip","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","Matrix4","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechnique","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","MeshPhongMaterial","MeshLambertMaterial","MeshBasicMaterial","getTexture","textureObject","surface","texture","wrapS","wrapU","RepeatWrapping","ClampToEdgeWrapping","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","double_sided","side","DoubleSide","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","PerspectiveCamera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","OrthographicCamera","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","Color","falloffAngle","f","distance","Math","sqrt","buildLight","light","DirectionalLight","PointLight","SpotLight","AmbientLight","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","normal","uv","uv2","BufferGeometry","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","setAttribute","Float32BufferAttribute","pushVector","sourceStride","sourceArray","c","k","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector","prepareNodes","element","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","bone","processed","bones","boneInverses","Skeleton","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","Bone","Group","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","LineBasicMaterial","skinning","attributes","LineSegments","Line","SkinnedMesh","Mesh","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError","result","stack","Node","TEXT_NODE","apply","scene","Scene","DOMParser","parseFromString","errorElement","errorText","version","asset","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","TGALoader","setFromEuler","Euler","PI","multiplyScalar","module","exports"],"sources":["/Users/mihailbaleev/Documents/GitHub/lastochka_spraying/node_modules/threebox-plugin/src/objects/loaders/ColladaLoader.js"],"sourcesContent":["const THREE = require('../../three.js');\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\n(function () {\r\n\r\n\tclass ColladaLoader extends THREE.Loader {\r\n\r\n\t\tconstructor(manager) {\r\n\r\n\t\t\tsuper(manager);\r\n\r\n\t\t}\r\n\r\n\t\tload(url, onLoad, onProgress, onError) {\r\n\r\n\t\t\tconst scope = this;\r\n\t\t\tconst path = scope.path === '' ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;\r\n\t\t\tconst loader = new THREE.FileLoader(scope.manager);\r\n\t\t\tloader.setPath(scope.path);\r\n\t\t\tloader.setRequestHeader(scope.requestHeader);\r\n\t\t\tloader.setWithCredentials(scope.withCredentials);\r\n\t\t\tloader.load(url, function (text) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tonLoad(scope.parse(text, path));\r\n\r\n\t\t\t\t} catch (e) {\r\n\r\n\t\t\t\t\tif (onError) {\r\n\r\n\t\t\t\t\t\tonError(e);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.error(e);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.manager.itemError(url);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, onError);\r\n\r\n\t\t}\r\n\r\n\t\tparse(text, path) {\r\n\r\n\t\t\tfunction getElementsByTagName(xml, name) {\r\n\r\n\t\t\t\t// Non recursive xml.getElementsByTagName() ...\r\n\t\t\t\tconst array = [];\r\n\t\t\t\tconst childNodes = xml.childNodes;\r\n\r\n\t\t\t\tfor (let i = 0, l = childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = childNodes[i];\r\n\r\n\t\t\t\t\tif (child.nodeName === name) {\r\n\r\n\t\t\t\t\t\tarray.push(child);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn array;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseStrings(text) {\r\n\r\n\t\t\t\tif (text.length === 0) return [];\r\n\t\t\t\tconst parts = text.trim().split(/\\s+/);\r\n\t\t\t\tconst array = new Array(parts.length);\r\n\r\n\t\t\t\tfor (let i = 0, l = parts.length; i < l; i++) {\r\n\r\n\t\t\t\t\tarray[i] = parts[i];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn array;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseFloats(text) {\r\n\r\n\t\t\t\tif (text.length === 0) return [];\r\n\t\t\t\tconst parts = text.trim().split(/\\s+/);\r\n\t\t\t\tconst array = new Array(parts.length);\r\n\r\n\t\t\t\tfor (let i = 0, l = parts.length; i < l; i++) {\r\n\r\n\t\t\t\t\tarray[i] = parseFloat(parts[i]);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn array;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseInts(text) {\r\n\r\n\t\t\t\tif (text.length === 0) return [];\r\n\t\t\t\tconst parts = text.trim().split(/\\s+/);\r\n\t\t\t\tconst array = new Array(parts.length);\r\n\r\n\t\t\t\tfor (let i = 0, l = parts.length; i < l; i++) {\r\n\r\n\t\t\t\t\tarray[i] = parseInt(parts[i]);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn array;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseId(text) {\r\n\r\n\t\t\t\treturn text.substring(1);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction generateId() {\r\n\r\n\t\t\t\treturn 'three_default_' + count++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction isEmpty(object) {\r\n\r\n\t\t\t\treturn Object.keys(object).length === 0;\r\n\r\n\t\t\t} // asset\r\n\r\n\r\n\t\t\tfunction parseAsset(xml) {\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tunit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\r\n\t\t\t\t\tupAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseAssetUnit(xml) {\r\n\r\n\t\t\t\tif (xml !== undefined && xml.hasAttribute('meter') === true) {\r\n\r\n\t\t\t\t\treturn parseFloat(xml.getAttribute('meter'));\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn 1; // default 1 meter\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseAssetUpAxis(xml) {\r\n\r\n\t\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\r\n\r\n\t\t\t} // library\r\n\r\n\r\n\t\t\tfunction parseLibrary(xml, libraryName, nodeName, parser) {\r\n\r\n\t\t\t\tconst library = getElementsByTagName(xml, libraryName)[0];\r\n\r\n\t\t\t\tif (library !== undefined) {\r\n\r\n\t\t\t\t\tconst elements = getElementsByTagName(library, nodeName);\r\n\r\n\t\t\t\t\tfor (let i = 0; i < elements.length; i++) {\r\n\r\n\t\t\t\t\t\tparser(elements[i]);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildLibrary(data, builder) {\r\n\r\n\t\t\t\tfor (const name in data) {\r\n\r\n\t\t\t\t\tconst object = data[name];\r\n\t\t\t\t\tobject.build = builder(data[name]);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} // get\r\n\r\n\r\n\t\t\tfunction getBuild(data, builder) {\r\n\r\n\t\t\t\tif (data.build !== undefined) return data.build;\r\n\t\t\t\tdata.build = builder(data);\r\n\t\t\t\treturn data.build;\r\n\r\n\t\t\t} // animation\r\n\r\n\r\n\t\t\tfunction parseAnimation(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tsources: {},\r\n\t\t\t\t\tsamplers: {},\r\n\t\t\t\t\tchannels: {}\r\n\t\t\t\t};\r\n\t\t\t\tlet hasChildren = false;\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\t\t\t\t\tlet id;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'source':\r\n\t\t\t\t\t\t\tid = child.getAttribute('id');\r\n\t\t\t\t\t\t\tdata.sources[id] = parseSource(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'sampler':\r\n\t\t\t\t\t\t\tid = child.getAttribute('id');\r\n\t\t\t\t\t\t\tdata.samplers[id] = parseAnimationSampler(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'channel':\r\n\t\t\t\t\t\t\tid = child.getAttribute('target');\r\n\t\t\t\t\t\t\tdata.channels[id] = parseAnimationChannel(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'animation':\r\n\t\t\t\t\t\t\t// hierarchy of related animations\r\n\t\t\t\t\t\t\tparseAnimation(child);\r\n\t\t\t\t\t\t\thasChildren = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.log(child);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (hasChildren === false) {\r\n\r\n\t\t\t\t\t// since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\r\n\t\t\t\t\tlibrary.animations[xml.getAttribute('id') || THREE.MathUtils.generateUUID()] = data;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseAnimationSampler(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tinputs: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'input':\r\n\t\t\t\t\t\t\tconst id = parseId(child.getAttribute('source'));\r\n\t\t\t\t\t\t\tconst semantic = child.getAttribute('semantic');\r\n\t\t\t\t\t\t\tdata.inputs[semantic] = id;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseAnimationChannel(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\t\t\t\tconst target = xml.getAttribute('target'); // parsing SID Addressing Syntax\r\n\r\n\t\t\t\tlet parts = target.split('/');\r\n\t\t\t\tconst id = parts.shift();\r\n\t\t\t\tlet sid = parts.shift(); // check selection syntax\r\n\r\n\t\t\t\tconst arraySyntax = sid.indexOf('(') !== - 1;\r\n\t\t\t\tconst memberSyntax = sid.indexOf('.') !== - 1;\r\n\r\n\t\t\t\tif (memberSyntax) {\r\n\r\n\t\t\t\t\t//  member selection access\r\n\t\t\t\t\tparts = sid.split('.');\r\n\t\t\t\t\tsid = parts.shift();\r\n\t\t\t\t\tdata.member = parts.shift();\r\n\r\n\t\t\t\t} else if (arraySyntax) {\r\n\r\n\t\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\r\n\t\t\t\t\tconst indices = sid.split('(');\r\n\t\t\t\t\tsid = indices.shift();\r\n\r\n\t\t\t\t\tfor (let i = 0; i < indices.length; i++) {\r\n\r\n\t\t\t\t\t\tindices[i] = parseInt(indices[i].replace(/\\)/, ''));\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdata.indices = indices;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.id = id;\r\n\t\t\t\tdata.sid = sid;\r\n\t\t\t\tdata.arraySyntax = arraySyntax;\r\n\t\t\t\tdata.memberSyntax = memberSyntax;\r\n\t\t\t\tdata.sampler = parseId(xml.getAttribute('source'));\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildAnimation(data) {\r\n\r\n\t\t\t\tconst tracks = [];\r\n\t\t\t\tconst channels = data.channels;\r\n\t\t\t\tconst samplers = data.samplers;\r\n\t\t\t\tconst sources = data.sources;\r\n\r\n\t\t\t\tfor (const target in channels) {\r\n\r\n\t\t\t\t\tif (channels.hasOwnProperty(target)) {\r\n\r\n\t\t\t\t\t\tconst channel = channels[target];\r\n\t\t\t\t\t\tconst sampler = samplers[channel.sampler];\r\n\t\t\t\t\t\tconst inputId = sampler.inputs.INPUT;\r\n\t\t\t\t\t\tconst outputId = sampler.inputs.OUTPUT;\r\n\t\t\t\t\t\tconst inputSource = sources[inputId];\r\n\t\t\t\t\t\tconst outputSource = sources[outputId];\r\n\t\t\t\t\t\tconst animation = buildAnimationChannel(channel, inputSource, outputSource);\r\n\t\t\t\t\t\tcreateKeyframeTracks(animation, tracks);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn tracks;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getAnimation(id) {\r\n\r\n\t\t\t\treturn getBuild(library.animations[id], buildAnimation);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildAnimationChannel(channel, inputSource, outputSource) {\r\n\r\n\t\t\t\tconst node = library.nodes[channel.id];\r\n\t\t\t\tconst object3D = getNode(node.id);\r\n\t\t\t\tconst transform = node.transforms[channel.sid];\r\n\t\t\t\tconst defaultMatrix = node.matrix.clone().transpose();\r\n\t\t\t\tlet time, stride;\r\n\t\t\t\tlet i, il, j, jl;\r\n\t\t\t\tconst data = {}; // the collada spec allows the animation of data in various ways.\r\n\t\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\r\n\r\n\t\t\t\tswitch (transform) {\r\n\r\n\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\t\tfor (i = 0, il = inputSource.array.length; i < il; i++) {\r\n\r\n\t\t\t\t\t\t\ttime = inputSource.array[i];\r\n\t\t\t\t\t\t\tstride = i * outputSource.stride;\r\n\t\t\t\t\t\t\tif (data[time] === undefined) data[time] = {};\r\n\r\n\t\t\t\t\t\t\tif (channel.arraySyntax === true) {\r\n\r\n\t\t\t\t\t\t\t\tconst value = outputSource.array[stride];\r\n\t\t\t\t\t\t\t\tconst index = channel.indices[0] + 4 * channel.indices[1];\r\n\t\t\t\t\t\t\t\tdata[time][index] = value;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tfor (j = 0, jl = outputSource.stride; j < jl; j++) {\r\n\r\n\t\t\t\t\t\t\t\t\tdata[time][j] = outputSource.array[stride + j];\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'scale':\r\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst keyframes = prepareAnimationData(data, defaultMatrix);\r\n\t\t\t\tconst animation = {\r\n\t\t\t\t\tname: object3D.uuid,\r\n\t\t\t\t\tkeyframes: keyframes\r\n\t\t\t\t};\r\n\t\t\t\treturn animation;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction prepareAnimationData(data, defaultMatrix) {\r\n\r\n\t\t\t\tconst keyframes = []; // transfer data into a sortable array\r\n\r\n\t\t\t\tfor (const time in data) {\r\n\r\n\t\t\t\t\tkeyframes.push({\r\n\t\t\t\t\t\ttime: parseFloat(time),\r\n\t\t\t\t\t\tvalue: data[time]\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t} // ensure keyframes are sorted by time\r\n\r\n\r\n\t\t\t\tkeyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\r\n\r\n\t\t\t\tfor (let i = 0; i < 16; i++) {\r\n\r\n\t\t\t\t\ttransformAnimationData(keyframes, i, defaultMatrix.elements[i]);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn keyframes; // array sort function\r\n\r\n\t\t\t\tfunction ascending(a, b) {\r\n\r\n\t\t\t\t\treturn a.time - b.time;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst position = new THREE.Vector3();\r\n\t\t\tconst scale = new THREE.Vector3();\r\n\t\t\tconst quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tfunction createKeyframeTracks(animation, tracks) {\r\n\r\n\t\t\t\tconst keyframes = animation.keyframes;\r\n\t\t\t\tconst name = animation.name;\r\n\t\t\t\tconst times = [];\r\n\t\t\t\tconst positionData = [];\r\n\t\t\t\tconst quaternionData = [];\r\n\t\t\t\tconst scaleData = [];\r\n\r\n\t\t\t\tfor (let i = 0, l = keyframes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst keyframe = keyframes[i];\r\n\t\t\t\t\tconst time = keyframe.time;\r\n\t\t\t\t\tconst value = keyframe.value;\r\n\t\t\t\t\tmatrix.fromArray(value).transpose();\r\n\t\t\t\t\tmatrix.decompose(position, quaternion, scale);\r\n\t\t\t\t\ttimes.push(time);\r\n\t\t\t\t\tpositionData.push(position.x, position.y, position.z);\r\n\t\t\t\t\tquaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\r\n\t\t\t\t\tscaleData.push(scale.x, scale.y, scale.z);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (positionData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.position', times, positionData));\r\n\t\t\t\tif (quaternionData.length > 0) tracks.push(new THREE.QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\r\n\t\t\t\tif (scaleData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.scale', times, scaleData));\r\n\t\t\t\treturn tracks;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction transformAnimationData(keyframes, property, defaultValue) {\r\n\r\n\t\t\t\tlet keyframe;\r\n\t\t\t\tlet empty = true;\r\n\t\t\t\tlet i, l; // check, if values of a property are missing in our keyframes\r\n\r\n\t\t\t\tfor (i = 0, l = keyframes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tkeyframe = keyframes[i];\r\n\r\n\t\t\t\t\tif (keyframe.value[property] === undefined) {\r\n\r\n\t\t\t\t\t\tkeyframe.value[property] = null; // mark as missing\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tempty = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (empty === true) {\r\n\r\n\t\t\t\t\t// no values at all, so we set a default value\r\n\t\t\t\t\tfor (i = 0, l = keyframes.length; i < l; i++) {\r\n\r\n\t\t\t\t\t\tkeyframe = keyframes[i];\r\n\t\t\t\t\t\tkeyframe.value[property] = defaultValue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// filling gaps\r\n\t\t\t\t\tcreateMissingKeyframes(keyframes, property);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction createMissingKeyframes(keyframes, property) {\r\n\r\n\t\t\t\tlet prev, next;\r\n\r\n\t\t\t\tfor (let i = 0, l = keyframes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst keyframe = keyframes[i];\r\n\r\n\t\t\t\t\tif (keyframe.value[property] === null) {\r\n\r\n\t\t\t\t\t\tprev = getPrev(keyframes, i, property);\r\n\t\t\t\t\t\tnext = getNext(keyframes, i, property);\r\n\r\n\t\t\t\t\t\tif (prev === null) {\r\n\r\n\t\t\t\t\t\t\tkeyframe.value[property] = next.value[property];\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (next === null) {\r\n\r\n\t\t\t\t\t\t\tkeyframe.value[property] = prev.value[property];\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tinterpolate(keyframe, prev, next, property);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getPrev(keyframes, i, property) {\r\n\r\n\t\t\t\twhile (i >= 0) {\r\n\r\n\t\t\t\t\tconst keyframe = keyframes[i];\r\n\t\t\t\t\tif (keyframe.value[property] !== null) return keyframe;\r\n\t\t\t\t\ti--;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getNext(keyframes, i, property) {\r\n\r\n\t\t\t\twhile (i < keyframes.length) {\r\n\r\n\t\t\t\t\tconst keyframe = keyframes[i];\r\n\t\t\t\t\tif (keyframe.value[property] !== null) return keyframe;\r\n\t\t\t\t\ti++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction interpolate(key, prev, next, property) {\r\n\r\n\t\t\t\tif (next.time - prev.time === 0) {\r\n\r\n\t\t\t\t\tkey.value[property] = prev.value[property];\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\r\n\r\n\t\t\t} // animation clips\r\n\r\n\r\n\t\t\tfunction parseAnimationClip(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tname: xml.getAttribute('id') || 'default',\r\n\t\t\t\t\tstart: parseFloat(xml.getAttribute('start') || 0),\r\n\t\t\t\t\tend: parseFloat(xml.getAttribute('end') || 0),\r\n\t\t\t\t\tanimations: []\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'instance_animation':\r\n\t\t\t\t\t\t\tdata.animations.push(parseId(child.getAttribute('url')));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.clips[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildAnimationClip(data) {\r\n\r\n\t\t\t\tconst tracks = [];\r\n\t\t\t\tconst name = data.name;\r\n\t\t\t\tconst duration = data.end - data.start || - 1;\r\n\t\t\t\tconst animations = data.animations;\r\n\r\n\t\t\t\tfor (let i = 0, il = animations.length; i < il; i++) {\r\n\r\n\t\t\t\t\tconst animationTracks = getAnimation(animations[i]);\r\n\r\n\t\t\t\t\tfor (let j = 0, jl = animationTracks.length; j < jl; j++) {\r\n\r\n\t\t\t\t\t\ttracks.push(animationTracks[j]);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new THREE.AnimationClip(name, duration, tracks);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getAnimationClip(id) {\r\n\r\n\t\t\t\treturn getBuild(library.clips[id], buildAnimationClip);\r\n\r\n\t\t\t} // controller\r\n\r\n\r\n\t\t\tfunction parseController(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'skin':\r\n\t\t\t\t\t\t\t// there is exactly one skin per controller\r\n\t\t\t\t\t\t\tdata.id = parseId(child.getAttribute('source'));\r\n\t\t\t\t\t\t\tdata.skin = parseSkin(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'morph':\r\n\t\t\t\t\t\t\tdata.id = parseId(child.getAttribute('source'));\r\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.controllers[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseSkin(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tsources: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'bind_shape_matrix':\r\n\t\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'source':\r\n\t\t\t\t\t\t\tconst id = child.getAttribute('id');\r\n\t\t\t\t\t\t\tdata.sources[id] = parseSource(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'joints':\r\n\t\t\t\t\t\t\tdata.joints = parseJoints(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'vertex_weights':\r\n\t\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseJoints(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tinputs: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'input':\r\n\t\t\t\t\t\t\tconst semantic = child.getAttribute('semantic');\r\n\t\t\t\t\t\t\tconst id = parseId(child.getAttribute('source'));\r\n\t\t\t\t\t\t\tdata.inputs[semantic] = id;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseVertexWeights(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tinputs: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'input':\r\n\t\t\t\t\t\t\tconst semantic = child.getAttribute('semantic');\r\n\t\t\t\t\t\t\tconst id = parseId(child.getAttribute('source'));\r\n\t\t\t\t\t\t\tconst offset = parseInt(child.getAttribute('offset'));\r\n\t\t\t\t\t\t\tdata.inputs[semantic] = {\r\n\t\t\t\t\t\t\t\tid: id,\r\n\t\t\t\t\t\t\t\toffset: offset\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'vcount':\r\n\t\t\t\t\t\t\tdata.vcount = parseInts(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\t\tdata.v = parseInts(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildController(data) {\r\n\r\n\t\t\t\tconst build = {\r\n\t\t\t\t\tid: data.id\r\n\t\t\t\t};\r\n\t\t\t\tconst geometry = library.geometries[build.id];\r\n\r\n\t\t\t\tif (data.skin !== undefined) {\r\n\r\n\t\t\t\t\tbuild.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\r\n\r\n\t\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\r\n\t\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn build;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildSkin(data) {\r\n\r\n\t\t\t\tconst BONE_LIMIT = 4;\r\n\t\t\t\tconst build = {\r\n\t\t\t\t\tjoints: [],\r\n\t\t\t\t\t// this must be an array to preserve the joint order\r\n\t\t\t\t\tindices: {\r\n\t\t\t\t\t\tarray: [],\r\n\t\t\t\t\t\tstride: BONE_LIMIT\r\n\t\t\t\t\t},\r\n\t\t\t\t\tweights: {\r\n\t\t\t\t\t\tarray: [],\r\n\t\t\t\t\t\tstride: BONE_LIMIT\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tconst sources = data.sources;\r\n\t\t\t\tconst vertexWeights = data.vertexWeights;\r\n\t\t\t\tconst vcount = vertexWeights.vcount;\r\n\t\t\t\tconst v = vertexWeights.v;\r\n\t\t\t\tconst jointOffset = vertexWeights.inputs.JOINT.offset;\r\n\t\t\t\tconst weightOffset = vertexWeights.inputs.WEIGHT.offset;\r\n\t\t\t\tconst jointSource = data.sources[data.joints.inputs.JOINT];\r\n\t\t\t\tconst inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\r\n\t\t\t\tconst weights = sources[vertexWeights.inputs.WEIGHT.id].array;\r\n\t\t\t\tlet stride = 0;\r\n\t\t\t\tlet i, j, l; // procces skin data for each vertex\r\n\r\n\t\t\t\tfor (i = 0, l = vcount.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\r\n\r\n\t\t\t\t\tconst vertexSkinData = [];\r\n\r\n\t\t\t\t\tfor (j = 0; j < jointCount; j++) {\r\n\r\n\t\t\t\t\t\tconst skinIndex = v[stride + jointOffset];\r\n\t\t\t\t\t\tconst weightId = v[stride + weightOffset];\r\n\t\t\t\t\t\tconst skinWeight = weights[weightId];\r\n\t\t\t\t\t\tvertexSkinData.push({\r\n\t\t\t\t\t\t\tindex: skinIndex,\r\n\t\t\t\t\t\t\tweight: skinWeight\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tstride += 2;\r\n\r\n\t\t\t\t\t} // we sort the joints in descending order based on the weights.\r\n\t\t\t\t\t// this ensures, we only procced the most important joints of the vertex\r\n\r\n\r\n\t\t\t\t\tvertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\r\n\t\t\t\t\t// the order of the skin data matches the order of vertices\r\n\r\n\t\t\t\t\tfor (j = 0; j < BONE_LIMIT; j++) {\r\n\r\n\t\t\t\t\t\tconst d = vertexSkinData[j];\r\n\r\n\t\t\t\t\t\tif (d !== undefined) {\r\n\r\n\t\t\t\t\t\t\tbuild.indices.array.push(d.index);\r\n\t\t\t\t\t\t\tbuild.weights.array.push(d.weight);\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tbuild.indices.array.push(0);\r\n\t\t\t\t\t\t\tbuild.weights.array.push(0);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // setup bind matrix\r\n\r\n\r\n\t\t\t\tif (data.bindShapeMatrix) {\r\n\r\n\t\t\t\t\tbuild.bindMatrix = new THREE.Matrix4().fromArray(data.bindShapeMatrix).transpose();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbuild.bindMatrix = new THREE.Matrix4().identity();\r\n\r\n\t\t\t\t} // process bones and inverse bind matrix data\r\n\r\n\r\n\t\t\t\tfor (i = 0, l = jointSource.array.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst name = jointSource.array[i];\r\n\t\t\t\t\tconst boneInverse = new THREE.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\r\n\t\t\t\t\tbuild.joints.push({\r\n\t\t\t\t\t\tname: name,\r\n\t\t\t\t\t\tboneInverse: boneInverse\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn build; // array sort function\r\n\r\n\t\t\t\tfunction descending(a, b) {\r\n\r\n\t\t\t\t\treturn b.weight - a.weight;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getController(id) {\r\n\r\n\t\t\t\treturn getBuild(library.controllers[id], buildController);\r\n\r\n\t\t\t} // image\r\n\r\n\r\n\t\t\tfunction parseImage(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tinit_from: getElementsByTagName(xml, 'init_from')[0].textContent\r\n\t\t\t\t};\r\n\t\t\t\tlibrary.images[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildImage(data) {\r\n\r\n\t\t\t\tif (data.build !== undefined) return data.build;\r\n\t\t\t\treturn data.init_from;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getImage(id) {\r\n\r\n\t\t\t\tconst data = library.images[id];\r\n\r\n\t\t\t\tif (data !== undefined) {\r\n\r\n\t\t\t\t\treturn getBuild(data, buildImage);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t find image with ID:', id);\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} // effect\r\n\r\n\r\n\t\t\tfunction parseEffect(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'profile_COMMON':\r\n\t\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.effects[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectProfileCOMMON(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tsurfaces: {},\r\n\t\t\t\t\tsamplers: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'newparam':\r\n\t\t\t\t\t\t\tparseEffectNewparam(child, data);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'technique':\r\n\t\t\t\t\t\t\tdata.technique = parseEffectTechnique(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'extra':\r\n\t\t\t\t\t\t\tdata.extra = parseEffectExtra(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectNewparam(xml, data) {\r\n\r\n\t\t\t\tconst sid = xml.getAttribute('sid');\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'surface':\r\n\t\t\t\t\t\t\tdata.surfaces[sid] = parseEffectSurface(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'sampler2D':\r\n\t\t\t\t\t\t\tdata.samplers[sid] = parseEffectSampler(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectSurface(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'init_from':\r\n\t\t\t\t\t\t\tdata.init_from = child.textContent;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectSampler(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'source':\r\n\t\t\t\t\t\t\tdata.source = child.textContent;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectTechnique(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'constant':\r\n\t\t\t\t\t\tcase 'lambert':\r\n\t\t\t\t\t\tcase 'blinn':\r\n\t\t\t\t\t\tcase 'phong':\r\n\t\t\t\t\t\t\tdata.type = child.nodeName;\r\n\t\t\t\t\t\t\tdata.parameters = parseEffectParameters(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectParameters(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'emission':\r\n\t\t\t\t\t\tcase 'diffuse':\r\n\t\t\t\t\t\tcase 'specular':\r\n\t\t\t\t\t\tcase 'bump':\r\n\t\t\t\t\t\tcase 'ambient':\r\n\t\t\t\t\t\tcase 'shininess':\r\n\t\t\t\t\t\tcase 'transparency':\r\n\t\t\t\t\t\t\tdata[child.nodeName] = parseEffectParameter(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'transparent':\r\n\t\t\t\t\t\t\tdata[child.nodeName] = {\r\n\t\t\t\t\t\t\t\topaque: child.getAttribute('opaque'),\r\n\t\t\t\t\t\t\t\tdata: parseEffectParameter(child)\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectParameter(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'color':\r\n\t\t\t\t\t\t\tdata[child.nodeName] = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'float':\r\n\t\t\t\t\t\t\tdata[child.nodeName] = parseFloat(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'texture':\r\n\t\t\t\t\t\t\tdata[child.nodeName] = {\r\n\t\t\t\t\t\t\t\tid: child.getAttribute('texture'),\r\n\t\t\t\t\t\t\t\textra: parseEffectParameterTexture(child)\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectParameterTexture(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\ttechnique: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'extra':\r\n\t\t\t\t\t\t\tparseEffectParameterTextureExtra(child, data);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectParameterTextureExtra(xml, data) {\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'technique':\r\n\t\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique(child, data);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectParameterTextureExtraTechnique(xml, data) {\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'repeatU':\r\n\t\t\t\t\t\tcase 'repeatV':\r\n\t\t\t\t\t\tcase 'offsetU':\r\n\t\t\t\t\t\tcase 'offsetV':\r\n\t\t\t\t\t\t\tdata.technique[child.nodeName] = parseFloat(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'wrapU':\r\n\t\t\t\t\t\tcase 'wrapV':\r\n\t\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\r\n\t\t\t\t\t\t\tif (child.textContent.toUpperCase() === 'TRUE') {\r\n\r\n\t\t\t\t\t\t\t\tdata.technique[child.nodeName] = 1;\r\n\r\n\t\t\t\t\t\t\t} else if (child.textContent.toUpperCase() === 'FALSE') {\r\n\r\n\t\t\t\t\t\t\t\tdata.technique[child.nodeName] = 0;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tdata.technique[child.nodeName] = parseInt(child.textContent);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectExtra(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'technique':\r\n\t\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseEffectExtraTechnique(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'double_sided':\r\n\t\t\t\t\t\t\tdata[child.nodeName] = parseInt(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildEffect(data) {\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getEffect(id) {\r\n\r\n\t\t\t\treturn getBuild(library.effects[id], buildEffect);\r\n\r\n\t\t\t} // material\r\n\r\n\r\n\t\t\tfunction parseMaterial(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tname: xml.getAttribute('name')\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'instance_effect':\r\n\t\t\t\t\t\t\tdata.url = parseId(child.getAttribute('url'));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.materials[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getTextureLoader(image) {\r\n\r\n\t\t\t\tlet loader;\r\n\t\t\t\tlet extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\r\n\r\n\t\t\t\textension = extension.toLowerCase();\r\n\r\n\t\t\t\tswitch (extension) {\r\n\r\n\t\t\t\t\tcase 'tga':\r\n\t\t\t\t\t\tloader = tgaLoader;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tloader = textureLoader;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn loader;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildMaterial(data) {\r\n\r\n\t\t\t\tconst effect = getEffect(data.url);\r\n\t\t\t\tconst technique = effect.profile.technique;\r\n\t\t\t\tconst extra = effect.profile.extra;\r\n\t\t\t\tlet material;\r\n\r\n\t\t\t\tswitch (technique.type) {\r\n\r\n\t\t\t\t\tcase 'phong':\r\n\t\t\t\t\tcase 'blinn':\r\n\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'lambert':\r\n\t\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterial.name = data.name || '';\r\n\r\n\t\t\t\tfunction getTexture(textureObject) {\r\n\r\n\t\t\t\t\tconst sampler = effect.profile.samplers[textureObject.id];\r\n\t\t\t\t\tlet image = null; // get image\r\n\r\n\t\t\t\t\tif (sampler !== undefined) {\r\n\r\n\t\t\t\t\t\tconst surface = effect.profile.surfaces[sampler.source];\r\n\t\t\t\t\t\timage = getImage(surface.init_from);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\r\n\t\t\t\t\t\timage = getImage(textureObject.id);\r\n\r\n\t\t\t\t\t} // create texture if image is avaiable\r\n\r\n\r\n\t\t\t\t\tif (image !== null) {\r\n\r\n\t\t\t\t\t\tconst loader = getTextureLoader(image);\r\n\r\n\t\t\t\t\t\tif (loader !== undefined) {\r\n\r\n\t\t\t\t\t\t\tconst texture = loader.load(image);\r\n\t\t\t\t\t\t\tconst extra = textureObject.extra;\r\n\r\n\t\t\t\t\t\t\tif (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\r\n\r\n\t\t\t\t\t\t\t\tconst technique = extra.technique;\r\n\t\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\r\n\t\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\r\n\t\t\t\t\t\t\t\ttexture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\r\n\t\t\t\t\t\t\t\ttexture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn texture;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: THREE.Loader for texture %s not found.', image);\r\n\t\t\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id);\r\n\t\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst parameters = technique.parameters;\r\n\r\n\t\t\t\tfor (const key in parameters) {\r\n\r\n\t\t\t\t\tconst parameter = parameters[key];\r\n\r\n\t\t\t\t\tswitch (key) {\r\n\r\n\t\t\t\t\t\tcase 'diffuse':\r\n\t\t\t\t\t\t\tif (parameter.color) material.color.fromArray(parameter.color);\r\n\t\t\t\t\t\t\tif (parameter.texture) material.map = getTexture(parameter.texture);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'specular':\r\n\t\t\t\t\t\t\tif (parameter.color && material.specular) material.specular.fromArray(parameter.color);\r\n\t\t\t\t\t\t\tif (parameter.texture) material.specularMap = getTexture(parameter.texture);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'bump':\r\n\t\t\t\t\t\t\tif (parameter.texture) material.normalMap = getTexture(parameter.texture);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'ambient':\r\n\t\t\t\t\t\t\tif (parameter.texture) material.lightMap = getTexture(parameter.texture);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'shininess':\r\n\t\t\t\t\t\t\tif (parameter.float && material.shininess) material.shininess = parameter.float;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'emission':\r\n\t\t\t\t\t\t\tif (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\r\n\t\t\t\t\t\t\tif (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} //\r\n\r\n\r\n\t\t\t\tlet transparent = parameters['transparent'];\r\n\t\t\t\tlet transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\r\n\r\n\t\t\t\tif (transparency === undefined && transparent) {\r\n\r\n\t\t\t\t\ttransparency = {\r\n\t\t\t\t\t\tfloat: 1\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t} // <transparent> does not exist but <transparency>\r\n\r\n\r\n\t\t\t\tif (transparent === undefined && transparency) {\r\n\r\n\t\t\t\t\ttransparent = {\r\n\t\t\t\t\t\topaque: 'A_ONE',\r\n\t\t\t\t\t\tdata: {\r\n\t\t\t\t\t\t\tcolor: [1, 1, 1, 1]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (transparent && transparency) {\r\n\r\n\t\t\t\t\t// handle case if a texture exists but no color\r\n\t\t\t\t\tif (transparent.data.texture) {\r\n\r\n\t\t\t\t\t\t// we do not set an alpha map (see #13792)\r\n\t\t\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconst color = transparent.data.color;\r\n\r\n\t\t\t\t\t\tswitch (transparent.opaque) {\r\n\r\n\t\t\t\t\t\t\tcase 'A_ONE':\r\n\t\t\t\t\t\t\t\tmaterial.opacity = color[3] * transparency.float;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'RGB_ZERO':\r\n\t\t\t\t\t\t\t\tmaterial.opacity = 1 - color[0] * transparency.float;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'A_ZERO':\r\n\t\t\t\t\t\t\t\tmaterial.opacity = 1 - color[3] * transparency.float;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'RGB_ONE':\r\n\t\t\t\t\t\t\t\tmaterial.opacity = color[0] * transparency.float;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (material.opacity < 1) material.transparent = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} //\r\n\r\n\r\n\t\t\t\tif (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\r\n\r\n\t\t\t\t\tmaterial.side = THREE.DoubleSide;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn material;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getMaterial(id) {\r\n\r\n\t\t\t\treturn getBuild(library.materials[id], buildMaterial);\r\n\r\n\t\t\t} // camera\r\n\r\n\r\n\t\t\tfunction parseCamera(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tname: xml.getAttribute('name')\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'optics':\r\n\t\t\t\t\t\t\tdata.optics = parseCameraOptics(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.cameras[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseCameraOptics(xml) {\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'technique_common':\r\n\t\t\t\t\t\t\treturn parseCameraTechnique(child);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn {};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseCameraTechnique(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'perspective':\r\n\t\t\t\t\t\tcase 'orthographic':\r\n\t\t\t\t\t\t\tdata.technique = child.nodeName;\r\n\t\t\t\t\t\t\tdata.parameters = parseCameraParameters(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseCameraParameters(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'xfov':\r\n\t\t\t\t\t\tcase 'yfov':\r\n\t\t\t\t\t\tcase 'xmag':\r\n\t\t\t\t\t\tcase 'ymag':\r\n\t\t\t\t\t\tcase 'znear':\r\n\t\t\t\t\t\tcase 'zfar':\r\n\t\t\t\t\t\tcase 'aspect_ratio':\r\n\t\t\t\t\t\t\tdata[child.nodeName] = parseFloat(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildCamera(data) {\r\n\r\n\t\t\t\tlet camera;\r\n\r\n\t\t\t\tswitch (data.optics.technique) {\r\n\r\n\t\t\t\t\tcase 'perspective':\r\n\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'orthographic':\r\n\t\t\t\t\t\tlet ymag = data.optics.parameters.ymag;\r\n\t\t\t\t\t\tlet xmag = data.optics.parameters.xmag;\r\n\t\t\t\t\t\tconst aspectRatio = data.optics.parameters.aspect_ratio;\r\n\t\t\t\t\t\txmag = xmag === undefined ? ymag * aspectRatio : xmag;\r\n\t\t\t\t\t\tymag = ymag === undefined ? xmag / aspectRatio : ymag;\r\n\t\t\t\t\t\txmag *= 0.5;\r\n\t\t\t\t\t\tymag *= 0.5;\r\n\t\t\t\t\t\tcamera = new THREE.OrthographicCamera(- xmag, xmag, ymag, - ymag, // left, right, top, bottom\r\n\t\t\t\t\t\t\tdata.optics.parameters.znear, data.optics.parameters.zfar);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcamera.name = data.name || '';\r\n\t\t\t\treturn camera;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getCamera(id) {\r\n\r\n\t\t\t\tconst data = library.cameras[id];\r\n\r\n\t\t\t\tif (data !== undefined) {\r\n\r\n\t\t\t\t\treturn getBuild(data, buildCamera);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t find camera with ID:', id);\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} // light\r\n\r\n\r\n\t\t\tfunction parseLight(xml) {\r\n\r\n\t\t\t\tlet data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'technique_common':\r\n\t\t\t\t\t\t\tdata = parseLightTechnique(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.lights[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseLightTechnique(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'directional':\r\n\t\t\t\t\t\tcase 'point':\r\n\t\t\t\t\t\tcase 'spot':\r\n\t\t\t\t\t\tcase 'ambient':\r\n\t\t\t\t\t\t\tdata.technique = child.nodeName;\r\n\t\t\t\t\t\t\tdata.parameters = parseLightParameters(child);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseLightParameters(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'color':\r\n\t\t\t\t\t\t\tconst array = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tdata.color = new THREE.Color().fromArray(array);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'falloff_angle':\r\n\t\t\t\t\t\t\tdata.falloffAngle = parseFloat(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'quadratic_attenuation':\r\n\t\t\t\t\t\t\tconst f = parseFloat(child.textContent);\r\n\t\t\t\t\t\t\tdata.distance = f ? Math.sqrt(1 / f) : 0;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildLight(data) {\r\n\r\n\t\t\t\tlet light;\r\n\r\n\t\t\t\tswitch (data.technique) {\r\n\r\n\t\t\t\t\tcase 'directional':\r\n\t\t\t\t\t\tlight = new THREE.DirectionalLight();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'point':\r\n\t\t\t\t\t\tlight = new THREE.PointLight();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'spot':\r\n\t\t\t\t\t\tlight = new THREE.SpotLight();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'ambient':\r\n\t\t\t\t\t\tlight = new THREE.AmbientLight();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (data.parameters.color) light.color.copy(data.parameters.color);\r\n\t\t\t\tif (data.parameters.distance) light.distance = data.parameters.distance;\r\n\t\t\t\treturn light;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getLight(id) {\r\n\r\n\t\t\t\tconst data = library.lights[id];\r\n\r\n\t\t\t\tif (data !== undefined) {\r\n\r\n\t\t\t\t\treturn getBuild(data, buildLight);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t find light with ID:', id);\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} // geometry\r\n\r\n\r\n\t\t\tfunction parseGeometry(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tname: xml.getAttribute('name'),\r\n\t\t\t\t\tsources: {},\r\n\t\t\t\t\tvertices: {},\r\n\t\t\t\t\tprimitives: []\r\n\t\t\t\t};\r\n\t\t\t\tconst mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\r\n\r\n\t\t\t\tif (mesh === undefined) return;\r\n\r\n\t\t\t\tfor (let i = 0; i < mesh.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = mesh.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\t\t\t\t\tconst id = child.getAttribute('id');\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'source':\r\n\t\t\t\t\t\t\tdata.sources[id] = parseSource(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'vertices':\r\n\t\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\r\n\t\t\t\t\t\t\tdata.vertices = parseGeometryVertices(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'polygons':\r\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'lines':\r\n\t\t\t\t\t\tcase 'linestrips':\r\n\t\t\t\t\t\tcase 'polylist':\r\n\t\t\t\t\t\tcase 'triangles':\r\n\t\t\t\t\t\t\tdata.primitives.push(parseGeometryPrimitive(child));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.log(child);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.geometries[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseSource(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tarray: [],\r\n\t\t\t\t\tstride: 3\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'float_array':\r\n\t\t\t\t\t\t\tdata.array = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'Name_array':\r\n\t\t\t\t\t\t\tdata.array = parseStrings(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'technique_common':\r\n\t\t\t\t\t\t\tconst accessor = getElementsByTagName(child, 'accessor')[0];\r\n\r\n\t\t\t\t\t\t\tif (accessor !== undefined) {\r\n\r\n\t\t\t\t\t\t\t\tdata.stride = parseInt(accessor.getAttribute('stride'));\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseGeometryVertices(xml) {\r\n\r\n\t\t\t\tconst data = {};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\t\t\t\t\tdata[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseGeometryPrimitive(xml) {\r\n\r\n\t\t\t\tconst primitive = {\r\n\t\t\t\t\ttype: xml.nodeName,\r\n\t\t\t\t\tmaterial: xml.getAttribute('material'),\r\n\t\t\t\t\tcount: parseInt(xml.getAttribute('count')),\r\n\t\t\t\t\tinputs: {},\r\n\t\t\t\t\tstride: 0,\r\n\t\t\t\t\thasUV: false\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0, l = xml.childNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'input':\r\n\t\t\t\t\t\t\tconst id = parseId(child.getAttribute('source'));\r\n\t\t\t\t\t\t\tconst semantic = child.getAttribute('semantic');\r\n\t\t\t\t\t\t\tconst offset = parseInt(child.getAttribute('offset'));\r\n\t\t\t\t\t\t\tconst set = parseInt(child.getAttribute('set'));\r\n\t\t\t\t\t\t\tconst inputname = set > 0 ? semantic + set : semantic;\r\n\t\t\t\t\t\t\tprimitive.inputs[inputname] = {\r\n\t\t\t\t\t\t\t\tid: id,\r\n\t\t\t\t\t\t\t\toffset: offset\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tprimitive.stride = Math.max(primitive.stride, offset + 1);\r\n\t\t\t\t\t\t\tif (semantic === 'TEXCOORD') primitive.hasUV = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'vcount':\r\n\t\t\t\t\t\t\tprimitive.vcount = parseInts(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'p':\r\n\t\t\t\t\t\t\tprimitive.p = parseInts(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn primitive;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction groupPrimitives(primitives) {\r\n\r\n\t\t\t\tconst build = {};\r\n\r\n\t\t\t\tfor (let i = 0; i < primitives.length; i++) {\r\n\r\n\t\t\t\t\tconst primitive = primitives[i];\r\n\t\t\t\t\tif (build[primitive.type] === undefined) build[primitive.type] = [];\r\n\t\t\t\t\tbuild[primitive.type].push(primitive);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn build;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction checkUVCoordinates(primitives) {\r\n\r\n\t\t\t\tlet count = 0;\r\n\r\n\t\t\t\tfor (let i = 0, l = primitives.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst primitive = primitives[i];\r\n\r\n\t\t\t\t\tif (primitive.hasUV === true) {\r\n\r\n\t\t\t\t\t\tcount++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (count > 0 && count < primitives.length) {\r\n\r\n\t\t\t\t\tprimitives.uvsNeedsFix = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildGeometry(data) {\r\n\r\n\t\t\t\tconst build = {};\r\n\t\t\t\tconst sources = data.sources;\r\n\t\t\t\tconst vertices = data.vertices;\r\n\t\t\t\tconst primitives = data.primitives;\r\n\t\t\t\tif (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\r\n\t\t\t\t// first, we group all primitives by their type\r\n\r\n\t\t\t\tconst groupedPrimitives = groupPrimitives(primitives);\r\n\r\n\t\t\t\tfor (const type in groupedPrimitives) {\r\n\r\n\t\t\t\t\tconst primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\r\n\r\n\t\t\t\t\tcheckUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\r\n\r\n\t\t\t\t\tbuild[type] = buildGeometryType(primitiveType, sources, vertices);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn build;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildGeometryType(primitives, sources, vertices) {\r\n\r\n\t\t\t\tconst build = {};\r\n\t\t\t\tconst position = {\r\n\t\t\t\t\tarray: [],\r\n\t\t\t\t\tstride: 0\r\n\t\t\t\t};\r\n\t\t\t\tconst normal = {\r\n\t\t\t\t\tarray: [],\r\n\t\t\t\t\tstride: 0\r\n\t\t\t\t};\r\n\t\t\t\tconst uv = {\r\n\t\t\t\t\tarray: [],\r\n\t\t\t\t\tstride: 0\r\n\t\t\t\t};\r\n\t\t\t\tconst uv2 = {\r\n\t\t\t\t\tarray: [],\r\n\t\t\t\t\tstride: 0\r\n\t\t\t\t};\r\n\t\t\t\tconst color = {\r\n\t\t\t\t\tarray: [],\r\n\t\t\t\t\tstride: 0\r\n\t\t\t\t};\r\n\t\t\t\tconst skinIndex = {\r\n\t\t\t\t\tarray: [],\r\n\t\t\t\t\tstride: 4\r\n\t\t\t\t};\r\n\t\t\t\tconst skinWeight = {\r\n\t\t\t\t\tarray: [],\r\n\t\t\t\t\tstride: 4\r\n\t\t\t\t};\r\n\t\t\t\tconst geometry = new THREE.BufferGeometry();\r\n\t\t\t\tconst materialKeys = [];\r\n\t\t\t\tlet start = 0;\r\n\r\n\t\t\t\tfor (let p = 0; p < primitives.length; p++) {\r\n\r\n\t\t\t\t\tconst primitive = primitives[p];\r\n\t\t\t\t\tconst inputs = primitive.inputs; // groups\r\n\r\n\t\t\t\t\tlet count = 0;\r\n\r\n\t\t\t\t\tswitch (primitive.type) {\r\n\r\n\t\t\t\t\t\tcase 'lines':\r\n\t\t\t\t\t\tcase 'linestrips':\r\n\t\t\t\t\t\t\tcount = primitive.count * 2;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'triangles':\r\n\t\t\t\t\t\t\tcount = primitive.count * 3;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'polylist':\r\n\t\t\t\t\t\t\tfor (let g = 0; g < primitive.count; g++) {\r\n\r\n\t\t\t\t\t\t\t\tconst vc = primitive.vcount[g];\r\n\r\n\t\t\t\t\t\t\t\tswitch (vc) {\r\n\r\n\t\t\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\r\n\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\r\n\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t\tcount += (vc - 2) * 3; // polylist with more than four vertices\r\n\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.addGroup(start, count, p);\r\n\t\t\t\t\tstart += count; // material\r\n\r\n\t\t\t\t\tif (primitive.material) {\r\n\r\n\t\t\t\t\t\tmaterialKeys.push(primitive.material);\r\n\r\n\t\t\t\t\t} // geometry data\r\n\r\n\r\n\t\t\t\t\tfor (const name in inputs) {\r\n\r\n\t\t\t\t\t\tconst input = inputs[name];\r\n\r\n\t\t\t\t\t\tswitch (name) {\r\n\r\n\t\t\t\t\t\t\tcase 'VERTEX':\r\n\t\t\t\t\t\t\t\tfor (const key in vertices) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst id = vertices[key];\r\n\r\n\t\t\t\t\t\t\t\t\tswitch (key) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'POSITION':\r\n\t\t\t\t\t\t\t\t\t\t\tconst prevLength = position.array.length;\r\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, position.array);\r\n\t\t\t\t\t\t\t\t\t\t\tposition.stride = sources[id].stride;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif (sources.skinWeights && sources.skinIndices) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t} // see #3803\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst count = (position.array.length - prevLength) / position.stride;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < count; i++) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push(0, 0);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'NORMAL':\r\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, normal.array);\r\n\t\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[id].stride;\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'COLOR':\r\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, color.array);\r\n\t\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[id].stride;\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\r\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, uv.array);\r\n\t\t\t\t\t\t\t\t\t\t\tuv.stride = sources[id].stride;\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\r\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, uv2.array);\r\n\t\t\t\t\t\t\t\t\t\t\tuv.stride = sources[id].stride;\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'NORMAL':\r\n\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[input.id], input.offset, normal.array);\r\n\t\t\t\t\t\t\t\tnormal.stride = sources[input.id].stride;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'COLOR':\r\n\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[input.id], input.offset, color.array);\r\n\t\t\t\t\t\t\t\tcolor.stride = sources[input.id].stride;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'TEXCOORD':\r\n\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[input.id], input.offset, uv.array);\r\n\t\t\t\t\t\t\t\tuv.stride = sources[input.id].stride;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'TEXCOORD1':\r\n\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\r\n\t\t\t\t\t\t\t\tuv2.stride = sources[input.id].stride;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // build geometry\r\n\r\n\r\n\t\t\t\tif (position.array.length > 0) geometry.setAttribute('position', new THREE.Float32BufferAttribute(position.array, position.stride));\r\n\t\t\t\tif (normal.array.length > 0) geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normal.array, normal.stride));\r\n\t\t\t\tif (color.array.length > 0) geometry.setAttribute('color', new THREE.Float32BufferAttribute(color.array, color.stride));\r\n\t\t\t\tif (uv.array.length > 0) geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uv.array, uv.stride));\r\n\t\t\t\tif (uv2.array.length > 0) geometry.setAttribute('uv2', new THREE.Float32BufferAttribute(uv2.array, uv2.stride));\r\n\t\t\t\tif (skinIndex.array.length > 0) geometry.setAttribute('skinIndex', new THREE.Float32BufferAttribute(skinIndex.array, skinIndex.stride));\r\n\t\t\t\tif (skinWeight.array.length > 0) geometry.setAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeight.array, skinWeight.stride));\r\n\t\t\t\tbuild.data = geometry;\r\n\t\t\t\tbuild.type = primitives[0].type;\r\n\t\t\t\tbuild.materialKeys = materialKeys;\r\n\t\t\t\treturn build;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildGeometryData(primitive, source, offset, array) {\r\n\r\n\t\t\t\tconst indices = primitive.p;\r\n\t\t\t\tconst stride = primitive.stride;\r\n\t\t\t\tconst vcount = primitive.vcount;\r\n\r\n\t\t\t\tfunction pushVector(i) {\r\n\r\n\t\t\t\t\tlet index = indices[i + offset] * sourceStride;\r\n\t\t\t\t\tconst length = index + sourceStride;\r\n\r\n\t\t\t\t\tfor (; index < length; index++) {\r\n\r\n\t\t\t\t\t\tarray.push(sourceArray[index]);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst sourceArray = source.array;\r\n\t\t\t\tconst sourceStride = source.stride;\r\n\r\n\t\t\t\tif (primitive.vcount !== undefined) {\r\n\r\n\t\t\t\t\tlet index = 0;\r\n\r\n\t\t\t\t\tfor (let i = 0, l = vcount.length; i < l; i++) {\r\n\r\n\t\t\t\t\t\tconst count = vcount[i];\r\n\r\n\t\t\t\t\t\tif (count === 4) {\r\n\r\n\t\t\t\t\t\t\tconst a = index + stride * 0;\r\n\t\t\t\t\t\t\tconst b = index + stride * 1;\r\n\t\t\t\t\t\t\tconst c = index + stride * 2;\r\n\t\t\t\t\t\t\tconst d = index + stride * 3;\r\n\t\t\t\t\t\t\tpushVector(a);\r\n\t\t\t\t\t\t\tpushVector(b);\r\n\t\t\t\t\t\t\tpushVector(d);\r\n\t\t\t\t\t\t\tpushVector(b);\r\n\t\t\t\t\t\t\tpushVector(c);\r\n\t\t\t\t\t\t\tpushVector(d);\r\n\r\n\t\t\t\t\t\t} else if (count === 3) {\r\n\r\n\t\t\t\t\t\t\tconst a = index + stride * 0;\r\n\t\t\t\t\t\t\tconst b = index + stride * 1;\r\n\t\t\t\t\t\t\tconst c = index + stride * 2;\r\n\t\t\t\t\t\t\tpushVector(a);\r\n\t\t\t\t\t\t\tpushVector(b);\r\n\t\t\t\t\t\t\tpushVector(c);\r\n\r\n\t\t\t\t\t\t} else if (count > 4) {\r\n\r\n\t\t\t\t\t\t\tfor (let k = 1, kl = count - 2; k <= kl; k++) {\r\n\r\n\t\t\t\t\t\t\t\tconst a = index + stride * 0;\r\n\t\t\t\t\t\t\t\tconst b = index + stride * k;\r\n\t\t\t\t\t\t\t\tconst c = index + stride * (k + 1);\r\n\t\t\t\t\t\t\t\tpushVector(a);\r\n\t\t\t\t\t\t\t\tpushVector(b);\r\n\t\t\t\t\t\t\t\tpushVector(c);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tindex += stride * count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor (let i = 0, l = indices.length; i < l; i += stride) {\r\n\r\n\t\t\t\t\t\tpushVector(i);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getGeometry(id) {\r\n\r\n\t\t\t\treturn getBuild(library.geometries[id], buildGeometry);\r\n\r\n\t\t\t} // kinematics\r\n\r\n\r\n\t\t\tfunction parseKinematicsModel(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tname: xml.getAttribute('name') || '',\r\n\t\t\t\t\tjoints: {},\r\n\t\t\t\t\tlinks: []\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'technique_common':\r\n\t\t\t\t\t\t\tparseKinematicsTechniqueCommon(child, data);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.kinematicsModels[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildKinematicsModel(data) {\r\n\r\n\t\t\t\tif (data.build !== undefined) return data.build;\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getKinematicsModel(id) {\r\n\r\n\t\t\t\treturn getBuild(library.kinematicsModels[id], buildKinematicsModel);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseKinematicsTechniqueCommon(xml, data) {\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'joint':\r\n\t\t\t\t\t\t\tdata.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'link':\r\n\t\t\t\t\t\t\tdata.links.push(parseKinematicsLink(child));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseKinematicsJoint(xml) {\r\n\r\n\t\t\t\tlet data;\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'prismatic':\r\n\t\t\t\t\t\tcase 'revolute':\r\n\t\t\t\t\t\t\tdata = parseKinematicsJointParameter(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseKinematicsJointParameter(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tsid: xml.getAttribute('sid'),\r\n\t\t\t\t\tname: xml.getAttribute('name') || '',\r\n\t\t\t\t\taxis: new THREE.Vector3(),\r\n\t\t\t\t\tlimits: {\r\n\t\t\t\t\t\tmin: 0,\r\n\t\t\t\t\t\tmax: 0\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttype: xml.nodeName,\r\n\t\t\t\t\tstatic: false,\r\n\t\t\t\t\tzeroPosition: 0,\r\n\t\t\t\t\tmiddlePosition: 0\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'axis':\r\n\t\t\t\t\t\t\tconst array = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tdata.axis.fromArray(array);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'limits':\r\n\t\t\t\t\t\t\tconst max = child.getElementsByTagName('max')[0];\r\n\t\t\t\t\t\t\tconst min = child.getElementsByTagName('min')[0];\r\n\t\t\t\t\t\t\tdata.limits.max = parseFloat(max.textContent);\r\n\t\t\t\t\t\t\tdata.limits.min = parseFloat(min.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // if min is equal to or greater than max, consider the joint static\r\n\r\n\r\n\t\t\t\tif (data.limits.min >= data.limits.max) {\r\n\r\n\t\t\t\t\tdata.static = true;\r\n\r\n\t\t\t\t} // calculate middle position\r\n\r\n\r\n\t\t\t\tdata.middlePosition = (data.limits.min + data.limits.max) / 2.0;\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseKinematicsLink(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tsid: xml.getAttribute('sid'),\r\n\t\t\t\t\tname: xml.getAttribute('name') || '',\r\n\t\t\t\t\tattachments: [],\r\n\t\t\t\t\ttransforms: []\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'attachment_full':\r\n\t\t\t\t\t\t\tdata.attachments.push(parseKinematicsAttachment(child));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\t\tdata.transforms.push(parseKinematicsTransform(child));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseKinematicsAttachment(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tjoint: xml.getAttribute('joint').split('/').pop(),\r\n\t\t\t\t\ttransforms: [],\r\n\t\t\t\t\tlinks: []\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'link':\r\n\t\t\t\t\t\t\tdata.links.push(parseKinematicsLink(child));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\t\tdata.transforms.push(parseKinematicsTransform(child));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseKinematicsTransform(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\ttype: xml.nodeName\r\n\t\t\t\t};\r\n\t\t\t\tconst array = parseFloats(xml.textContent);\r\n\r\n\t\t\t\tswitch (data.type) {\r\n\r\n\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\t\tdata.obj = new THREE.Matrix4();\r\n\t\t\t\t\t\tdata.obj.fromArray(array).transpose();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\t\tdata.obj = new THREE.Vector3();\r\n\t\t\t\t\t\tdata.obj.fromArray(array);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\tdata.obj = new THREE.Vector3();\r\n\t\t\t\t\t\tdata.obj.fromArray(array);\r\n\t\t\t\t\t\tdata.angle = THREE.MathUtils.degToRad(array[3]);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t} // physics\r\n\r\n\r\n\t\t\tfunction parsePhysicsModel(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tname: xml.getAttribute('name') || '',\r\n\t\t\t\t\trigidBodies: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'rigid_body':\r\n\t\t\t\t\t\t\tdata.rigidBodies[child.getAttribute('name')] = {};\r\n\t\t\t\t\t\t\tparsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.physicsModels[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parsePhysicsRigidBody(xml, data) {\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'technique_common':\r\n\t\t\t\t\t\t\tparsePhysicsTechniqueCommon(child, data);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parsePhysicsTechniqueCommon(xml, data) {\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'inertia':\r\n\t\t\t\t\t\t\tdata.inertia = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'mass':\r\n\t\t\t\t\t\t\tdata.mass = parseFloats(child.textContent)[0];\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} // scene\r\n\r\n\r\n\t\t\tfunction parseKinematicsScene(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tbindJointAxis: []\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'bind_joint_axis':\r\n\t\t\t\t\t\t\tdata.bindJointAxis.push(parseKinematicsBindJointAxis(child));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseKinematicsBindJointAxis(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\ttarget: xml.getAttribute('target').split('/').pop()\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'axis':\r\n\t\t\t\t\t\t\tconst param = child.getElementsByTagName('param')[0];\r\n\t\t\t\t\t\t\tdata.axis = param.textContent;\r\n\t\t\t\t\t\t\tconst tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\r\n\t\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildKinematicsScene(data) {\r\n\r\n\t\t\t\tif (data.build !== undefined) return data.build;\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getKinematicsScene(id) {\r\n\r\n\t\t\t\treturn getBuild(library.kinematicsScenes[id], buildKinematicsScene);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction setupKinematics() {\r\n\r\n\t\t\t\tconst kinematicsModelId = Object.keys(library.kinematicsModels)[0];\r\n\t\t\t\tconst kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\r\n\t\t\t\tconst visualSceneId = Object.keys(library.visualScenes)[0];\r\n\t\t\t\tif (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\r\n\t\t\t\tconst kinematicsModel = getKinematicsModel(kinematicsModelId);\r\n\t\t\t\tconst kinematicsScene = getKinematicsScene(kinematicsSceneId);\r\n\t\t\t\tconst visualScene = getVisualScene(visualSceneId);\r\n\t\t\t\tconst bindJointAxis = kinematicsScene.bindJointAxis;\r\n\t\t\t\tconst jointMap = {};\r\n\r\n\t\t\t\tfor (let i = 0, l = bindJointAxis.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\r\n\r\n\t\t\t\t\tconst targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\r\n\r\n\t\t\t\t\tif (targetElement) {\r\n\r\n\t\t\t\t\t\t// get the parent of the transform element\r\n\t\t\t\t\t\tconst parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\r\n\r\n\t\t\t\t\t\tconnect(axis.jointIndex, parentVisualElement);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction connect(jointIndex, visualElement) {\r\n\r\n\t\t\t\t\tconst visualElementName = visualElement.getAttribute('name');\r\n\t\t\t\t\tconst joint = kinematicsModel.joints[jointIndex];\r\n\t\t\t\t\tvisualScene.traverse(function (object) {\r\n\r\n\t\t\t\t\t\tif (object.name === visualElementName) {\r\n\r\n\t\t\t\t\t\t\tjointMap[jointIndex] = {\r\n\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\ttransforms: buildTransformList(visualElement),\r\n\t\t\t\t\t\t\t\tjoint: joint,\r\n\t\t\t\t\t\t\t\tposition: joint.zeroPosition\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst m0 = new THREE.Matrix4();\r\n\t\t\t\tkinematics = {\r\n\t\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\r\n\t\t\t\t\tgetJointValue: function (jointIndex) {\r\n\r\n\t\t\t\t\t\tconst jointData = jointMap[jointIndex];\r\n\r\n\t\t\t\t\t\tif (jointData) {\r\n\r\n\t\t\t\t\t\t\treturn jointData.position;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.');\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tsetJointValue: function (jointIndex, value) {\r\n\r\n\t\t\t\t\t\tconst jointData = jointMap[jointIndex];\r\n\r\n\t\t\t\t\t\tif (jointData) {\r\n\r\n\t\t\t\t\t\t\tconst joint = jointData.joint;\r\n\r\n\t\t\t\t\t\t\tif (value > joint.limits.max || value < joint.limits.min) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\r\n\r\n\t\t\t\t\t\t\t} else if (joint.static) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tconst object = jointData.object;\r\n\t\t\t\t\t\t\t\tconst axis = joint.axis;\r\n\t\t\t\t\t\t\t\tconst transforms = jointData.transforms;\r\n\t\t\t\t\t\t\t\tmatrix.identity(); // each update, we have to apply all transforms in the correct order\r\n\r\n\t\t\t\t\t\t\t\tfor (let i = 0; i < transforms.length; i++) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\r\n\r\n\t\t\t\t\t\t\t\t\tif (transform.sid && transform.sid.indexOf(jointIndex) !== - 1) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tswitch (joint.type) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tcase 'revolute':\r\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeRotationAxis(axis, THREE.MathUtils.degToRad(value)));\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\r\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\tswitch (transform.type) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(transform.obj);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tcase 'scale':\r\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.scale(transform.obj);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tobject.matrix.copy(matrix);\r\n\t\t\t\t\t\t\t\tobject.matrix.decompose(object.position, object.quaternion, object.scale);\r\n\t\t\t\t\t\t\t\tjointMap[jointIndex].position = value;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tconsole.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildTransformList(node) {\r\n\r\n\t\t\t\tconst transforms = [];\r\n\t\t\t\tconst xml = collada.querySelector('[id=\"' + node.id + '\"]');\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\t\t\t\t\tlet array, vector;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\t\t\tarray = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tconst matrix = new THREE.Matrix4().fromArray(array).transpose();\r\n\t\t\t\t\t\t\ttransforms.push({\r\n\t\t\t\t\t\t\t\tsid: child.getAttribute('sid'),\r\n\t\t\t\t\t\t\t\ttype: child.nodeName,\r\n\t\t\t\t\t\t\t\tobj: matrix\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\t\tcase 'scale':\r\n\t\t\t\t\t\t\tarray = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tvector = new THREE.Vector3().fromArray(array);\r\n\t\t\t\t\t\t\ttransforms.push({\r\n\t\t\t\t\t\t\t\tsid: child.getAttribute('sid'),\r\n\t\t\t\t\t\t\t\ttype: child.nodeName,\r\n\t\t\t\t\t\t\t\tobj: vector\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\t\tarray = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tvector = new THREE.Vector3().fromArray(array);\r\n\t\t\t\t\t\t\tconst angle = THREE.MathUtils.degToRad(array[3]);\r\n\t\t\t\t\t\t\ttransforms.push({\r\n\t\t\t\t\t\t\t\tsid: child.getAttribute('sid'),\r\n\t\t\t\t\t\t\t\ttype: child.nodeName,\r\n\t\t\t\t\t\t\t\tobj: vector,\r\n\t\t\t\t\t\t\t\tangle: angle\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn transforms;\r\n\r\n\t\t\t} // nodes\r\n\r\n\r\n\t\t\tfunction prepareNodes(xml) {\r\n\r\n\t\t\t\tconst elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\r\n\r\n\t\t\t\tfor (let i = 0; i < elements.length; i++) {\r\n\r\n\t\t\t\t\tconst element = elements[i];\r\n\r\n\t\t\t\t\tif (element.hasAttribute('id') === false) {\r\n\r\n\t\t\t\t\t\telement.setAttribute('id', generateId());\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst matrix = new THREE.Matrix4();\r\n\t\t\tconst vector = new THREE.Vector3();\r\n\r\n\t\t\tfunction parseNode(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tname: xml.getAttribute('name') || '',\r\n\t\t\t\t\ttype: xml.getAttribute('type'),\r\n\t\t\t\t\tid: xml.getAttribute('id'),\r\n\t\t\t\t\tsid: xml.getAttribute('sid'),\r\n\t\t\t\t\tmatrix: new THREE.Matrix4(),\r\n\t\t\t\t\tnodes: [],\r\n\t\t\t\t\tinstanceCameras: [],\r\n\t\t\t\t\tinstanceControllers: [],\r\n\t\t\t\t\tinstanceLights: [],\r\n\t\t\t\t\tinstanceGeometries: [],\r\n\t\t\t\t\tinstanceNodes: [],\r\n\t\t\t\t\ttransforms: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\t\t\t\t\tif (child.nodeType !== 1) continue;\r\n\t\t\t\t\tlet array;\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'node':\r\n\t\t\t\t\t\t\tdata.nodes.push(child.getAttribute('id'));\r\n\t\t\t\t\t\t\tparseNode(child);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'instance_camera':\r\n\t\t\t\t\t\t\tdata.instanceCameras.push(parseId(child.getAttribute('url')));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'instance_controller':\r\n\t\t\t\t\t\t\tdata.instanceControllers.push(parseNodeInstance(child));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'instance_light':\r\n\t\t\t\t\t\t\tdata.instanceLights.push(parseId(child.getAttribute('url')));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'instance_geometry':\r\n\t\t\t\t\t\t\tdata.instanceGeometries.push(parseNodeInstance(child));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'instance_node':\r\n\t\t\t\t\t\t\tdata.instanceNodes.push(parseId(child.getAttribute('url')));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\t\t\tarray = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tdata.matrix.multiply(matrix.fromArray(array).transpose());\r\n\t\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\t\t\tarray = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tvector.fromArray(array);\r\n\t\t\t\t\t\t\tdata.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\r\n\t\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\t\tarray = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tconst angle = THREE.MathUtils.degToRad(array[3]);\r\n\t\t\t\t\t\t\tdata.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\r\n\t\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'scale':\r\n\t\t\t\t\t\t\tarray = parseFloats(child.textContent);\r\n\t\t\t\t\t\t\tdata.matrix.scale(vector.fromArray(array));\r\n\t\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'extra':\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.log(child);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (hasNode(data.id)) {\r\n\r\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tlibrary.nodes[data.id] = data;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseNodeInstance(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tid: parseId(xml.getAttribute('url')),\r\n\t\t\t\t\tmaterials: {},\r\n\t\t\t\t\tskeletons: []\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (let i = 0; i < xml.childNodes.length; i++) {\r\n\r\n\t\t\t\t\tconst child = xml.childNodes[i];\r\n\r\n\t\t\t\t\tswitch (child.nodeName) {\r\n\r\n\t\t\t\t\t\tcase 'bind_material':\r\n\t\t\t\t\t\t\tconst instances = child.getElementsByTagName('instance_material');\r\n\r\n\t\t\t\t\t\t\tfor (let j = 0; j < instances.length; j++) {\r\n\r\n\t\t\t\t\t\t\t\tconst instance = instances[j];\r\n\t\t\t\t\t\t\t\tconst symbol = instance.getAttribute('symbol');\r\n\t\t\t\t\t\t\t\tconst target = instance.getAttribute('target');\r\n\t\t\t\t\t\t\t\tdata.materials[symbol] = parseId(target);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'skeleton':\r\n\t\t\t\t\t\t\tdata.skeletons.push(parseId(child.textContent));\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildSkeleton(skeletons, joints) {\r\n\r\n\t\t\t\tconst boneData = [];\r\n\t\t\t\tconst sortedBoneData = [];\r\n\t\t\t\tlet i, j, data; // a skeleton can have multiple root bones. collada expresses this\r\n\t\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\r\n\r\n\t\t\t\tfor (i = 0; i < skeletons.length; i++) {\r\n\r\n\t\t\t\t\tconst skeleton = skeletons[i];\r\n\t\t\t\t\tlet root;\r\n\r\n\t\t\t\t\tif (hasNode(skeleton)) {\r\n\r\n\t\t\t\t\t\troot = getNode(skeleton);\r\n\t\t\t\t\t\tbuildBoneHierarchy(root, joints, boneData);\r\n\r\n\t\t\t\t\t} else if (hasVisualScene(skeleton)) {\r\n\r\n\t\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\r\n\t\t\t\t\t\tconst visualScene = library.visualScenes[skeleton];\r\n\t\t\t\t\t\tconst children = visualScene.children;\r\n\r\n\t\t\t\t\t\tfor (let j = 0; j < children.length; j++) {\r\n\r\n\t\t\t\t\t\t\tconst child = children[j];\r\n\r\n\t\t\t\t\t\t\tif (child.type === 'JOINT') {\r\n\r\n\t\t\t\t\t\t\t\tconst root = getNode(child.id);\r\n\t\t\t\t\t\t\t\tbuildBoneHierarchy(root, joints, boneData);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // sort bone data (the order is defined in the corresponding controller)\r\n\r\n\r\n\t\t\t\tfor (i = 0; i < joints.length; i++) {\r\n\r\n\t\t\t\t\tfor (j = 0; j < boneData.length; j++) {\r\n\r\n\t\t\t\t\t\tdata = boneData[j];\r\n\r\n\t\t\t\t\t\tif (data.bone.name === joints[i].name) {\r\n\r\n\t\t\t\t\t\t\tsortedBoneData[i] = data;\r\n\t\t\t\t\t\t\tdata.processed = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // add unprocessed bone data at the end of the list\r\n\r\n\r\n\t\t\t\tfor (i = 0; i < boneData.length; i++) {\r\n\r\n\t\t\t\t\tdata = boneData[i];\r\n\r\n\t\t\t\t\tif (data.processed === false) {\r\n\r\n\t\t\t\t\t\tsortedBoneData.push(data);\r\n\t\t\t\t\t\tdata.processed = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // setup arrays for skeleton creation\r\n\r\n\r\n\t\t\t\tconst bones = [];\r\n\t\t\t\tconst boneInverses = [];\r\n\r\n\t\t\t\tfor (i = 0; i < sortedBoneData.length; i++) {\r\n\r\n\t\t\t\t\tdata = sortedBoneData[i];\r\n\t\t\t\t\tbones.push(data.bone);\r\n\t\t\t\t\tboneInverses.push(data.boneInverse);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new THREE.Skeleton(bones, boneInverses);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildBoneHierarchy(root, joints, boneData) {\r\n\r\n\t\t\t\t// setup bone data from visual scene\r\n\t\t\t\troot.traverse(function (object) {\r\n\r\n\t\t\t\t\tif (object.isBone === true) {\r\n\r\n\t\t\t\t\t\tlet boneInverse; // retrieve the boneInverse from the controller data\r\n\r\n\t\t\t\t\t\tfor (let i = 0; i < joints.length; i++) {\r\n\r\n\t\t\t\t\t\t\tconst joint = joints[i];\r\n\r\n\t\t\t\t\t\t\tif (joint.name === object.name) {\r\n\r\n\t\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (boneInverse === undefined) {\r\n\r\n\t\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\r\n\t\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\r\n\t\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\r\n\t\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\r\n\t\t\t\t\t\t\t// ensure a correct animation of the model.\r\n\t\t\t\t\t\t\tboneInverse = new THREE.Matrix4();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tboneData.push({\r\n\t\t\t\t\t\t\tbone: object,\r\n\t\t\t\t\t\t\tboneInverse: boneInverse,\r\n\t\t\t\t\t\t\tprocessed: false\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildNode(data) {\r\n\r\n\t\t\t\tconst objects = [];\r\n\t\t\t\tconst matrix = data.matrix;\r\n\t\t\t\tconst nodes = data.nodes;\r\n\t\t\t\tconst type = data.type;\r\n\t\t\t\tconst instanceCameras = data.instanceCameras;\r\n\t\t\t\tconst instanceControllers = data.instanceControllers;\r\n\t\t\t\tconst instanceLights = data.instanceLights;\r\n\t\t\t\tconst instanceGeometries = data.instanceGeometries;\r\n\t\t\t\tconst instanceNodes = data.instanceNodes; // nodes\r\n\r\n\t\t\t\tfor (let i = 0, l = nodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tobjects.push(getNode(nodes[i]));\r\n\r\n\t\t\t\t} // instance cameras\r\n\r\n\r\n\t\t\t\tfor (let i = 0, l = instanceCameras.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst instanceCamera = getCamera(instanceCameras[i]);\r\n\r\n\t\t\t\t\tif (instanceCamera !== null) {\r\n\r\n\t\t\t\t\t\tobjects.push(instanceCamera.clone());\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // instance controllers\r\n\r\n\r\n\t\t\t\tfor (let i = 0, l = instanceControllers.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst instance = instanceControllers[i];\r\n\t\t\t\t\tconst controller = getController(instance.id);\r\n\t\t\t\t\tconst geometries = getGeometry(controller.id);\r\n\t\t\t\t\tconst newObjects = buildObjects(geometries, instance.materials);\r\n\t\t\t\t\tconst skeletons = instance.skeletons;\r\n\t\t\t\t\tconst joints = controller.skin.joints;\r\n\t\t\t\t\tconst skeleton = buildSkeleton(skeletons, joints);\r\n\r\n\t\t\t\t\tfor (let j = 0, jl = newObjects.length; j < jl; j++) {\r\n\r\n\t\t\t\t\t\tconst object = newObjects[j];\r\n\r\n\t\t\t\t\t\tif (object.isSkinnedMesh) {\r\n\r\n\t\t\t\t\t\t\tobject.bind(skeleton, controller.skin.bindMatrix);\r\n\t\t\t\t\t\t\tobject.normalizeSkinWeights();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tobjects.push(object);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // instance lights\r\n\r\n\r\n\t\t\t\tfor (let i = 0, l = instanceLights.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst instanceLight = getLight(instanceLights[i]);\r\n\r\n\t\t\t\t\tif (instanceLight !== null) {\r\n\r\n\t\t\t\t\t\tobjects.push(instanceLight.clone());\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // instance geometries\r\n\r\n\r\n\t\t\t\tfor (let i = 0, l = instanceGeometries.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\r\n\t\t\t\t\t// this is the case when primitives are combined like triangles and lines\r\n\r\n\t\t\t\t\tconst geometries = getGeometry(instance.id);\r\n\t\t\t\t\tconst newObjects = buildObjects(geometries, instance.materials);\r\n\r\n\t\t\t\t\tfor (let j = 0, jl = newObjects.length; j < jl; j++) {\r\n\r\n\t\t\t\t\t\tobjects.push(newObjects[j]);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // instance nodes\r\n\r\n\r\n\t\t\t\tfor (let i = 0, l = instanceNodes.length; i < l; i++) {\r\n\r\n\t\t\t\t\tobjects.push(getNode(instanceNodes[i]).clone());\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet object;\r\n\r\n\t\t\t\tif (nodes.length === 0 && objects.length === 1) {\r\n\r\n\t\t\t\t\tobject = objects[0];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tobject = type === 'JOINT' ? new THREE.Bone() : new THREE.Group();\r\n\r\n\t\t\t\t\tfor (let i = 0; i < objects.length; i++) {\r\n\r\n\t\t\t\t\t\tobject.add(objects[i]);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.name = type === 'JOINT' ? data.sid : data.name;\r\n\t\t\t\tobject.matrix.copy(matrix);\r\n\t\t\t\tobject.matrix.decompose(object.position, object.quaternion, object.scale);\r\n\t\t\t\treturn object;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst fallbackMaterial = new THREE.MeshBasicMaterial({\r\n\t\t\t\tcolor: 0xff00ff\r\n\t\t\t});\r\n\r\n\t\t\tfunction resolveMaterialBinding(keys, instanceMaterials) {\r\n\r\n\t\t\t\tconst materials = [];\r\n\r\n\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\r\n\r\n\t\t\t\t\tconst id = instanceMaterials[keys[i]];\r\n\r\n\t\t\t\t\tif (id === undefined) {\r\n\r\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\r\n\t\t\t\t\t\tmaterials.push(fallbackMaterial);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmaterials.push(getMaterial(id));\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn materials;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildObjects(geometries, instanceMaterials) {\r\n\r\n\t\t\t\tconst objects = [];\r\n\r\n\t\t\t\tfor (const type in geometries) {\r\n\r\n\t\t\t\t\tconst geometry = geometries[type];\r\n\t\t\t\t\tconst materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\r\n\r\n\t\t\t\t\tif (materials.length === 0) {\r\n\r\n\t\t\t\t\t\tif (type === 'lines' || type === 'linestrips') {\r\n\r\n\t\t\t\t\t\t\tmaterials.push(new THREE.LineBasicMaterial());\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tmaterials.push(new THREE.MeshPhongMaterial());\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} // regard skinning\r\n\r\n\r\n\t\t\t\t\tconst skinning = geometry.data.attributes.skinIndex !== undefined; // choose between a single or multi materials (material array)\r\n\r\n\t\t\t\t\tconst material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\r\n\r\n\t\t\t\t\tlet object;\r\n\r\n\t\t\t\t\tswitch (type) {\r\n\r\n\t\t\t\t\t\tcase 'lines':\r\n\t\t\t\t\t\t\tobject = new THREE.LineSegments(geometry.data, material);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'linestrips':\r\n\t\t\t\t\t\t\tobject = new THREE.Line(geometry.data, material);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'triangles':\r\n\t\t\t\t\t\tcase 'polylist':\r\n\t\t\t\t\t\t\tif (skinning) {\r\n\r\n\t\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh(geometry.data, material);\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tobject = new THREE.Mesh(geometry.data, material);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobjects.push(object);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn objects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction hasNode(id) {\r\n\r\n\t\t\t\treturn library.nodes[id] !== undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getNode(id) {\r\n\r\n\t\t\t\treturn getBuild(library.nodes[id], buildNode);\r\n\r\n\t\t\t} // visual scenes\r\n\r\n\r\n\t\t\tfunction parseVisualScene(xml) {\r\n\r\n\t\t\t\tconst data = {\r\n\t\t\t\t\tname: xml.getAttribute('name'),\r\n\t\t\t\t\tchildren: []\r\n\t\t\t\t};\r\n\t\t\t\tprepareNodes(xml);\r\n\t\t\t\tconst elements = getElementsByTagName(xml, 'node');\r\n\r\n\t\t\t\tfor (let i = 0; i < elements.length; i++) {\r\n\r\n\t\t\t\t\tdata.children.push(parseNode(elements[i]));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlibrary.visualScenes[xml.getAttribute('id')] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction buildVisualScene(data) {\r\n\r\n\t\t\t\tconst group = new THREE.Group();\r\n\t\t\t\tgroup.name = data.name;\r\n\t\t\t\tconst children = data.children;\r\n\r\n\t\t\t\tfor (let i = 0; i < children.length; i++) {\r\n\r\n\t\t\t\t\tconst child = children[i];\r\n\t\t\t\t\tgroup.add(getNode(child.id));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn group;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction hasVisualScene(id) {\r\n\r\n\t\t\t\treturn library.visualScenes[id] !== undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getVisualScene(id) {\r\n\r\n\t\t\t\treturn getBuild(library.visualScenes[id], buildVisualScene);\r\n\r\n\t\t\t} // scenes\r\n\r\n\r\n\t\t\tfunction parseScene(xml) {\r\n\r\n\t\t\t\tconst instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\r\n\t\t\t\treturn getVisualScene(parseId(instance.getAttribute('url')));\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction setupAnimations() {\r\n\r\n\t\t\t\tconst clips = library.clips;\r\n\r\n\t\t\t\tif (isEmpty(clips) === true) {\r\n\r\n\t\t\t\t\tif (isEmpty(library.animations) === false) {\r\n\r\n\t\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\r\n\t\t\t\t\t\tconst tracks = [];\r\n\r\n\t\t\t\t\t\tfor (const id in library.animations) {\r\n\r\n\t\t\t\t\t\t\tconst animationTracks = getAnimation(id);\r\n\r\n\t\t\t\t\t\t\tfor (let i = 0, l = animationTracks.length; i < l; i++) {\r\n\r\n\t\t\t\t\t\t\t\ttracks.push(animationTracks[i]);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tanimations.push(new THREE.AnimationClip('default', - 1, tracks));\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor (const id in clips) {\r\n\r\n\t\t\t\t\t\tanimations.push(getAnimationClip(id));\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} // convert the parser error element into text with each child elements text\r\n\t\t\t// separated by new lines.\r\n\r\n\r\n\t\t\tfunction parserErrorToText(parserError) {\r\n\r\n\t\t\t\tlet result = '';\r\n\t\t\t\tconst stack = [parserError];\r\n\r\n\t\t\t\twhile (stack.length) {\r\n\r\n\t\t\t\t\tconst node = stack.shift();\r\n\r\n\t\t\t\t\tif (node.nodeType === Node.TEXT_NODE) {\r\n\r\n\t\t\t\t\t\tresult += node.textContent;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tresult += '\\n';\r\n\t\t\t\t\t\tstack.push.apply(stack, node.childNodes);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn result.trim();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (text.length === 0) {\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tscene: new THREE.Scene()\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst xml = new DOMParser().parseFromString(text, 'application/xml');\r\n\t\t\tconst collada = getElementsByTagName(xml, 'COLLADA')[0];\r\n\t\t\tconst parserError = xml.getElementsByTagName('parsererror')[0];\r\n\r\n\t\t\tif (parserError !== undefined) {\r\n\r\n\t\t\t\t// Chrome will return parser error with a div in it\r\n\t\t\t\tconst errorElement = getElementsByTagName(parserError, 'div')[0];\r\n\t\t\t\tlet errorText;\r\n\r\n\t\t\t\tif (errorElement) {\r\n\r\n\t\t\t\t\terrorText = errorElement.textContent;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\terrorText = parserErrorToText(parserError);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconsole.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} // metadata\r\n\r\n\r\n\t\t\tconst version = collada.getAttribute('version');\r\n\t\t\tconsole.log('THREE.ColladaLoader: File version', version);\r\n\t\t\tconst asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\r\n\t\t\tconst textureLoader = new THREE.TextureLoader(this.manager);\r\n\t\t\ttextureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\r\n\t\t\tlet tgaLoader;\r\n\r\n\t\t\tif (THREE.TGALoader) {\r\n\r\n\t\t\t\ttgaLoader = new THREE.TGALoader(this.manager);\r\n\t\t\t\ttgaLoader.setPath(this.resourcePath || path);\r\n\r\n\t\t\t} //\r\n\r\n\r\n\t\t\tconst animations = [];\r\n\t\t\tlet kinematics = {};\r\n\t\t\tlet count = 0; //\r\n\r\n\t\t\tconst library = {\r\n\t\t\t\tanimations: {},\r\n\t\t\t\tclips: {},\r\n\t\t\t\tcontrollers: {},\r\n\t\t\t\timages: {},\r\n\t\t\t\teffects: {},\r\n\t\t\t\tmaterials: {},\r\n\t\t\t\tcameras: {},\r\n\t\t\t\tlights: {},\r\n\t\t\t\tgeometries: {},\r\n\t\t\t\tnodes: {},\r\n\t\t\t\tvisualScenes: {},\r\n\t\t\t\tkinematicsModels: {},\r\n\t\t\t\tphysicsModels: {},\r\n\t\t\t\tkinematicsScenes: {}\r\n\t\t\t};\r\n\t\t\tparseLibrary(collada, 'library_animations', 'animation', parseAnimation);\r\n\t\t\tparseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\r\n\t\t\tparseLibrary(collada, 'library_controllers', 'controller', parseController);\r\n\t\t\tparseLibrary(collada, 'library_images', 'image', parseImage);\r\n\t\t\tparseLibrary(collada, 'library_effects', 'effect', parseEffect);\r\n\t\t\tparseLibrary(collada, 'library_materials', 'material', parseMaterial);\r\n\t\t\tparseLibrary(collada, 'library_cameras', 'camera', parseCamera);\r\n\t\t\tparseLibrary(collada, 'library_lights', 'light', parseLight);\r\n\t\t\tparseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\r\n\t\t\tparseLibrary(collada, 'library_nodes', 'node', parseNode);\r\n\t\t\tparseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\r\n\t\t\tparseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\r\n\t\t\tparseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\r\n\t\t\tparseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\r\n\t\t\tbuildLibrary(library.animations, buildAnimation);\r\n\t\t\tbuildLibrary(library.clips, buildAnimationClip);\r\n\t\t\tbuildLibrary(library.controllers, buildController);\r\n\t\t\tbuildLibrary(library.images, buildImage);\r\n\t\t\tbuildLibrary(library.effects, buildEffect);\r\n\t\t\tbuildLibrary(library.materials, buildMaterial);\r\n\t\t\tbuildLibrary(library.cameras, buildCamera);\r\n\t\t\tbuildLibrary(library.lights, buildLight);\r\n\t\t\tbuildLibrary(library.geometries, buildGeometry);\r\n\t\t\tbuildLibrary(library.visualScenes, buildVisualScene);\r\n\t\t\tsetupAnimations();\r\n\t\t\tsetupKinematics();\r\n\t\t\tconst scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\r\n\t\t\tscene.animations = animations;\r\n\r\n\t\t\tif (asset.upAxis === 'Z_UP') {\r\n\r\n\t\t\t\tscene.quaternion.setFromEuler(new THREE.Euler(- Math.PI / 2, 0, 0));\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscene.scale.multiplyScalar(asset.unit);\r\n\t\t\treturn {\r\n\t\t\t\tget animations() {\r\n\r\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\r\n\t\t\t\t\treturn animations;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tkinematics: kinematics,\r\n\t\t\t\tlibrary: library,\r\n\t\t\t\tscene: scene\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.ColladaLoader = ColladaLoader;\r\n\r\n})();\r\n\r\nmodule.exports = exports = THREE.ColladaLoader;\r\n"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,gBAAgB,CAAC;;AAEvC;AACA;AACA;AACA;;AAEA,CAAC,YAAY;EAEZ,MAAMC,aAAa,SAASF,KAAK,CAACG,MAAM,CAAC;IAExCC,WAAWA,CAACC,OAAO,EAAE;MAEpB,KAAK,CAACA,OAAO,CAAC;IAEf;IAEAC,IAAIA,CAACC,GAAG,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAE;MAEtC,MAAMC,KAAK,GAAG,IAAI;MAClB,MAAMC,IAAI,GAAGD,KAAK,CAACC,IAAI,KAAK,EAAE,GAAGZ,KAAK,CAACa,WAAW,CAACC,cAAc,CAACP,GAAG,CAAC,GAAGI,KAAK,CAACC,IAAI;MACnF,MAAMG,MAAM,GAAG,IAAIf,KAAK,CAACgB,UAAU,CAACL,KAAK,CAACN,OAAO,CAAC;MAClDU,MAAM,CAACE,OAAO,CAACN,KAAK,CAACC,IAAI,CAAC;MAC1BG,MAAM,CAACG,gBAAgB,CAACP,KAAK,CAACQ,aAAa,CAAC;MAC5CJ,MAAM,CAACK,kBAAkB,CAACT,KAAK,CAACU,eAAe,CAAC;MAChDN,MAAM,CAACT,IAAI,CAACC,GAAG,EAAE,UAAUe,IAAI,EAAE;QAEhC,IAAI;UAEHd,MAAM,CAACG,KAAK,CAACY,KAAK,CAACD,IAAI,EAAEV,IAAI,CAAC,CAAC;QAEhC,CAAC,CAAC,OAAOY,CAAC,EAAE;UAEX,IAAId,OAAO,EAAE;YAEZA,OAAO,CAACc,CAAC,CAAC;UAEX,CAAC,MAAM;YAENC,OAAO,CAACC,KAAK,CAACF,CAAC,CAAC;UAEjB;UAEAb,KAAK,CAACN,OAAO,CAACsB,SAAS,CAACpB,GAAG,CAAC;QAE7B;MAED,CAAC,EAAEE,UAAU,EAAEC,OAAO,CAAC;IAExB;IAEAa,KAAKA,CAACD,IAAI,EAAEV,IAAI,EAAE;MAEjB,SAASgB,oBAAoBA,CAACC,GAAG,EAAEC,IAAI,EAAE;QAExC;QACA,MAAMC,KAAK,GAAG,EAAE;QAChB,MAAMC,UAAU,GAAGH,GAAG,CAACG,UAAU;QAEjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGF,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAElD,MAAMG,KAAK,GAAGJ,UAAU,CAACC,CAAC,CAAC;UAE3B,IAAIG,KAAK,CAACC,QAAQ,KAAKP,IAAI,EAAE;YAE5BC,KAAK,CAACO,IAAI,CAACF,KAAK,CAAC;UAElB;QAED;QAEA,OAAOL,KAAK;MAEb;MAEA,SAASQ,YAAYA,CAACjB,IAAI,EAAE;QAE3B,IAAIA,IAAI,CAACa,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;QAChC,MAAMK,KAAK,GAAGlB,IAAI,CAACmB,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK,CAAC;QACtC,MAAMX,KAAK,GAAG,IAAIY,KAAK,CAACH,KAAK,CAACL,MAAM,CAAC;QAErC,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGM,KAAK,CAACL,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAE7CF,KAAK,CAACE,CAAC,CAAC,GAAGO,KAAK,CAACP,CAAC,CAAC;QAEpB;QAEA,OAAOF,KAAK;MAEb;MAEA,SAASa,WAAWA,CAACtB,IAAI,EAAE;QAE1B,IAAIA,IAAI,CAACa,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;QAChC,MAAMK,KAAK,GAAGlB,IAAI,CAACmB,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK,CAAC;QACtC,MAAMX,KAAK,GAAG,IAAIY,KAAK,CAACH,KAAK,CAACL,MAAM,CAAC;QAErC,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGM,KAAK,CAACL,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAE7CF,KAAK,CAACE,CAAC,CAAC,GAAGY,UAAU,CAACL,KAAK,CAACP,CAAC,CAAC,CAAC;QAEhC;QAEA,OAAOF,KAAK;MAEb;MAEA,SAASe,SAASA,CAACxB,IAAI,EAAE;QAExB,IAAIA,IAAI,CAACa,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;QAChC,MAAMK,KAAK,GAAGlB,IAAI,CAACmB,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK,CAAC;QACtC,MAAMX,KAAK,GAAG,IAAIY,KAAK,CAACH,KAAK,CAACL,MAAM,CAAC;QAErC,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGM,KAAK,CAACL,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAE7CF,KAAK,CAACE,CAAC,CAAC,GAAGc,QAAQ,CAACP,KAAK,CAACP,CAAC,CAAC,CAAC;QAE9B;QAEA,OAAOF,KAAK;MAEb;MAEA,SAASiB,OAAOA,CAAC1B,IAAI,EAAE;QAEtB,OAAOA,IAAI,CAAC2B,SAAS,CAAC,CAAC,CAAC;MAEzB;MAEA,SAASC,UAAUA,CAAA,EAAG;QAErB,OAAO,gBAAgB,GAAGC,KAAK,EAAE;MAElC;MAEA,SAASC,OAAOA,CAACC,MAAM,EAAE;QAExB,OAAOC,MAAM,CAACC,IAAI,CAACF,MAAM,CAAC,CAAClB,MAAM,KAAK,CAAC;MAExC,CAAC,CAAC;;MAGF,SAASqB,UAAUA,CAAC3B,GAAG,EAAE;QAExB,OAAO;UACN4B,IAAI,EAAEC,cAAc,CAAC9B,oBAAoB,CAACC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;UAC1D8B,MAAM,EAAEC,gBAAgB,CAAChC,oBAAoB,CAACC,GAAG,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;QACjE,CAAC;MAEF;MAEA,SAAS6B,cAAcA,CAAC7B,GAAG,EAAE;QAE5B,IAAIA,GAAG,KAAKgC,SAAS,IAAIhC,GAAG,CAACiC,YAAY,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE;UAE5D,OAAOjB,UAAU,CAAChB,GAAG,CAACkC,YAAY,CAAC,OAAO,CAAC,CAAC;QAE7C,CAAC,MAAM;UAEN,OAAO,CAAC,CAAC,CAAC;QAEX;MAED;MAEA,SAASH,gBAAgBA,CAAC/B,GAAG,EAAE;QAE9B,OAAOA,GAAG,KAAKgC,SAAS,GAAGhC,GAAG,CAACmC,WAAW,GAAG,MAAM;MAEpD,CAAC,CAAC;;MAGF,SAASC,YAAYA,CAACpC,GAAG,EAAEqC,WAAW,EAAE7B,QAAQ,EAAE8B,MAAM,EAAE;QAEzD,MAAMC,OAAO,GAAGxC,oBAAoB,CAACC,GAAG,EAAEqC,WAAW,CAAC,CAAC,CAAC,CAAC;QAEzD,IAAIE,OAAO,KAAKP,SAAS,EAAE;UAE1B,MAAMQ,QAAQ,GAAGzC,oBAAoB,CAACwC,OAAO,EAAE/B,QAAQ,CAAC;UAExD,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,QAAQ,CAAClC,MAAM,EAAEF,CAAC,EAAE,EAAE;YAEzCkC,MAAM,CAACE,QAAQ,CAACpC,CAAC,CAAC,CAAC;UAEpB;QAED;MAED;MAEA,SAASqC,YAAYA,CAACC,IAAI,EAAEC,OAAO,EAAE;QAEpC,KAAK,MAAM1C,IAAI,IAAIyC,IAAI,EAAE;UAExB,MAAMlB,MAAM,GAAGkB,IAAI,CAACzC,IAAI,CAAC;UACzBuB,MAAM,CAACoB,KAAK,GAAGD,OAAO,CAACD,IAAI,CAACzC,IAAI,CAAC,CAAC;QAEnC;MAED,CAAC,CAAC;;MAGF,SAAS4C,QAAQA,CAACH,IAAI,EAAEC,OAAO,EAAE;QAEhC,IAAID,IAAI,CAACE,KAAK,KAAKZ,SAAS,EAAE,OAAOU,IAAI,CAACE,KAAK;QAC/CF,IAAI,CAACE,KAAK,GAAGD,OAAO,CAACD,IAAI,CAAC;QAC1B,OAAOA,IAAI,CAACE,KAAK;MAElB,CAAC,CAAC;;MAGF,SAASE,cAAcA,CAAC9C,GAAG,EAAE;QAE5B,MAAM0C,IAAI,GAAG;UACZK,OAAO,EAAE,CAAC,CAAC;UACXC,QAAQ,EAAE,CAAC,CAAC;UACZC,QAAQ,EAAE,CAAC;QACZ,CAAC;QACD,IAAIC,WAAW,GAAG,KAAK;QAEvB,KAAK,IAAI9C,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAC1B,IAAIC,EAAE;UAEN,QAAQ7C,KAAK,CAACC,QAAQ;YAErB,KAAK,QAAQ;cACZ4C,EAAE,GAAG7C,KAAK,CAAC2B,YAAY,CAAC,IAAI,CAAC;cAC7BQ,IAAI,CAACK,OAAO,CAACK,EAAE,CAAC,GAAGC,WAAW,CAAC9C,KAAK,CAAC;cACrC;YAED,KAAK,SAAS;cACb6C,EAAE,GAAG7C,KAAK,CAAC2B,YAAY,CAAC,IAAI,CAAC;cAC7BQ,IAAI,CAACM,QAAQ,CAACI,EAAE,CAAC,GAAGE,qBAAqB,CAAC/C,KAAK,CAAC;cAChD;YAED,KAAK,SAAS;cACb6C,EAAE,GAAG7C,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC;cACjCQ,IAAI,CAACO,QAAQ,CAACG,EAAE,CAAC,GAAGG,qBAAqB,CAAChD,KAAK,CAAC;cAChD;YAED,KAAK,WAAW;cACf;cACAuC,cAAc,CAACvC,KAAK,CAAC;cACrB2C,WAAW,GAAG,IAAI;cAClB;YAED;cACCtD,OAAO,CAAC4D,GAAG,CAACjD,KAAK,CAAC;UAEpB;QAED;QAEA,IAAI2C,WAAW,KAAK,KAAK,EAAE;UAE1B;UACAX,OAAO,CAACkB,UAAU,CAACzD,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,IAAI/D,KAAK,CAACuF,SAAS,CAACC,YAAY,CAAC,CAAC,CAAC,GAAGjB,IAAI;QAEpF;MAED;MAEA,SAASY,qBAAqBA,CAACtD,GAAG,EAAE;QAEnC,MAAM0C,IAAI,GAAG;UACZkB,MAAM,EAAE,CAAC;QACV,CAAC;QAED,KAAK,IAAIxD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,OAAO;cACX,MAAM4C,EAAE,GAAGjC,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC,CAAC;cAChD,MAAM2B,QAAQ,GAAGtD,KAAK,CAAC2B,YAAY,CAAC,UAAU,CAAC;cAC/CQ,IAAI,CAACkB,MAAM,CAACC,QAAQ,CAAC,GAAGT,EAAE;cAC1B;UAEF;QAED;QAEA,OAAOV,IAAI;MAEZ;MAEA,SAASa,qBAAqBA,CAACvD,GAAG,EAAE;QAEnC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QACf,MAAMoB,MAAM,GAAG9D,GAAG,CAACkC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC;;QAE3C,IAAIvB,KAAK,GAAGmD,MAAM,CAACjD,KAAK,CAAC,GAAG,CAAC;QAC7B,MAAMuC,EAAE,GAAGzC,KAAK,CAACoD,KAAK,CAAC,CAAC;QACxB,IAAIC,GAAG,GAAGrD,KAAK,CAACoD,KAAK,CAAC,CAAC,CAAC,CAAC;;QAEzB,MAAME,WAAW,GAAGD,GAAG,CAACE,OAAO,CAAC,GAAG,CAAC,KAAK,CAAE,CAAC;QAC5C,MAAMC,YAAY,GAAGH,GAAG,CAACE,OAAO,CAAC,GAAG,CAAC,KAAK,CAAE,CAAC;QAE7C,IAAIC,YAAY,EAAE;UAEjB;UACAxD,KAAK,GAAGqD,GAAG,CAACnD,KAAK,CAAC,GAAG,CAAC;UACtBmD,GAAG,GAAGrD,KAAK,CAACoD,KAAK,CAAC,CAAC;UACnBrB,IAAI,CAAC0B,MAAM,GAAGzD,KAAK,CAACoD,KAAK,CAAC,CAAC;QAE5B,CAAC,MAAM,IAAIE,WAAW,EAAE;UAEvB;UACA,MAAMI,OAAO,GAAGL,GAAG,CAACnD,KAAK,CAAC,GAAG,CAAC;UAC9BmD,GAAG,GAAGK,OAAO,CAACN,KAAK,CAAC,CAAC;UAErB,KAAK,IAAI3D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiE,OAAO,CAAC/D,MAAM,EAAEF,CAAC,EAAE,EAAE;YAExCiE,OAAO,CAACjE,CAAC,CAAC,GAAGc,QAAQ,CAACmD,OAAO,CAACjE,CAAC,CAAC,CAACkE,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;UAEpD;UAEA5B,IAAI,CAAC2B,OAAO,GAAGA,OAAO;QAEvB;QAEA3B,IAAI,CAACU,EAAE,GAAGA,EAAE;QACZV,IAAI,CAACsB,GAAG,GAAGA,GAAG;QACdtB,IAAI,CAACuB,WAAW,GAAGA,WAAW;QAC9BvB,IAAI,CAACyB,YAAY,GAAGA,YAAY;QAChCzB,IAAI,CAAC6B,OAAO,GAAGpD,OAAO,CAACnB,GAAG,CAACkC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAClD,OAAOQ,IAAI;MAEZ;MAEA,SAAS8B,cAAcA,CAAC9B,IAAI,EAAE;QAE7B,MAAM+B,MAAM,GAAG,EAAE;QACjB,MAAMxB,QAAQ,GAAGP,IAAI,CAACO,QAAQ;QAC9B,MAAMD,QAAQ,GAAGN,IAAI,CAACM,QAAQ;QAC9B,MAAMD,OAAO,GAAGL,IAAI,CAACK,OAAO;QAE5B,KAAK,MAAMe,MAAM,IAAIb,QAAQ,EAAE;UAE9B,IAAIA,QAAQ,CAACyB,cAAc,CAACZ,MAAM,CAAC,EAAE;YAEpC,MAAMa,OAAO,GAAG1B,QAAQ,CAACa,MAAM,CAAC;YAChC,MAAMS,OAAO,GAAGvB,QAAQ,CAAC2B,OAAO,CAACJ,OAAO,CAAC;YACzC,MAAMK,OAAO,GAAGL,OAAO,CAACX,MAAM,CAACiB,KAAK;YACpC,MAAMC,QAAQ,GAAGP,OAAO,CAACX,MAAM,CAACmB,MAAM;YACtC,MAAMC,WAAW,GAAGjC,OAAO,CAAC6B,OAAO,CAAC;YACpC,MAAMK,YAAY,GAAGlC,OAAO,CAAC+B,QAAQ,CAAC;YACtC,MAAMI,SAAS,GAAGC,qBAAqB,CAACR,OAAO,EAAEK,WAAW,EAAEC,YAAY,CAAC;YAC3EG,oBAAoB,CAACF,SAAS,EAAET,MAAM,CAAC;UAExC;QAED;QAEA,OAAOA,MAAM;MAEd;MAEA,SAASY,YAAYA,CAACjC,EAAE,EAAE;QAEzB,OAAOP,QAAQ,CAACN,OAAO,CAACkB,UAAU,CAACL,EAAE,CAAC,EAAEoB,cAAc,CAAC;MAExD;MAEA,SAASW,qBAAqBA,CAACR,OAAO,EAAEK,WAAW,EAAEC,YAAY,EAAE;QAElE,MAAMK,IAAI,GAAG/C,OAAO,CAACgD,KAAK,CAACZ,OAAO,CAACvB,EAAE,CAAC;QACtC,MAAMoC,QAAQ,GAAGC,OAAO,CAACH,IAAI,CAAClC,EAAE,CAAC;QACjC,MAAMsC,SAAS,GAAGJ,IAAI,CAACK,UAAU,CAAChB,OAAO,CAACX,GAAG,CAAC;QAC9C,MAAM4B,aAAa,GAAGN,IAAI,CAACO,MAAM,CAACC,KAAK,CAAC,CAAC,CAACC,SAAS,CAAC,CAAC;QACrD,IAAIC,IAAI,EAAEC,MAAM;QAChB,IAAI7F,CAAC,EAAE8F,EAAE,EAAEC,CAAC,EAAEC,EAAE;QAChB,MAAM1D,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;QACjB;;QAEA,QAAQgD,SAAS;UAEhB,KAAK,QAAQ;YACZ,KAAKtF,CAAC,GAAG,CAAC,EAAE8F,EAAE,GAAGlB,WAAW,CAAC9E,KAAK,CAACI,MAAM,EAAEF,CAAC,GAAG8F,EAAE,EAAE9F,CAAC,EAAE,EAAE;cAEvD4F,IAAI,GAAGhB,WAAW,CAAC9E,KAAK,CAACE,CAAC,CAAC;cAC3B6F,MAAM,GAAG7F,CAAC,GAAG6E,YAAY,CAACgB,MAAM;cAChC,IAAIvD,IAAI,CAACsD,IAAI,CAAC,KAAKhE,SAAS,EAAEU,IAAI,CAACsD,IAAI,CAAC,GAAG,CAAC,CAAC;cAE7C,IAAIrB,OAAO,CAACV,WAAW,KAAK,IAAI,EAAE;gBAEjC,MAAMoC,KAAK,GAAGpB,YAAY,CAAC/E,KAAK,CAAC+F,MAAM,CAAC;gBACxC,MAAMK,KAAK,GAAG3B,OAAO,CAACN,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,GAAGM,OAAO,CAACN,OAAO,CAAC,CAAC,CAAC;gBACzD3B,IAAI,CAACsD,IAAI,CAAC,CAACM,KAAK,CAAC,GAAGD,KAAK;cAE1B,CAAC,MAAM;gBAEN,KAAKF,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGnB,YAAY,CAACgB,MAAM,EAAEE,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;kBAElDzD,IAAI,CAACsD,IAAI,CAAC,CAACG,CAAC,CAAC,GAAGlB,YAAY,CAAC/E,KAAK,CAAC+F,MAAM,GAAGE,CAAC,CAAC;gBAE/C;cAED;YAED;YAEA;UAED,KAAK,WAAW;YACfvG,OAAO,CAAC2G,IAAI,CAAC,yEAAyE,EAAEb,SAAS,CAAC;YAClG;UAED,KAAK,QAAQ;YACZ9F,OAAO,CAAC2G,IAAI,CAAC,yEAAyE,EAAEb,SAAS,CAAC;YAClG;UAED,KAAK,OAAO;YACX9F,OAAO,CAAC2G,IAAI,CAAC,yEAAyE,EAAEb,SAAS,CAAC;YAClG;QAEF;QAEA,MAAMc,SAAS,GAAGC,oBAAoB,CAAC/D,IAAI,EAAEkD,aAAa,CAAC;QAC3D,MAAMV,SAAS,GAAG;UACjBjF,IAAI,EAAEuF,QAAQ,CAACkB,IAAI;UACnBF,SAAS,EAAEA;QACZ,CAAC;QACD,OAAOtB,SAAS;MAEjB;MAEA,SAASuB,oBAAoBA,CAAC/D,IAAI,EAAEkD,aAAa,EAAE;QAElD,MAAMY,SAAS,GAAG,EAAE,CAAC,CAAC;;QAEtB,KAAK,MAAMR,IAAI,IAAItD,IAAI,EAAE;UAExB8D,SAAS,CAAC/F,IAAI,CAAC;YACduF,IAAI,EAAEhF,UAAU,CAACgF,IAAI,CAAC;YACtBK,KAAK,EAAE3D,IAAI,CAACsD,IAAI;UACjB,CAAC,CAAC;QAEH,CAAC,CAAC;;QAGFQ,SAAS,CAACG,IAAI,CAACC,SAAS,CAAC,CAAC,CAAC;;QAE3B,KAAK,IAAIxG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;UAE5ByG,sBAAsB,CAACL,SAAS,EAAEpG,CAAC,EAAEwF,aAAa,CAACpD,QAAQ,CAACpC,CAAC,CAAC,CAAC;QAEhE;QAEA,OAAOoG,SAAS,CAAC,CAAC;;QAElB,SAASI,SAASA,CAACE,CAAC,EAAEC,CAAC,EAAE;UAExB,OAAOD,CAAC,CAACd,IAAI,GAAGe,CAAC,CAACf,IAAI;QAEvB;MAED;MAEA,MAAMgB,QAAQ,GAAG,IAAI7I,KAAK,CAAC8I,OAAO,CAAC,CAAC;MACpC,MAAMC,KAAK,GAAG,IAAI/I,KAAK,CAAC8I,OAAO,CAAC,CAAC;MACjC,MAAME,UAAU,GAAG,IAAIhJ,KAAK,CAACiJ,UAAU,CAAC,CAAC;MAEzC,SAAShC,oBAAoBA,CAACF,SAAS,EAAET,MAAM,EAAE;QAEhD,MAAM+B,SAAS,GAAGtB,SAAS,CAACsB,SAAS;QACrC,MAAMvG,IAAI,GAAGiF,SAAS,CAACjF,IAAI;QAC3B,MAAMoH,KAAK,GAAG,EAAE;QAChB,MAAMC,YAAY,GAAG,EAAE;QACvB,MAAMC,cAAc,GAAG,EAAE;QACzB,MAAMC,SAAS,GAAG,EAAE;QAEpB,KAAK,IAAIpH,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGmG,SAAS,CAAClG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEjD,MAAMqH,QAAQ,GAAGjB,SAAS,CAACpG,CAAC,CAAC;UAC7B,MAAM4F,IAAI,GAAGyB,QAAQ,CAACzB,IAAI;UAC1B,MAAMK,KAAK,GAAGoB,QAAQ,CAACpB,KAAK;UAC5BR,MAAM,CAAC6B,SAAS,CAACrB,KAAK,CAAC,CAACN,SAAS,CAAC,CAAC;UACnCF,MAAM,CAAC8B,SAAS,CAACX,QAAQ,EAAEG,UAAU,EAAED,KAAK,CAAC;UAC7CG,KAAK,CAAC5G,IAAI,CAACuF,IAAI,CAAC;UAChBsB,YAAY,CAAC7G,IAAI,CAACuG,QAAQ,CAACY,CAAC,EAAEZ,QAAQ,CAACa,CAAC,EAAEb,QAAQ,CAACc,CAAC,CAAC;UACrDP,cAAc,CAAC9G,IAAI,CAAC0G,UAAU,CAACS,CAAC,EAAET,UAAU,CAACU,CAAC,EAAEV,UAAU,CAACW,CAAC,EAAEX,UAAU,CAACY,CAAC,CAAC;UAC3EP,SAAS,CAAC/G,IAAI,CAACyG,KAAK,CAACU,CAAC,EAAEV,KAAK,CAACW,CAAC,EAAEX,KAAK,CAACY,CAAC,CAAC;QAE1C;QAEA,IAAIR,YAAY,CAAChH,MAAM,GAAG,CAAC,EAAEmE,MAAM,CAAChE,IAAI,CAAC,IAAItC,KAAK,CAAC6J,mBAAmB,CAAC/H,IAAI,GAAG,WAAW,EAAEoH,KAAK,EAAEC,YAAY,CAAC,CAAC;QAChH,IAAIC,cAAc,CAACjH,MAAM,GAAG,CAAC,EAAEmE,MAAM,CAAChE,IAAI,CAAC,IAAItC,KAAK,CAAC8J,uBAAuB,CAAChI,IAAI,GAAG,aAAa,EAAEoH,KAAK,EAAEE,cAAc,CAAC,CAAC;QAC1H,IAAIC,SAAS,CAAClH,MAAM,GAAG,CAAC,EAAEmE,MAAM,CAAChE,IAAI,CAAC,IAAItC,KAAK,CAAC6J,mBAAmB,CAAC/H,IAAI,GAAG,QAAQ,EAAEoH,KAAK,EAAEG,SAAS,CAAC,CAAC;QACvG,OAAO/C,MAAM;MAEd;MAEA,SAASoC,sBAAsBA,CAACL,SAAS,EAAE0B,QAAQ,EAAEC,YAAY,EAAE;QAElE,IAAIV,QAAQ;QACZ,IAAIW,KAAK,GAAG,IAAI;QAChB,IAAIhI,CAAC,EAAEC,CAAC,CAAC,CAAC;;QAEV,KAAKD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGmG,SAAS,CAAClG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAE7CqH,QAAQ,GAAGjB,SAAS,CAACpG,CAAC,CAAC;UAEvB,IAAIqH,QAAQ,CAACpB,KAAK,CAAC6B,QAAQ,CAAC,KAAKlG,SAAS,EAAE;YAE3CyF,QAAQ,CAACpB,KAAK,CAAC6B,QAAQ,CAAC,GAAG,IAAI,CAAC,CAAC;UAElC,CAAC,MAAM;YAENE,KAAK,GAAG,KAAK;UAEd;QAED;QAEA,IAAIA,KAAK,KAAK,IAAI,EAAE;UAEnB;UACA,KAAKhI,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGmG,SAAS,CAAClG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;YAE7CqH,QAAQ,GAAGjB,SAAS,CAACpG,CAAC,CAAC;YACvBqH,QAAQ,CAACpB,KAAK,CAAC6B,QAAQ,CAAC,GAAGC,YAAY;UAExC;QAED,CAAC,MAAM;UAEN;UACAE,sBAAsB,CAAC7B,SAAS,EAAE0B,QAAQ,CAAC;QAE5C;MAED;MAEA,SAASG,sBAAsBA,CAAC7B,SAAS,EAAE0B,QAAQ,EAAE;QAEpD,IAAII,IAAI,EAAEC,IAAI;QAEd,KAAK,IAAInI,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGmG,SAAS,CAAClG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEjD,MAAMqH,QAAQ,GAAGjB,SAAS,CAACpG,CAAC,CAAC;UAE7B,IAAIqH,QAAQ,CAACpB,KAAK,CAAC6B,QAAQ,CAAC,KAAK,IAAI,EAAE;YAEtCI,IAAI,GAAGE,OAAO,CAAChC,SAAS,EAAEpG,CAAC,EAAE8H,QAAQ,CAAC;YACtCK,IAAI,GAAGE,OAAO,CAACjC,SAAS,EAAEpG,CAAC,EAAE8H,QAAQ,CAAC;YAEtC,IAAII,IAAI,KAAK,IAAI,EAAE;cAElBb,QAAQ,CAACpB,KAAK,CAAC6B,QAAQ,CAAC,GAAGK,IAAI,CAAClC,KAAK,CAAC6B,QAAQ,CAAC;cAC/C;YAED;YAEA,IAAIK,IAAI,KAAK,IAAI,EAAE;cAElBd,QAAQ,CAACpB,KAAK,CAAC6B,QAAQ,CAAC,GAAGI,IAAI,CAACjC,KAAK,CAAC6B,QAAQ,CAAC;cAC/C;YAED;YAEAQ,WAAW,CAACjB,QAAQ,EAAEa,IAAI,EAAEC,IAAI,EAAEL,QAAQ,CAAC;UAE5C;QAED;MAED;MAEA,SAASM,OAAOA,CAAChC,SAAS,EAAEpG,CAAC,EAAE8H,QAAQ,EAAE;QAExC,OAAO9H,CAAC,IAAI,CAAC,EAAE;UAEd,MAAMqH,QAAQ,GAAGjB,SAAS,CAACpG,CAAC,CAAC;UAC7B,IAAIqH,QAAQ,CAACpB,KAAK,CAAC6B,QAAQ,CAAC,KAAK,IAAI,EAAE,OAAOT,QAAQ;UACtDrH,CAAC,EAAE;QAEJ;QAEA,OAAO,IAAI;MAEZ;MAEA,SAASqI,OAAOA,CAACjC,SAAS,EAAEpG,CAAC,EAAE8H,QAAQ,EAAE;QAExC,OAAO9H,CAAC,GAAGoG,SAAS,CAAClG,MAAM,EAAE;UAE5B,MAAMmH,QAAQ,GAAGjB,SAAS,CAACpG,CAAC,CAAC;UAC7B,IAAIqH,QAAQ,CAACpB,KAAK,CAAC6B,QAAQ,CAAC,KAAK,IAAI,EAAE,OAAOT,QAAQ;UACtDrH,CAAC,EAAE;QAEJ;QAEA,OAAO,IAAI;MAEZ;MAEA,SAASsI,WAAWA,CAACC,GAAG,EAAEL,IAAI,EAAEC,IAAI,EAAEL,QAAQ,EAAE;QAE/C,IAAIK,IAAI,CAACvC,IAAI,GAAGsC,IAAI,CAACtC,IAAI,KAAK,CAAC,EAAE;UAEhC2C,GAAG,CAACtC,KAAK,CAAC6B,QAAQ,CAAC,GAAGI,IAAI,CAACjC,KAAK,CAAC6B,QAAQ,CAAC;UAC1C;QAED;QAEAS,GAAG,CAACtC,KAAK,CAAC6B,QAAQ,CAAC,GAAG,CAACS,GAAG,CAAC3C,IAAI,GAAGsC,IAAI,CAACtC,IAAI,KAAKuC,IAAI,CAAClC,KAAK,CAAC6B,QAAQ,CAAC,GAAGI,IAAI,CAACjC,KAAK,CAAC6B,QAAQ,CAAC,CAAC,IAAIK,IAAI,CAACvC,IAAI,GAAGsC,IAAI,CAACtC,IAAI,CAAC,GAAGsC,IAAI,CAACjC,KAAK,CAAC6B,QAAQ,CAAC;MAE9I,CAAC,CAAC;;MAGF,SAASU,kBAAkBA,CAAC5I,GAAG,EAAE;QAEhC,MAAM0C,IAAI,GAAG;UACZzC,IAAI,EAAED,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,IAAI,SAAS;UACzC2G,KAAK,EAAE7H,UAAU,CAAChB,GAAG,CAACkC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;UACjD4G,GAAG,EAAE9H,UAAU,CAAChB,GAAG,CAACkC,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;UAC7CuB,UAAU,EAAE;QACb,CAAC;QAED,KAAK,IAAIrD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,oBAAoB;cACxBkC,IAAI,CAACe,UAAU,CAAChD,IAAI,CAACU,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;cACxD;UAEF;QAED;QAEAK,OAAO,CAACwG,KAAK,CAAC/I,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAE7C;MAEA,SAASsG,kBAAkBA,CAACtG,IAAI,EAAE;QAEjC,MAAM+B,MAAM,GAAG,EAAE;QACjB,MAAMxE,IAAI,GAAGyC,IAAI,CAACzC,IAAI;QACtB,MAAMgJ,QAAQ,GAAGvG,IAAI,CAACoG,GAAG,GAAGpG,IAAI,CAACmG,KAAK,IAAI,CAAE,CAAC;QAC7C,MAAMpF,UAAU,GAAGf,IAAI,CAACe,UAAU;QAElC,KAAK,IAAIrD,CAAC,GAAG,CAAC,EAAE8F,EAAE,GAAGzC,UAAU,CAACnD,MAAM,EAAEF,CAAC,GAAG8F,EAAE,EAAE9F,CAAC,EAAE,EAAE;UAEpD,MAAM8I,eAAe,GAAG7D,YAAY,CAAC5B,UAAU,CAACrD,CAAC,CAAC,CAAC;UAEnD,KAAK,IAAI+F,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG8C,eAAe,CAAC5I,MAAM,EAAE6F,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;YAEzD1B,MAAM,CAAChE,IAAI,CAACyI,eAAe,CAAC/C,CAAC,CAAC,CAAC;UAEhC;QAED;QAEA,OAAO,IAAIhI,KAAK,CAACgL,aAAa,CAAClJ,IAAI,EAAEgJ,QAAQ,EAAExE,MAAM,CAAC;MAEvD;MAEA,SAAS2E,gBAAgBA,CAAChG,EAAE,EAAE;QAE7B,OAAOP,QAAQ,CAACN,OAAO,CAACwG,KAAK,CAAC3F,EAAE,CAAC,EAAE4F,kBAAkB,CAAC;MAEvD,CAAC,CAAC;;MAGF,SAASK,eAAeA,CAACrJ,GAAG,EAAE;QAE7B,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,MAAM;cACV;cACAkC,IAAI,CAACU,EAAE,GAAGjC,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC,CAAC;cAC/CQ,IAAI,CAAC4G,IAAI,GAAGC,SAAS,CAAChJ,KAAK,CAAC;cAC5B;YAED,KAAK,OAAO;cACXmC,IAAI,CAACU,EAAE,GAAGjC,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC,CAAC;cAC/CtC,OAAO,CAAC2G,IAAI,CAAC,gEAAgE,CAAC;cAC9E;UAEF;QAED;QAEAhE,OAAO,CAACiH,WAAW,CAACxJ,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAEnD;MAEA,SAAS6G,SAASA,CAACvJ,GAAG,EAAE;QAEvB,MAAM0C,IAAI,GAAG;UACZK,OAAO,EAAE,CAAC;QACX,CAAC;QAED,KAAK,IAAI3C,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,mBAAmB;cACvBkC,IAAI,CAAC+G,eAAe,GAAG1I,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cACrD;YAED,KAAK,QAAQ;cACZ,MAAMiB,EAAE,GAAG7C,KAAK,CAAC2B,YAAY,CAAC,IAAI,CAAC;cACnCQ,IAAI,CAACK,OAAO,CAACK,EAAE,CAAC,GAAGC,WAAW,CAAC9C,KAAK,CAAC;cACrC;YAED,KAAK,QAAQ;cACZmC,IAAI,CAACgH,MAAM,GAAGC,WAAW,CAACpJ,KAAK,CAAC;cAChC;YAED,KAAK,gBAAgB;cACpBmC,IAAI,CAACkH,aAAa,GAAGC,kBAAkB,CAACtJ,KAAK,CAAC;cAC9C;UAEF;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAASiH,WAAWA,CAAC3J,GAAG,EAAE;QAEzB,MAAM0C,IAAI,GAAG;UACZkB,MAAM,EAAE,CAAC;QACV,CAAC;QAED,KAAK,IAAIxD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,OAAO;cACX,MAAMqD,QAAQ,GAAGtD,KAAK,CAAC2B,YAAY,CAAC,UAAU,CAAC;cAC/C,MAAMkB,EAAE,GAAGjC,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC,CAAC;cAChDQ,IAAI,CAACkB,MAAM,CAACC,QAAQ,CAAC,GAAGT,EAAE;cAC1B;UAEF;QAED;QAEA,OAAOV,IAAI;MAEZ;MAEA,SAASmH,kBAAkBA,CAAC7J,GAAG,EAAE;QAEhC,MAAM0C,IAAI,GAAG;UACZkB,MAAM,EAAE,CAAC;QACV,CAAC;QAED,KAAK,IAAIxD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,OAAO;cACX,MAAMqD,QAAQ,GAAGtD,KAAK,CAAC2B,YAAY,CAAC,UAAU,CAAC;cAC/C,MAAMkB,EAAE,GAAGjC,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC,CAAC;cAChD,MAAM4H,MAAM,GAAG5I,QAAQ,CAACX,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC,CAAC;cACrDQ,IAAI,CAACkB,MAAM,CAACC,QAAQ,CAAC,GAAG;gBACvBT,EAAE,EAAEA,EAAE;gBACN0G,MAAM,EAAEA;cACT,CAAC;cACD;YAED,KAAK,QAAQ;cACZpH,IAAI,CAACqH,MAAM,GAAG9I,SAAS,CAACV,KAAK,CAAC4B,WAAW,CAAC;cAC1C;YAED,KAAK,GAAG;cACPO,IAAI,CAACsH,CAAC,GAAG/I,SAAS,CAACV,KAAK,CAAC4B,WAAW,CAAC;cACrC;UAEF;QAED;QAEA,OAAOO,IAAI;MAEZ;MAEA,SAASuH,eAAeA,CAACvH,IAAI,EAAE;QAE9B,MAAME,KAAK,GAAG;UACbQ,EAAE,EAAEV,IAAI,CAACU;QACV,CAAC;QACD,MAAM8G,QAAQ,GAAG3H,OAAO,CAAC4H,UAAU,CAACvH,KAAK,CAACQ,EAAE,CAAC;QAE7C,IAAIV,IAAI,CAAC4G,IAAI,KAAKtH,SAAS,EAAE;UAE5BY,KAAK,CAAC0G,IAAI,GAAGc,SAAS,CAAC1H,IAAI,CAAC4G,IAAI,CAAC,CAAC,CAAC;;UAEnCY,QAAQ,CAACnH,OAAO,CAACsH,WAAW,GAAGzH,KAAK,CAAC0G,IAAI,CAACjF,OAAO;UACjD6F,QAAQ,CAACnH,OAAO,CAACuH,WAAW,GAAG1H,KAAK,CAAC0G,IAAI,CAACiB,OAAO;QAElD;QAEA,OAAO3H,KAAK;MAEb;MAEA,SAASwH,SAASA,CAAC1H,IAAI,EAAE;QAExB,MAAM8H,UAAU,GAAG,CAAC;QACpB,MAAM5H,KAAK,GAAG;UACb8G,MAAM,EAAE,EAAE;UACV;UACArF,OAAO,EAAE;YACRnE,KAAK,EAAE,EAAE;YACT+F,MAAM,EAAEuE;UACT,CAAC;UACDD,OAAO,EAAE;YACRrK,KAAK,EAAE,EAAE;YACT+F,MAAM,EAAEuE;UACT;QACD,CAAC;QACD,MAAMzH,OAAO,GAAGL,IAAI,CAACK,OAAO;QAC5B,MAAM6G,aAAa,GAAGlH,IAAI,CAACkH,aAAa;QACxC,MAAMG,MAAM,GAAGH,aAAa,CAACG,MAAM;QACnC,MAAMC,CAAC,GAAGJ,aAAa,CAACI,CAAC;QACzB,MAAMS,WAAW,GAAGb,aAAa,CAAChG,MAAM,CAAC8G,KAAK,CAACZ,MAAM;QACrD,MAAMa,YAAY,GAAGf,aAAa,CAAChG,MAAM,CAACgH,MAAM,CAACd,MAAM;QACvD,MAAMe,WAAW,GAAGnI,IAAI,CAACK,OAAO,CAACL,IAAI,CAACgH,MAAM,CAAC9F,MAAM,CAAC8G,KAAK,CAAC;QAC1D,MAAMI,aAAa,GAAGpI,IAAI,CAACK,OAAO,CAACL,IAAI,CAACgH,MAAM,CAAC9F,MAAM,CAACmH,eAAe,CAAC;QACtE,MAAMR,OAAO,GAAGxH,OAAO,CAAC6G,aAAa,CAAChG,MAAM,CAACgH,MAAM,CAACxH,EAAE,CAAC,CAAClD,KAAK;QAC7D,IAAI+F,MAAM,GAAG,CAAC;QACd,IAAI7F,CAAC,EAAE+F,CAAC,EAAE9F,CAAC,CAAC,CAAC;;QAEb,KAAKD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG0J,MAAM,CAACzJ,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAE1C,MAAM4K,UAAU,GAAGjB,MAAM,CAAC3J,CAAC,CAAC,CAAC,CAAC;;UAE9B,MAAM6K,cAAc,GAAG,EAAE;UAEzB,KAAK9E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6E,UAAU,EAAE7E,CAAC,EAAE,EAAE;YAEhC,MAAM+E,SAAS,GAAGlB,CAAC,CAAC/D,MAAM,GAAGwE,WAAW,CAAC;YACzC,MAAMU,QAAQ,GAAGnB,CAAC,CAAC/D,MAAM,GAAG0E,YAAY,CAAC;YACzC,MAAMS,UAAU,GAAGb,OAAO,CAACY,QAAQ,CAAC;YACpCF,cAAc,CAACxK,IAAI,CAAC;cACnB6F,KAAK,EAAE4E,SAAS;cAChBG,MAAM,EAAED;YACT,CAAC,CAAC;YACFnF,MAAM,IAAI,CAAC;UAEZ,CAAC,CAAC;UACF;;UAGAgF,cAAc,CAACtE,IAAI,CAAC2E,UAAU,CAAC,CAAC,CAAC;UACjC;;UAEA,KAAKnF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqE,UAAU,EAAErE,CAAC,EAAE,EAAE;YAEhC,MAAMoF,CAAC,GAAGN,cAAc,CAAC9E,CAAC,CAAC;YAE3B,IAAIoF,CAAC,KAAKvJ,SAAS,EAAE;cAEpBY,KAAK,CAACyB,OAAO,CAACnE,KAAK,CAACO,IAAI,CAAC8K,CAAC,CAACjF,KAAK,CAAC;cACjC1D,KAAK,CAAC2H,OAAO,CAACrK,KAAK,CAACO,IAAI,CAAC8K,CAAC,CAACF,MAAM,CAAC;YAEnC,CAAC,MAAM;cAENzI,KAAK,CAACyB,OAAO,CAACnE,KAAK,CAACO,IAAI,CAAC,CAAC,CAAC;cAC3BmC,KAAK,CAAC2H,OAAO,CAACrK,KAAK,CAACO,IAAI,CAAC,CAAC,CAAC;YAE5B;UAED;QAED,CAAC,CAAC;;QAGF,IAAIiC,IAAI,CAAC+G,eAAe,EAAE;UAEzB7G,KAAK,CAAC4I,UAAU,GAAG,IAAIrN,KAAK,CAACsN,OAAO,CAAC,CAAC,CAAC/D,SAAS,CAAChF,IAAI,CAAC+G,eAAe,CAAC,CAAC1D,SAAS,CAAC,CAAC;QAEnF,CAAC,MAAM;UAENnD,KAAK,CAAC4I,UAAU,GAAG,IAAIrN,KAAK,CAACsN,OAAO,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC;QAElD,CAAC,CAAC;;QAGF,KAAKtL,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGwK,WAAW,CAAC3K,KAAK,CAACI,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAErD,MAAMH,IAAI,GAAG4K,WAAW,CAAC3K,KAAK,CAACE,CAAC,CAAC;UACjC,MAAMuL,WAAW,GAAG,IAAIxN,KAAK,CAACsN,OAAO,CAAC,CAAC,CAAC/D,SAAS,CAACoD,aAAa,CAAC5K,KAAK,EAAEE,CAAC,GAAG0K,aAAa,CAAC7E,MAAM,CAAC,CAACF,SAAS,CAAC,CAAC;UAC5GnD,KAAK,CAAC8G,MAAM,CAACjJ,IAAI,CAAC;YACjBR,IAAI,EAAEA,IAAI;YACV0L,WAAW,EAAEA;UACd,CAAC,CAAC;QAEH;QAEA,OAAO/I,KAAK,CAAC,CAAC;;QAEd,SAAS0I,UAAUA,CAACxE,CAAC,EAAEC,CAAC,EAAE;UAEzB,OAAOA,CAAC,CAACsE,MAAM,GAAGvE,CAAC,CAACuE,MAAM;QAE3B;MAED;MAEA,SAASO,aAAaA,CAACxI,EAAE,EAAE;QAE1B,OAAOP,QAAQ,CAACN,OAAO,CAACiH,WAAW,CAACpG,EAAE,CAAC,EAAE6G,eAAe,CAAC;MAE1D,CAAC,CAAC;;MAGF,SAAS4B,UAAUA,CAAC7L,GAAG,EAAE;QAExB,MAAM0C,IAAI,GAAG;UACZoJ,SAAS,EAAE/L,oBAAoB,CAACC,GAAG,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC,CAACmC;QACtD,CAAC;QACDI,OAAO,CAACwJ,MAAM,CAAC/L,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAE9C;MAEA,SAASsJ,UAAUA,CAACtJ,IAAI,EAAE;QAEzB,IAAIA,IAAI,CAACE,KAAK,KAAKZ,SAAS,EAAE,OAAOU,IAAI,CAACE,KAAK;QAC/C,OAAOF,IAAI,CAACoJ,SAAS;MAEtB;MAEA,SAASG,QAAQA,CAAC7I,EAAE,EAAE;QAErB,MAAMV,IAAI,GAAGH,OAAO,CAACwJ,MAAM,CAAC3I,EAAE,CAAC;QAE/B,IAAIV,IAAI,KAAKV,SAAS,EAAE;UAEvB,OAAOa,QAAQ,CAACH,IAAI,EAAEsJ,UAAU,CAAC;QAElC;QAEApM,OAAO,CAAC2G,IAAI,CAAC,oDAAoD,EAAEnD,EAAE,CAAC;QACtE,OAAO,IAAI;MAEZ,CAAC,CAAC;;MAGF,SAAS8I,WAAWA,CAAClM,GAAG,EAAE;QAEzB,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,gBAAgB;cACpBkC,IAAI,CAACyJ,OAAO,GAAGC,wBAAwB,CAAC7L,KAAK,CAAC;cAC9C;UAEF;QAED;QAEAgC,OAAO,CAAC8J,OAAO,CAACrM,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAE/C;MAEA,SAAS0J,wBAAwBA,CAACpM,GAAG,EAAE;QAEtC,MAAM0C,IAAI,GAAG;UACZ4J,QAAQ,EAAE,CAAC,CAAC;UACZtJ,QAAQ,EAAE,CAAC;QACZ,CAAC;QAED,KAAK,IAAI5C,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,UAAU;cACd+L,mBAAmB,CAAChM,KAAK,EAAEmC,IAAI,CAAC;cAChC;YAED,KAAK,WAAW;cACfA,IAAI,CAAC8J,SAAS,GAAGC,oBAAoB,CAAClM,KAAK,CAAC;cAC5C;YAED,KAAK,OAAO;cACXmC,IAAI,CAACgK,KAAK,GAAGC,gBAAgB,CAACpM,KAAK,CAAC;cACpC;UAEF;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAAS6J,mBAAmBA,CAACvM,GAAG,EAAE0C,IAAI,EAAE;QAEvC,MAAMsB,GAAG,GAAGhE,GAAG,CAACkC,YAAY,CAAC,KAAK,CAAC;QAEnC,KAAK,IAAI9B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,SAAS;cACbkC,IAAI,CAAC4J,QAAQ,CAACtI,GAAG,CAAC,GAAG4I,kBAAkB,CAACrM,KAAK,CAAC;cAC9C;YAED,KAAK,WAAW;cACfmC,IAAI,CAACM,QAAQ,CAACgB,GAAG,CAAC,GAAG6I,kBAAkB,CAACtM,KAAK,CAAC;cAC9C;UAEF;QAED;MAED;MAEA,SAASqM,kBAAkBA,CAAC5M,GAAG,EAAE;QAEhC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,WAAW;cACfkC,IAAI,CAACoJ,SAAS,GAAGvL,KAAK,CAAC4B,WAAW;cAClC;UAEF;QAED;QAEA,OAAOO,IAAI;MAEZ;MAEA,SAASmK,kBAAkBA,CAAC7M,GAAG,EAAE;QAEhC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,QAAQ;cACZkC,IAAI,CAACoK,MAAM,GAAGvM,KAAK,CAAC4B,WAAW;cAC/B;UAEF;QAED;QAEA,OAAOO,IAAI;MAEZ;MAEA,SAAS+J,oBAAoBA,CAACzM,GAAG,EAAE;QAElC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,UAAU;YACf,KAAK,SAAS;YACd,KAAK,OAAO;YACZ,KAAK,OAAO;cACXkC,IAAI,CAACqK,IAAI,GAAGxM,KAAK,CAACC,QAAQ;cAC1BkC,IAAI,CAACsK,UAAU,GAAGC,qBAAqB,CAAC1M,KAAK,CAAC;cAC9C;UAEF;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAASuK,qBAAqBA,CAACjN,GAAG,EAAE;QAEnC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,UAAU;YACf,KAAK,SAAS;YACd,KAAK,UAAU;YACf,KAAK,MAAM;YACX,KAAK,SAAS;YACd,KAAK,WAAW;YAChB,KAAK,cAAc;cAClBkC,IAAI,CAACnC,KAAK,CAACC,QAAQ,CAAC,GAAG0M,oBAAoB,CAAC3M,KAAK,CAAC;cAClD;YAED,KAAK,aAAa;cACjBmC,IAAI,CAACnC,KAAK,CAACC,QAAQ,CAAC,GAAG;gBACtB2M,MAAM,EAAE5M,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC;gBACpCQ,IAAI,EAAEwK,oBAAoB,CAAC3M,KAAK;cACjC,CAAC;cACD;UAEF;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAASwK,oBAAoBA,CAAClN,GAAG,EAAE;QAElC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,OAAO;cACXkC,IAAI,CAACnC,KAAK,CAACC,QAAQ,CAAC,GAAGO,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cACrD;YAED,KAAK,OAAO;cACXO,IAAI,CAACnC,KAAK,CAACC,QAAQ,CAAC,GAAGQ,UAAU,CAACT,KAAK,CAAC4B,WAAW,CAAC;cACpD;YAED,KAAK,SAAS;cACbO,IAAI,CAACnC,KAAK,CAACC,QAAQ,CAAC,GAAG;gBACtB4C,EAAE,EAAE7C,KAAK,CAAC2B,YAAY,CAAC,SAAS,CAAC;gBACjCwK,KAAK,EAAEU,2BAA2B,CAAC7M,KAAK;cACzC,CAAC;cACD;UAEF;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAAS0K,2BAA2BA,CAACpN,GAAG,EAAE;QAEzC,MAAM0C,IAAI,GAAG;UACZ8J,SAAS,EAAE,CAAC;QACb,CAAC;QAED,KAAK,IAAIpM,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,OAAO;cACX6M,gCAAgC,CAAC9M,KAAK,EAAEmC,IAAI,CAAC;cAC7C;UAEF;QAED;QAEA,OAAOA,IAAI;MAEZ;MAEA,SAAS2K,gCAAgCA,CAACrN,GAAG,EAAE0C,IAAI,EAAE;QAEpD,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,WAAW;cACf8M,yCAAyC,CAAC/M,KAAK,EAAEmC,IAAI,CAAC;cACtD;UAEF;QAED;MAED;MAEA,SAAS4K,yCAAyCA,CAACtN,GAAG,EAAE0C,IAAI,EAAE;QAE7D,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,SAAS;YACd,KAAK,SAAS;YACd,KAAK,SAAS;YACd,KAAK,SAAS;cACbkC,IAAI,CAAC8J,SAAS,CAACjM,KAAK,CAACC,QAAQ,CAAC,GAAGQ,UAAU,CAACT,KAAK,CAAC4B,WAAW,CAAC;cAC9D;YAED,KAAK,OAAO;YACZ,KAAK,OAAO;cACX;cACA,IAAI5B,KAAK,CAAC4B,WAAW,CAACoL,WAAW,CAAC,CAAC,KAAK,MAAM,EAAE;gBAE/C7K,IAAI,CAAC8J,SAAS,CAACjM,KAAK,CAACC,QAAQ,CAAC,GAAG,CAAC;cAEnC,CAAC,MAAM,IAAID,KAAK,CAAC4B,WAAW,CAACoL,WAAW,CAAC,CAAC,KAAK,OAAO,EAAE;gBAEvD7K,IAAI,CAAC8J,SAAS,CAACjM,KAAK,CAACC,QAAQ,CAAC,GAAG,CAAC;cAEnC,CAAC,MAAM;gBAENkC,IAAI,CAAC8J,SAAS,CAACjM,KAAK,CAACC,QAAQ,CAAC,GAAGU,QAAQ,CAACX,KAAK,CAAC4B,WAAW,CAAC;cAE7D;cAEA;UAEF;QAED;MAED;MAEA,SAASwK,gBAAgBA,CAAC3M,GAAG,EAAE;QAE9B,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,WAAW;cACfkC,IAAI,CAAC8J,SAAS,GAAGgB,yBAAyB,CAACjN,KAAK,CAAC;cACjD;UAEF;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAAS8K,yBAAyBA,CAACxN,GAAG,EAAE;QAEvC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,cAAc;cAClBkC,IAAI,CAACnC,KAAK,CAACC,QAAQ,CAAC,GAAGU,QAAQ,CAACX,KAAK,CAAC4B,WAAW,CAAC;cAClD;UAEF;QAED;QAEA,OAAOO,IAAI;MAEZ;MAEA,SAAS+K,WAAWA,CAAC/K,IAAI,EAAE;QAE1B,OAAOA,IAAI;MAEZ;MAEA,SAASgL,SAASA,CAACtK,EAAE,EAAE;QAEtB,OAAOP,QAAQ,CAACN,OAAO,CAAC8J,OAAO,CAACjJ,EAAE,CAAC,EAAEqK,WAAW,CAAC;MAElD,CAAC,CAAC;;MAGF,SAASE,aAAaA,CAAC3N,GAAG,EAAE;QAE3B,MAAM0C,IAAI,GAAG;UACZzC,IAAI,EAAED,GAAG,CAACkC,YAAY,CAAC,MAAM;QAC9B,CAAC;QAED,KAAK,IAAI9B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,iBAAiB;cACrBkC,IAAI,CAAChE,GAAG,GAAGyC,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC;cAC7C;UAEF;QAED;QAEAK,OAAO,CAACqL,SAAS,CAAC5N,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAEjD;MAEA,SAASmL,gBAAgBA,CAACC,KAAK,EAAE;QAEhC,IAAI5O,MAAM;QACV,IAAI6O,SAAS,GAAGD,KAAK,CAACE,KAAK,CAAC,CAACF,KAAK,CAACG,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;QAErEF,SAAS,GAAGA,SAAS,CAACG,WAAW,CAAC,CAAC;QAEnC,QAAQH,SAAS;UAEhB,KAAK,KAAK;YACT7O,MAAM,GAAGiP,SAAS;YAClB;UAED;YACCjP,MAAM,GAAGkP,aAAa;QAExB;QAEA,OAAOlP,MAAM;MAEd;MAEA,SAASmP,aAAaA,CAAC3L,IAAI,EAAE;QAE5B,MAAM4L,MAAM,GAAGZ,SAAS,CAAChL,IAAI,CAAChE,GAAG,CAAC;QAClC,MAAM8N,SAAS,GAAG8B,MAAM,CAACnC,OAAO,CAACK,SAAS;QAC1C,MAAME,KAAK,GAAG4B,MAAM,CAACnC,OAAO,CAACO,KAAK;QAClC,IAAI6B,QAAQ;QAEZ,QAAQ/B,SAAS,CAACO,IAAI;UAErB,KAAK,OAAO;UACZ,KAAK,OAAO;YACXwB,QAAQ,GAAG,IAAIpQ,KAAK,CAACqQ,iBAAiB,CAAC,CAAC;YACxC;UAED,KAAK,SAAS;YACbD,QAAQ,GAAG,IAAIpQ,KAAK,CAACsQ,mBAAmB,CAAC,CAAC;YAC1C;UAED;YACCF,QAAQ,GAAG,IAAIpQ,KAAK,CAACuQ,iBAAiB,CAAC,CAAC;YACxC;QAEF;QAEAH,QAAQ,CAACtO,IAAI,GAAGyC,IAAI,CAACzC,IAAI,IAAI,EAAE;QAE/B,SAAS0O,UAAUA,CAACC,aAAa,EAAE;UAElC,MAAMrK,OAAO,GAAG+J,MAAM,CAACnC,OAAO,CAACnJ,QAAQ,CAAC4L,aAAa,CAACxL,EAAE,CAAC;UACzD,IAAI0K,KAAK,GAAG,IAAI,CAAC,CAAC;;UAElB,IAAIvJ,OAAO,KAAKvC,SAAS,EAAE;YAE1B,MAAM6M,OAAO,GAAGP,MAAM,CAACnC,OAAO,CAACG,QAAQ,CAAC/H,OAAO,CAACuI,MAAM,CAAC;YACvDgB,KAAK,GAAG7B,QAAQ,CAAC4C,OAAO,CAAC/C,SAAS,CAAC;UAEpC,CAAC,MAAM;YAENlM,OAAO,CAAC2G,IAAI,CAAC,6EAA6E,CAAC;YAC3FuH,KAAK,GAAG7B,QAAQ,CAAC2C,aAAa,CAACxL,EAAE,CAAC;UAEnC,CAAC,CAAC;;UAGF,IAAI0K,KAAK,KAAK,IAAI,EAAE;YAEnB,MAAM5O,MAAM,GAAG2O,gBAAgB,CAACC,KAAK,CAAC;YAEtC,IAAI5O,MAAM,KAAK8C,SAAS,EAAE;cAEzB,MAAM8M,OAAO,GAAG5P,MAAM,CAACT,IAAI,CAACqP,KAAK,CAAC;cAClC,MAAMpB,KAAK,GAAGkC,aAAa,CAAClC,KAAK;cAEjC,IAAIA,KAAK,KAAK1K,SAAS,IAAI0K,KAAK,CAACF,SAAS,KAAKxK,SAAS,IAAIT,OAAO,CAACmL,KAAK,CAACF,SAAS,CAAC,KAAK,KAAK,EAAE;gBAE/F,MAAMA,SAAS,GAAGE,KAAK,CAACF,SAAS;gBACjCsC,OAAO,CAACC,KAAK,GAAGvC,SAAS,CAACwC,KAAK,GAAG7Q,KAAK,CAAC8Q,cAAc,GAAG9Q,KAAK,CAAC+Q,mBAAmB;gBAClFJ,OAAO,CAACK,KAAK,GAAG3C,SAAS,CAAC4C,KAAK,GAAGjR,KAAK,CAAC8Q,cAAc,GAAG9Q,KAAK,CAAC+Q,mBAAmB;gBAClFJ,OAAO,CAAChF,MAAM,CAACuF,GAAG,CAAC7C,SAAS,CAAC8C,OAAO,IAAI,CAAC,EAAE9C,SAAS,CAAC+C,OAAO,IAAI,CAAC,CAAC;gBAClET,OAAO,CAACU,MAAM,CAACH,GAAG,CAAC7C,SAAS,CAACiD,OAAO,IAAI,CAAC,EAAEjD,SAAS,CAACkD,OAAO,IAAI,CAAC,CAAC;cAEnE,CAAC,MAAM;gBAENZ,OAAO,CAACC,KAAK,GAAG5Q,KAAK,CAAC8Q,cAAc;gBACpCH,OAAO,CAACK,KAAK,GAAGhR,KAAK,CAAC8Q,cAAc;cAErC;cAEA,OAAOH,OAAO;YAEf,CAAC,MAAM;cAENlP,OAAO,CAAC2G,IAAI,CAAC,6DAA6D,EAAEuH,KAAK,CAAC;cAClF,OAAO,IAAI;YAEZ;UAED,CAAC,MAAM;YAENlO,OAAO,CAAC2G,IAAI,CAAC,wDAAwD,EAAEqI,aAAa,CAACxL,EAAE,CAAC;YACxF,OAAO,IAAI;UAEZ;QAED;QAEA,MAAM4J,UAAU,GAAGR,SAAS,CAACQ,UAAU;QAEvC,KAAK,MAAMrE,GAAG,IAAIqE,UAAU,EAAE;UAE7B,MAAM2C,SAAS,GAAG3C,UAAU,CAACrE,GAAG,CAAC;UAEjC,QAAQA,GAAG;YAEV,KAAK,SAAS;cACb,IAAIgH,SAAS,CAACC,KAAK,EAAErB,QAAQ,CAACqB,KAAK,CAAClI,SAAS,CAACiI,SAAS,CAACC,KAAK,CAAC;cAC9D,IAAID,SAAS,CAACb,OAAO,EAAEP,QAAQ,CAACsB,GAAG,GAAGlB,UAAU,CAACgB,SAAS,CAACb,OAAO,CAAC;cACnE;YAED,KAAK,UAAU;cACd,IAAIa,SAAS,CAACC,KAAK,IAAIrB,QAAQ,CAACuB,QAAQ,EAAEvB,QAAQ,CAACuB,QAAQ,CAACpI,SAAS,CAACiI,SAAS,CAACC,KAAK,CAAC;cACtF,IAAID,SAAS,CAACb,OAAO,EAAEP,QAAQ,CAACwB,WAAW,GAAGpB,UAAU,CAACgB,SAAS,CAACb,OAAO,CAAC;cAC3E;YAED,KAAK,MAAM;cACV,IAAIa,SAAS,CAACb,OAAO,EAAEP,QAAQ,CAACyB,SAAS,GAAGrB,UAAU,CAACgB,SAAS,CAACb,OAAO,CAAC;cACzE;YAED,KAAK,SAAS;cACb,IAAIa,SAAS,CAACb,OAAO,EAAEP,QAAQ,CAAC0B,QAAQ,GAAGtB,UAAU,CAACgB,SAAS,CAACb,OAAO,CAAC;cACxE;YAED,KAAK,WAAW;cACf,IAAIa,SAAS,CAACO,KAAK,IAAI3B,QAAQ,CAAC4B,SAAS,EAAE5B,QAAQ,CAAC4B,SAAS,GAAGR,SAAS,CAACO,KAAK;cAC/E;YAED,KAAK,UAAU;cACd,IAAIP,SAAS,CAACC,KAAK,IAAIrB,QAAQ,CAAC6B,QAAQ,EAAE7B,QAAQ,CAAC6B,QAAQ,CAAC1I,SAAS,CAACiI,SAAS,CAACC,KAAK,CAAC;cACtF,IAAID,SAAS,CAACb,OAAO,EAAEP,QAAQ,CAAC8B,WAAW,GAAG1B,UAAU,CAACgB,SAAS,CAACb,OAAO,CAAC;cAC3E;UAEF;QAED,CAAC,CAAC;;QAGF,IAAIwB,WAAW,GAAGtD,UAAU,CAAC,aAAa,CAAC;QAC3C,IAAIuD,YAAY,GAAGvD,UAAU,CAAC,cAAc,CAAC,CAAC,CAAC;;QAE/C,IAAIuD,YAAY,KAAKvO,SAAS,IAAIsO,WAAW,EAAE;UAE9CC,YAAY,GAAG;YACdL,KAAK,EAAE;UACR,CAAC;QAEF,CAAC,CAAC;;QAGF,IAAII,WAAW,KAAKtO,SAAS,IAAIuO,YAAY,EAAE;UAE9CD,WAAW,GAAG;YACbnD,MAAM,EAAE,OAAO;YACfzK,IAAI,EAAE;cACLkN,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;YACnB;UACD,CAAC;QAEF;QAEA,IAAIU,WAAW,IAAIC,YAAY,EAAE;UAEhC;UACA,IAAID,WAAW,CAAC5N,IAAI,CAACoM,OAAO,EAAE;YAE7B;YACAP,QAAQ,CAAC+B,WAAW,GAAG,IAAI;UAE5B,CAAC,MAAM;YAEN,MAAMV,KAAK,GAAGU,WAAW,CAAC5N,IAAI,CAACkN,KAAK;YAEpC,QAAQU,WAAW,CAACnD,MAAM;cAEzB,KAAK,OAAO;gBACXoB,QAAQ,CAACiC,OAAO,GAAGZ,KAAK,CAAC,CAAC,CAAC,GAAGW,YAAY,CAACL,KAAK;gBAChD;cAED,KAAK,UAAU;gBACd3B,QAAQ,CAACiC,OAAO,GAAG,CAAC,GAAGZ,KAAK,CAAC,CAAC,CAAC,GAAGW,YAAY,CAACL,KAAK;gBACpD;cAED,KAAK,QAAQ;gBACZ3B,QAAQ,CAACiC,OAAO,GAAG,CAAC,GAAGZ,KAAK,CAAC,CAAC,CAAC,GAAGW,YAAY,CAACL,KAAK;gBACpD;cAED,KAAK,SAAS;gBACb3B,QAAQ,CAACiC,OAAO,GAAGZ,KAAK,CAAC,CAAC,CAAC,GAAGW,YAAY,CAACL,KAAK;gBAChD;cAED;gBACCtQ,OAAO,CAAC2G,IAAI,CAAC,mEAAmE,EAAE+J,WAAW,CAACnD,MAAM,CAAC;YAEvG;YAEA,IAAIoB,QAAQ,CAACiC,OAAO,GAAG,CAAC,EAAEjC,QAAQ,CAAC+B,WAAW,GAAG,IAAI;UAEtD;QAED,CAAC,CAAC;;QAGF,IAAI5D,KAAK,KAAK1K,SAAS,IAAI0K,KAAK,CAACF,SAAS,KAAKxK,SAAS,IAAI0K,KAAK,CAACF,SAAS,CAACiE,YAAY,KAAK,CAAC,EAAE;UAE/FlC,QAAQ,CAACmC,IAAI,GAAGvS,KAAK,CAACwS,UAAU;QAEjC;QAEA,OAAOpC,QAAQ;MAEhB;MAEA,SAASqC,WAAWA,CAACxN,EAAE,EAAE;QAExB,OAAOP,QAAQ,CAACN,OAAO,CAACqL,SAAS,CAACxK,EAAE,CAAC,EAAEiL,aAAa,CAAC;MAEtD,CAAC,CAAC;;MAGF,SAASwC,WAAWA,CAAC7Q,GAAG,EAAE;QAEzB,MAAM0C,IAAI,GAAG;UACZzC,IAAI,EAAED,GAAG,CAACkC,YAAY,CAAC,MAAM;QAC9B,CAAC;QAED,KAAK,IAAI9B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,QAAQ;cACZkC,IAAI,CAACoO,MAAM,GAAGC,iBAAiB,CAACxQ,KAAK,CAAC;cACtC;UAEF;QAED;QAEAgC,OAAO,CAACyO,OAAO,CAAChR,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAE/C;MAEA,SAASqO,iBAAiBA,CAAC/Q,GAAG,EAAE;QAE/B,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAE/B,QAAQG,KAAK,CAACC,QAAQ;YAErB,KAAK,kBAAkB;cACtB,OAAOyQ,oBAAoB,CAAC1Q,KAAK,CAAC;UAEpC;QAED;QAEA,OAAO,CAAC,CAAC;MAEV;MAEA,SAAS0Q,oBAAoBA,CAACjR,GAAG,EAAE;QAElC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAE/B,QAAQG,KAAK,CAACC,QAAQ;YAErB,KAAK,aAAa;YAClB,KAAK,cAAc;cAClBkC,IAAI,CAAC8J,SAAS,GAAGjM,KAAK,CAACC,QAAQ;cAC/BkC,IAAI,CAACsK,UAAU,GAAGkE,qBAAqB,CAAC3Q,KAAK,CAAC;cAC9C;UAEF;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAASwO,qBAAqBA,CAAClR,GAAG,EAAE;QAEnC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAE/B,QAAQG,KAAK,CAACC,QAAQ;YAErB,KAAK,MAAM;YACX,KAAK,MAAM;YACX,KAAK,MAAM;YACX,KAAK,MAAM;YACX,KAAK,OAAO;YACZ,KAAK,MAAM;YACX,KAAK,cAAc;cAClBkC,IAAI,CAACnC,KAAK,CAACC,QAAQ,CAAC,GAAGQ,UAAU,CAACT,KAAK,CAAC4B,WAAW,CAAC;cACpD;UAEF;QAED;QAEA,OAAOO,IAAI;MAEZ;MAEA,SAASyO,WAAWA,CAACzO,IAAI,EAAE;QAE1B,IAAI0O,MAAM;QAEV,QAAQ1O,IAAI,CAACoO,MAAM,CAACtE,SAAS;UAE5B,KAAK,aAAa;YACjB4E,MAAM,GAAG,IAAIjT,KAAK,CAACkT,iBAAiB,CAAC3O,IAAI,CAACoO,MAAM,CAAC9D,UAAU,CAACsE,IAAI,EAAE5O,IAAI,CAACoO,MAAM,CAAC9D,UAAU,CAACuE,YAAY,EAAE7O,IAAI,CAACoO,MAAM,CAAC9D,UAAU,CAACwE,KAAK,EAAE9O,IAAI,CAACoO,MAAM,CAAC9D,UAAU,CAACyE,IAAI,CAAC;YACjK;UAED,KAAK,cAAc;YAClB,IAAIC,IAAI,GAAGhP,IAAI,CAACoO,MAAM,CAAC9D,UAAU,CAAC0E,IAAI;YACtC,IAAIC,IAAI,GAAGjP,IAAI,CAACoO,MAAM,CAAC9D,UAAU,CAAC2E,IAAI;YACtC,MAAMC,WAAW,GAAGlP,IAAI,CAACoO,MAAM,CAAC9D,UAAU,CAACuE,YAAY;YACvDI,IAAI,GAAGA,IAAI,KAAK3P,SAAS,GAAG0P,IAAI,GAAGE,WAAW,GAAGD,IAAI;YACrDD,IAAI,GAAGA,IAAI,KAAK1P,SAAS,GAAG2P,IAAI,GAAGC,WAAW,GAAGF,IAAI;YACrDC,IAAI,IAAI,GAAG;YACXD,IAAI,IAAI,GAAG;YACXN,MAAM,GAAG,IAAIjT,KAAK,CAAC0T,kBAAkB,CAAC,CAAEF,IAAI,EAAEA,IAAI,EAAED,IAAI,EAAE,CAAEA,IAAI;YAAE;YACjEhP,IAAI,CAACoO,MAAM,CAAC9D,UAAU,CAACwE,KAAK,EAAE9O,IAAI,CAACoO,MAAM,CAAC9D,UAAU,CAACyE,IAAI,CAAC;YAC3D;UAED;YACCL,MAAM,GAAG,IAAIjT,KAAK,CAACkT,iBAAiB,CAAC,CAAC;YACtC;QAEF;QAEAD,MAAM,CAACnR,IAAI,GAAGyC,IAAI,CAACzC,IAAI,IAAI,EAAE;QAC7B,OAAOmR,MAAM;MAEd;MAEA,SAASU,SAASA,CAAC1O,EAAE,EAAE;QAEtB,MAAMV,IAAI,GAAGH,OAAO,CAACyO,OAAO,CAAC5N,EAAE,CAAC;QAEhC,IAAIV,IAAI,KAAKV,SAAS,EAAE;UAEvB,OAAOa,QAAQ,CAACH,IAAI,EAAEyO,WAAW,CAAC;QAEnC;QAEAvR,OAAO,CAAC2G,IAAI,CAAC,qDAAqD,EAAEnD,EAAE,CAAC;QACvE,OAAO,IAAI;MAEZ,CAAC,CAAC;;MAGF,SAAS2O,UAAUA,CAAC/R,GAAG,EAAE;QAExB,IAAI0C,IAAI,GAAG,CAAC,CAAC;QAEb,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,kBAAkB;cACtBkC,IAAI,GAAGsP,mBAAmB,CAACzR,KAAK,CAAC;cACjC;UAEF;QAED;QAEAgC,OAAO,CAAC0P,MAAM,CAACjS,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAE9C;MAEA,SAASsP,mBAAmBA,CAAChS,GAAG,EAAE;QAEjC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,aAAa;YAClB,KAAK,OAAO;YACZ,KAAK,MAAM;YACX,KAAK,SAAS;cACbkC,IAAI,CAAC8J,SAAS,GAAGjM,KAAK,CAACC,QAAQ;cAC/BkC,IAAI,CAACsK,UAAU,GAAGkF,oBAAoB,CAAC3R,KAAK,CAAC;UAE/C;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAASwP,oBAAoBA,CAAClS,GAAG,EAAE;QAElC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,OAAO;cACX,MAAMN,KAAK,GAAGa,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cAC5CO,IAAI,CAACkN,KAAK,GAAG,IAAIzR,KAAK,CAACgU,KAAK,CAAC,CAAC,CAACzK,SAAS,CAACxH,KAAK,CAAC;cAC/C;YAED,KAAK,eAAe;cACnBwC,IAAI,CAAC0P,YAAY,GAAGpR,UAAU,CAACT,KAAK,CAAC4B,WAAW,CAAC;cACjD;YAED,KAAK,uBAAuB;cAC3B,MAAMkQ,CAAC,GAAGrR,UAAU,CAACT,KAAK,CAAC4B,WAAW,CAAC;cACvCO,IAAI,CAAC4P,QAAQ,GAAGD,CAAC,GAAGE,IAAI,CAACC,IAAI,CAAC,CAAC,GAAGH,CAAC,CAAC,GAAG,CAAC;cACxC;UAEF;QAED;QAEA,OAAO3P,IAAI;MAEZ;MAEA,SAAS+P,UAAUA,CAAC/P,IAAI,EAAE;QAEzB,IAAIgQ,KAAK;QAET,QAAQhQ,IAAI,CAAC8J,SAAS;UAErB,KAAK,aAAa;YACjBkG,KAAK,GAAG,IAAIvU,KAAK,CAACwU,gBAAgB,CAAC,CAAC;YACpC;UAED,KAAK,OAAO;YACXD,KAAK,GAAG,IAAIvU,KAAK,CAACyU,UAAU,CAAC,CAAC;YAC9B;UAED,KAAK,MAAM;YACVF,KAAK,GAAG,IAAIvU,KAAK,CAAC0U,SAAS,CAAC,CAAC;YAC7B;UAED,KAAK,SAAS;YACbH,KAAK,GAAG,IAAIvU,KAAK,CAAC2U,YAAY,CAAC,CAAC;YAChC;QAEF;QAEA,IAAIpQ,IAAI,CAACsK,UAAU,CAAC4C,KAAK,EAAE8C,KAAK,CAAC9C,KAAK,CAACmD,IAAI,CAACrQ,IAAI,CAACsK,UAAU,CAAC4C,KAAK,CAAC;QAClE,IAAIlN,IAAI,CAACsK,UAAU,CAACsF,QAAQ,EAAEI,KAAK,CAACJ,QAAQ,GAAG5P,IAAI,CAACsK,UAAU,CAACsF,QAAQ;QACvE,OAAOI,KAAK;MAEb;MAEA,SAASM,QAAQA,CAAC5P,EAAE,EAAE;QAErB,MAAMV,IAAI,GAAGH,OAAO,CAAC0P,MAAM,CAAC7O,EAAE,CAAC;QAE/B,IAAIV,IAAI,KAAKV,SAAS,EAAE;UAEvB,OAAOa,QAAQ,CAACH,IAAI,EAAE+P,UAAU,CAAC;QAElC;QAEA7S,OAAO,CAAC2G,IAAI,CAAC,oDAAoD,EAAEnD,EAAE,CAAC;QACtE,OAAO,IAAI;MAEZ,CAAC,CAAC;;MAGF,SAAS6P,aAAaA,CAACjT,GAAG,EAAE;QAE3B,MAAM0C,IAAI,GAAG;UACZzC,IAAI,EAAED,GAAG,CAACkC,YAAY,CAAC,MAAM,CAAC;UAC9Ba,OAAO,EAAE,CAAC,CAAC;UACXmQ,QAAQ,EAAE,CAAC,CAAC;UACZC,UAAU,EAAE;QACb,CAAC;QACD,MAAMC,IAAI,GAAGrT,oBAAoB,CAACC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;QAEnD,IAAIoT,IAAI,KAAKpR,SAAS,EAAE;QAExB,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgT,IAAI,CAACjT,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAEhD,MAAMG,KAAK,GAAG6S,IAAI,CAACjT,UAAU,CAACC,CAAC,CAAC;UAChC,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAC1B,MAAMC,EAAE,GAAG7C,KAAK,CAAC2B,YAAY,CAAC,IAAI,CAAC;UAEnC,QAAQ3B,KAAK,CAACC,QAAQ;YAErB,KAAK,QAAQ;cACZkC,IAAI,CAACK,OAAO,CAACK,EAAE,CAAC,GAAGC,WAAW,CAAC9C,KAAK,CAAC;cACrC;YAED,KAAK,UAAU;cACd;cACAmC,IAAI,CAACwQ,QAAQ,GAAGG,qBAAqB,CAAC9S,KAAK,CAAC;cAC5C;YAED,KAAK,UAAU;cACdX,OAAO,CAAC2G,IAAI,CAAC,mDAAmD,EAAEhG,KAAK,CAACC,QAAQ,CAAC;cACjF;YAED,KAAK,OAAO;YACZ,KAAK,YAAY;YACjB,KAAK,UAAU;YACf,KAAK,WAAW;cACfkC,IAAI,CAACyQ,UAAU,CAAC1S,IAAI,CAAC6S,sBAAsB,CAAC/S,KAAK,CAAC,CAAC;cACnD;YAED;cACCX,OAAO,CAAC4D,GAAG,CAACjD,KAAK,CAAC;UAEpB;QAED;QAEAgC,OAAO,CAAC4H,UAAU,CAACnK,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAElD;MAEA,SAASW,WAAWA,CAACrD,GAAG,EAAE;QAEzB,MAAM0C,IAAI,GAAG;UACZxC,KAAK,EAAE,EAAE;UACT+F,MAAM,EAAE;QACT,CAAC;QAED,KAAK,IAAI7F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,aAAa;cACjBkC,IAAI,CAACxC,KAAK,GAAGa,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cAC3C;YAED,KAAK,YAAY;cAChBO,IAAI,CAACxC,KAAK,GAAGQ,YAAY,CAACH,KAAK,CAAC4B,WAAW,CAAC;cAC5C;YAED,KAAK,kBAAkB;cACtB,MAAMoR,QAAQ,GAAGxT,oBAAoB,CAACQ,KAAK,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC;cAE3D,IAAIgT,QAAQ,KAAKvR,SAAS,EAAE;gBAE3BU,IAAI,CAACuD,MAAM,GAAG/E,QAAQ,CAACqS,QAAQ,CAACrR,YAAY,CAAC,QAAQ,CAAC,CAAC;cAExD;cAEA;UAEF;QAED;QAEA,OAAOQ,IAAI;MAEZ;MAEA,SAAS2Q,qBAAqBA,CAACrT,GAAG,EAAE;QAEnC,MAAM0C,IAAI,GAAG,CAAC,CAAC;QAEf,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAC1BT,IAAI,CAACnC,KAAK,CAAC2B,YAAY,CAAC,UAAU,CAAC,CAAC,GAAGf,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC,CAAC;QAE7E;QAEA,OAAOQ,IAAI;MAEZ;MAEA,SAAS4Q,sBAAsBA,CAACtT,GAAG,EAAE;QAEpC,MAAMwT,SAAS,GAAG;UACjBzG,IAAI,EAAE/M,GAAG,CAACQ,QAAQ;UAClB+N,QAAQ,EAAEvO,GAAG,CAACkC,YAAY,CAAC,UAAU,CAAC;UACtCZ,KAAK,EAAEJ,QAAQ,CAAClB,GAAG,CAACkC,YAAY,CAAC,OAAO,CAAC,CAAC;UAC1C0B,MAAM,EAAE,CAAC,CAAC;UACVqC,MAAM,EAAE,CAAC;UACTwN,KAAK,EAAE;QACR,CAAC;QAED,KAAK,IAAIrT,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGL,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,OAAO;cACX,MAAM4C,EAAE,GAAGjC,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC,CAAC;cAChD,MAAM2B,QAAQ,GAAGtD,KAAK,CAAC2B,YAAY,CAAC,UAAU,CAAC;cAC/C,MAAM4H,MAAM,GAAG5I,QAAQ,CAACX,KAAK,CAAC2B,YAAY,CAAC,QAAQ,CAAC,CAAC;cACrD,MAAMmN,GAAG,GAAGnO,QAAQ,CAACX,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC;cAC/C,MAAMwR,SAAS,GAAGrE,GAAG,GAAG,CAAC,GAAGxL,QAAQ,GAAGwL,GAAG,GAAGxL,QAAQ;cACrD2P,SAAS,CAAC5P,MAAM,CAAC8P,SAAS,CAAC,GAAG;gBAC7BtQ,EAAE,EAAEA,EAAE;gBACN0G,MAAM,EAAEA;cACT,CAAC;cACD0J,SAAS,CAACvN,MAAM,GAAGsM,IAAI,CAACoB,GAAG,CAACH,SAAS,CAACvN,MAAM,EAAE6D,MAAM,GAAG,CAAC,CAAC;cACzD,IAAIjG,QAAQ,KAAK,UAAU,EAAE2P,SAAS,CAACC,KAAK,GAAG,IAAI;cACnD;YAED,KAAK,QAAQ;cACZD,SAAS,CAACzJ,MAAM,GAAG9I,SAAS,CAACV,KAAK,CAAC4B,WAAW,CAAC;cAC/C;YAED,KAAK,GAAG;cACPqR,SAAS,CAACI,CAAC,GAAG3S,SAAS,CAACV,KAAK,CAAC4B,WAAW,CAAC;cAC1C;UAEF;QAED;QAEA,OAAOqR,SAAS;MAEjB;MAEA,SAASK,eAAeA,CAACV,UAAU,EAAE;QAEpC,MAAMvQ,KAAK,GAAG,CAAC,CAAC;QAEhB,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+S,UAAU,CAAC7S,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE3C,MAAMoT,SAAS,GAAGL,UAAU,CAAC/S,CAAC,CAAC;UAC/B,IAAIwC,KAAK,CAAC4Q,SAAS,CAACzG,IAAI,CAAC,KAAK/K,SAAS,EAAEY,KAAK,CAAC4Q,SAAS,CAACzG,IAAI,CAAC,GAAG,EAAE;UACnEnK,KAAK,CAAC4Q,SAAS,CAACzG,IAAI,CAAC,CAACtM,IAAI,CAAC+S,SAAS,CAAC;QAEtC;QAEA,OAAO5Q,KAAK;MAEb;MAEA,SAASkR,kBAAkBA,CAACX,UAAU,EAAE;QAEvC,IAAI7R,KAAK,GAAG,CAAC;QAEb,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG8S,UAAU,CAAC7S,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAElD,MAAMoT,SAAS,GAAGL,UAAU,CAAC/S,CAAC,CAAC;UAE/B,IAAIoT,SAAS,CAACC,KAAK,KAAK,IAAI,EAAE;YAE7BnS,KAAK,EAAE;UAER;QAED;QAEA,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG6R,UAAU,CAAC7S,MAAM,EAAE;UAE3C6S,UAAU,CAACY,WAAW,GAAG,IAAI;QAE9B;MAED;MAEA,SAASC,aAAaA,CAACtR,IAAI,EAAE;QAE5B,MAAME,KAAK,GAAG,CAAC,CAAC;QAChB,MAAMG,OAAO,GAAGL,IAAI,CAACK,OAAO;QAC5B,MAAMmQ,QAAQ,GAAGxQ,IAAI,CAACwQ,QAAQ;QAC9B,MAAMC,UAAU,GAAGzQ,IAAI,CAACyQ,UAAU;QAClC,IAAIA,UAAU,CAAC7S,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;QACxC;;QAEA,MAAM2T,iBAAiB,GAAGJ,eAAe,CAACV,UAAU,CAAC;QAErD,KAAK,MAAMpG,IAAI,IAAIkH,iBAAiB,EAAE;UAErC,MAAMC,aAAa,GAAGD,iBAAiB,CAAClH,IAAI,CAAC,CAAC,CAAC;;UAE/C+G,kBAAkB,CAACI,aAAa,CAAC,CAAC,CAAC;;UAEnCtR,KAAK,CAACmK,IAAI,CAAC,GAAGoH,iBAAiB,CAACD,aAAa,EAAEnR,OAAO,EAAEmQ,QAAQ,CAAC;QAElE;QAEA,OAAOtQ,KAAK;MAEb;MAEA,SAASuR,iBAAiBA,CAAChB,UAAU,EAAEpQ,OAAO,EAAEmQ,QAAQ,EAAE;QAEzD,MAAMtQ,KAAK,GAAG,CAAC,CAAC;QAChB,MAAMoE,QAAQ,GAAG;UAChB9G,KAAK,EAAE,EAAE;UACT+F,MAAM,EAAE;QACT,CAAC;QACD,MAAMmO,MAAM,GAAG;UACdlU,KAAK,EAAE,EAAE;UACT+F,MAAM,EAAE;QACT,CAAC;QACD,MAAMoO,EAAE,GAAG;UACVnU,KAAK,EAAE,EAAE;UACT+F,MAAM,EAAE;QACT,CAAC;QACD,MAAMqO,GAAG,GAAG;UACXpU,KAAK,EAAE,EAAE;UACT+F,MAAM,EAAE;QACT,CAAC;QACD,MAAM2J,KAAK,GAAG;UACb1P,KAAK,EAAE,EAAE;UACT+F,MAAM,EAAE;QACT,CAAC;QACD,MAAMiF,SAAS,GAAG;UACjBhL,KAAK,EAAE,EAAE;UACT+F,MAAM,EAAE;QACT,CAAC;QACD,MAAMmF,UAAU,GAAG;UAClBlL,KAAK,EAAE,EAAE;UACT+F,MAAM,EAAE;QACT,CAAC;QACD,MAAMiE,QAAQ,GAAG,IAAI/L,KAAK,CAACoW,cAAc,CAAC,CAAC;QAC3C,MAAMC,YAAY,GAAG,EAAE;QACvB,IAAI3L,KAAK,GAAG,CAAC;QAEb,KAAK,IAAI+K,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,UAAU,CAAC7S,MAAM,EAAEsT,CAAC,EAAE,EAAE;UAE3C,MAAMJ,SAAS,GAAGL,UAAU,CAACS,CAAC,CAAC;UAC/B,MAAMhQ,MAAM,GAAG4P,SAAS,CAAC5P,MAAM,CAAC,CAAC;;UAEjC,IAAItC,KAAK,GAAG,CAAC;UAEb,QAAQkS,SAAS,CAACzG,IAAI;YAErB,KAAK,OAAO;YACZ,KAAK,YAAY;cAChBzL,KAAK,GAAGkS,SAAS,CAAClS,KAAK,GAAG,CAAC;cAC3B;YAED,KAAK,WAAW;cACfA,KAAK,GAAGkS,SAAS,CAAClS,KAAK,GAAG,CAAC;cAC3B;YAED,KAAK,UAAU;cACd,KAAK,IAAImT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,SAAS,CAAClS,KAAK,EAAEmT,CAAC,EAAE,EAAE;gBAEzC,MAAMC,EAAE,GAAGlB,SAAS,CAACzJ,MAAM,CAAC0K,CAAC,CAAC;gBAE9B,QAAQC,EAAE;kBAET,KAAK,CAAC;oBACLpT,KAAK,IAAI,CAAC,CAAC,CAAC;;oBAEZ;kBAED,KAAK,CAAC;oBACLA,KAAK,IAAI,CAAC,CAAC,CAAC;;oBAEZ;kBAED;oBACCA,KAAK,IAAI,CAACoT,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;;oBAEvB;gBAEF;cAED;cAEA;YAED;cACC9U,OAAO,CAAC2G,IAAI,CAAC,6CAA6C,EAAEiN,SAAS,CAACzG,IAAI,CAAC;UAE7E;UAEA7C,QAAQ,CAACyK,QAAQ,CAAC9L,KAAK,EAAEvH,KAAK,EAAEsS,CAAC,CAAC;UAClC/K,KAAK,IAAIvH,KAAK,CAAC,CAAC;;UAEhB,IAAIkS,SAAS,CAACjF,QAAQ,EAAE;YAEvBiG,YAAY,CAAC/T,IAAI,CAAC+S,SAAS,CAACjF,QAAQ,CAAC;UAEtC,CAAC,CAAC;;UAGF,KAAK,MAAMtO,IAAI,IAAI2D,MAAM,EAAE;YAE1B,MAAMgR,KAAK,GAAGhR,MAAM,CAAC3D,IAAI,CAAC;YAE1B,QAAQA,IAAI;cAEX,KAAK,QAAQ;gBACZ,KAAK,MAAM0I,GAAG,IAAIuK,QAAQ,EAAE;kBAE3B,MAAM9P,EAAE,GAAG8P,QAAQ,CAACvK,GAAG,CAAC;kBAExB,QAAQA,GAAG;oBAEV,KAAK,UAAU;sBACd,MAAMkM,UAAU,GAAG7N,QAAQ,CAAC9G,KAAK,CAACI,MAAM;sBACxCwU,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAACK,EAAE,CAAC,EAAEwR,KAAK,CAAC9K,MAAM,EAAE9C,QAAQ,CAAC9G,KAAK,CAAC;sBACvE8G,QAAQ,CAACf,MAAM,GAAGlD,OAAO,CAACK,EAAE,CAAC,CAAC6C,MAAM;sBAEpC,IAAIlD,OAAO,CAACuH,WAAW,IAAIvH,OAAO,CAACsH,WAAW,EAAE;wBAE/CyK,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAACsH,WAAW,EAAEuK,KAAK,CAAC9K,MAAM,EAAEoB,SAAS,CAAChL,KAAK,CAAC;wBAChF4U,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAACuH,WAAW,EAAEsK,KAAK,CAAC9K,MAAM,EAAEsB,UAAU,CAAClL,KAAK,CAAC;sBAElF,CAAC,CAAC;;sBAGF,IAAIsT,SAAS,CAACC,KAAK,KAAK,KAAK,IAAIN,UAAU,CAACY,WAAW,KAAK,IAAI,EAAE;wBAEjE,MAAMzS,KAAK,GAAG,CAAC0F,QAAQ,CAAC9G,KAAK,CAACI,MAAM,GAAGuU,UAAU,IAAI7N,QAAQ,CAACf,MAAM;wBAEpE,KAAK,IAAI7F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,KAAK,EAAElB,CAAC,EAAE,EAAE;0BAE/B;0BACAiU,EAAE,CAACnU,KAAK,CAACO,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;wBAEpB;sBAED;sBAEA;oBAED,KAAK,QAAQ;sBACZqU,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAACK,EAAE,CAAC,EAAEwR,KAAK,CAAC9K,MAAM,EAAEsK,MAAM,CAAClU,KAAK,CAAC;sBACrEkU,MAAM,CAACnO,MAAM,GAAGlD,OAAO,CAACK,EAAE,CAAC,CAAC6C,MAAM;sBAClC;oBAED,KAAK,OAAO;sBACX6O,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAACK,EAAE,CAAC,EAAEwR,KAAK,CAAC9K,MAAM,EAAE8F,KAAK,CAAC1P,KAAK,CAAC;sBACpE0P,KAAK,CAAC3J,MAAM,GAAGlD,OAAO,CAACK,EAAE,CAAC,CAAC6C,MAAM;sBACjC;oBAED,KAAK,UAAU;sBACd6O,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAACK,EAAE,CAAC,EAAEwR,KAAK,CAAC9K,MAAM,EAAEuK,EAAE,CAACnU,KAAK,CAAC;sBACjEmU,EAAE,CAACpO,MAAM,GAAGlD,OAAO,CAACK,EAAE,CAAC,CAAC6C,MAAM;sBAC9B;oBAED,KAAK,WAAW;sBACf6O,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAACK,EAAE,CAAC,EAAEwR,KAAK,CAAC9K,MAAM,EAAEwK,GAAG,CAACpU,KAAK,CAAC;sBAClEmU,EAAE,CAACpO,MAAM,GAAGlD,OAAO,CAACK,EAAE,CAAC,CAAC6C,MAAM;sBAC9B;oBAED;sBACCrG,OAAO,CAAC2G,IAAI,CAAC,2EAA2E,EAAEoC,GAAG,CAAC;kBAEhG;gBAED;gBAEA;cAED,KAAK,QAAQ;gBACZmM,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAAC6R,KAAK,CAACxR,EAAE,CAAC,EAAEwR,KAAK,CAAC9K,MAAM,EAAEsK,MAAM,CAAClU,KAAK,CAAC;gBAC3EkU,MAAM,CAACnO,MAAM,GAAGlD,OAAO,CAAC6R,KAAK,CAACxR,EAAE,CAAC,CAAC6C,MAAM;gBACxC;cAED,KAAK,OAAO;gBACX6O,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAAC6R,KAAK,CAACxR,EAAE,CAAC,EAAEwR,KAAK,CAAC9K,MAAM,EAAE8F,KAAK,CAAC1P,KAAK,CAAC;gBAC1E0P,KAAK,CAAC3J,MAAM,GAAGlD,OAAO,CAAC6R,KAAK,CAACxR,EAAE,CAAC,CAAC6C,MAAM;gBACvC;cAED,KAAK,UAAU;gBACd6O,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAAC6R,KAAK,CAACxR,EAAE,CAAC,EAAEwR,KAAK,CAAC9K,MAAM,EAAEuK,EAAE,CAACnU,KAAK,CAAC;gBACvEmU,EAAE,CAACpO,MAAM,GAAGlD,OAAO,CAAC6R,KAAK,CAACxR,EAAE,CAAC,CAAC6C,MAAM;gBACpC;cAED,KAAK,WAAW;gBACf6O,iBAAiB,CAACtB,SAAS,EAAEzQ,OAAO,CAAC6R,KAAK,CAACxR,EAAE,CAAC,EAAEwR,KAAK,CAAC9K,MAAM,EAAEwK,GAAG,CAACpU,KAAK,CAAC;gBACxEoU,GAAG,CAACrO,MAAM,GAAGlD,OAAO,CAAC6R,KAAK,CAACxR,EAAE,CAAC,CAAC6C,MAAM;gBACrC;YAEF;UAED;QAED,CAAC,CAAC;;QAGF,IAAIe,QAAQ,CAAC9G,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE4J,QAAQ,CAAC6K,YAAY,CAAC,UAAU,EAAE,IAAI5W,KAAK,CAAC6W,sBAAsB,CAAChO,QAAQ,CAAC9G,KAAK,EAAE8G,QAAQ,CAACf,MAAM,CAAC,CAAC;QACnI,IAAImO,MAAM,CAAClU,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE4J,QAAQ,CAAC6K,YAAY,CAAC,QAAQ,EAAE,IAAI5W,KAAK,CAAC6W,sBAAsB,CAACZ,MAAM,CAAClU,KAAK,EAAEkU,MAAM,CAACnO,MAAM,CAAC,CAAC;QAC3H,IAAI2J,KAAK,CAAC1P,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE4J,QAAQ,CAAC6K,YAAY,CAAC,OAAO,EAAE,IAAI5W,KAAK,CAAC6W,sBAAsB,CAACpF,KAAK,CAAC1P,KAAK,EAAE0P,KAAK,CAAC3J,MAAM,CAAC,CAAC;QACvH,IAAIoO,EAAE,CAACnU,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE4J,QAAQ,CAAC6K,YAAY,CAAC,IAAI,EAAE,IAAI5W,KAAK,CAAC6W,sBAAsB,CAACX,EAAE,CAACnU,KAAK,EAAEmU,EAAE,CAACpO,MAAM,CAAC,CAAC;QAC3G,IAAIqO,GAAG,CAACpU,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE4J,QAAQ,CAAC6K,YAAY,CAAC,KAAK,EAAE,IAAI5W,KAAK,CAAC6W,sBAAsB,CAACV,GAAG,CAACpU,KAAK,EAAEoU,GAAG,CAACrO,MAAM,CAAC,CAAC;QAC/G,IAAIiF,SAAS,CAAChL,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE4J,QAAQ,CAAC6K,YAAY,CAAC,WAAW,EAAE,IAAI5W,KAAK,CAAC6W,sBAAsB,CAAC9J,SAAS,CAAChL,KAAK,EAAEgL,SAAS,CAACjF,MAAM,CAAC,CAAC;QACvI,IAAImF,UAAU,CAAClL,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE4J,QAAQ,CAAC6K,YAAY,CAAC,YAAY,EAAE,IAAI5W,KAAK,CAAC6W,sBAAsB,CAAC5J,UAAU,CAAClL,KAAK,EAAEkL,UAAU,CAACnF,MAAM,CAAC,CAAC;QAC3IrD,KAAK,CAACF,IAAI,GAAGwH,QAAQ;QACrBtH,KAAK,CAACmK,IAAI,GAAGoG,UAAU,CAAC,CAAC,CAAC,CAACpG,IAAI;QAC/BnK,KAAK,CAAC4R,YAAY,GAAGA,YAAY;QACjC,OAAO5R,KAAK;MAEb;MAEA,SAASkS,iBAAiBA,CAACtB,SAAS,EAAE1G,MAAM,EAAEhD,MAAM,EAAE5J,KAAK,EAAE;QAE5D,MAAMmE,OAAO,GAAGmP,SAAS,CAACI,CAAC;QAC3B,MAAM3N,MAAM,GAAGuN,SAAS,CAACvN,MAAM;QAC/B,MAAM8D,MAAM,GAAGyJ,SAAS,CAACzJ,MAAM;QAE/B,SAASkL,UAAUA,CAAC7U,CAAC,EAAE;UAEtB,IAAIkG,KAAK,GAAGjC,OAAO,CAACjE,CAAC,GAAG0J,MAAM,CAAC,GAAGoL,YAAY;UAC9C,MAAM5U,MAAM,GAAGgG,KAAK,GAAG4O,YAAY;UAEnC,OAAO5O,KAAK,GAAGhG,MAAM,EAAEgG,KAAK,EAAE,EAAE;YAE/BpG,KAAK,CAACO,IAAI,CAAC0U,WAAW,CAAC7O,KAAK,CAAC,CAAC;UAE/B;QAED;QAEA,MAAM6O,WAAW,GAAGrI,MAAM,CAAC5M,KAAK;QAChC,MAAMgV,YAAY,GAAGpI,MAAM,CAAC7G,MAAM;QAElC,IAAIuN,SAAS,CAACzJ,MAAM,KAAK/H,SAAS,EAAE;UAEnC,IAAIsE,KAAK,GAAG,CAAC;UAEb,KAAK,IAAIlG,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG0J,MAAM,CAACzJ,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;YAE9C,MAAMkB,KAAK,GAAGyI,MAAM,CAAC3J,CAAC,CAAC;YAEvB,IAAIkB,KAAK,KAAK,CAAC,EAAE;cAEhB,MAAMwF,CAAC,GAAGR,KAAK,GAAGL,MAAM,GAAG,CAAC;cAC5B,MAAMc,CAAC,GAAGT,KAAK,GAAGL,MAAM,GAAG,CAAC;cAC5B,MAAMmP,CAAC,GAAG9O,KAAK,GAAGL,MAAM,GAAG,CAAC;cAC5B,MAAMsF,CAAC,GAAGjF,KAAK,GAAGL,MAAM,GAAG,CAAC;cAC5BgP,UAAU,CAACnO,CAAC,CAAC;cACbmO,UAAU,CAAClO,CAAC,CAAC;cACbkO,UAAU,CAAC1J,CAAC,CAAC;cACb0J,UAAU,CAAClO,CAAC,CAAC;cACbkO,UAAU,CAACG,CAAC,CAAC;cACbH,UAAU,CAAC1J,CAAC,CAAC;YAEd,CAAC,MAAM,IAAIjK,KAAK,KAAK,CAAC,EAAE;cAEvB,MAAMwF,CAAC,GAAGR,KAAK,GAAGL,MAAM,GAAG,CAAC;cAC5B,MAAMc,CAAC,GAAGT,KAAK,GAAGL,MAAM,GAAG,CAAC;cAC5B,MAAMmP,CAAC,GAAG9O,KAAK,GAAGL,MAAM,GAAG,CAAC;cAC5BgP,UAAU,CAACnO,CAAC,CAAC;cACbmO,UAAU,CAAClO,CAAC,CAAC;cACbkO,UAAU,CAACG,CAAC,CAAC;YAEd,CAAC,MAAM,IAAI9T,KAAK,GAAG,CAAC,EAAE;cAErB,KAAK,IAAI+T,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGhU,KAAK,GAAG,CAAC,EAAE+T,CAAC,IAAIC,EAAE,EAAED,CAAC,EAAE,EAAE;gBAE7C,MAAMvO,CAAC,GAAGR,KAAK,GAAGL,MAAM,GAAG,CAAC;gBAC5B,MAAMc,CAAC,GAAGT,KAAK,GAAGL,MAAM,GAAGoP,CAAC;gBAC5B,MAAMD,CAAC,GAAG9O,KAAK,GAAGL,MAAM,IAAIoP,CAAC,GAAG,CAAC,CAAC;gBAClCJ,UAAU,CAACnO,CAAC,CAAC;gBACbmO,UAAU,CAAClO,CAAC,CAAC;gBACbkO,UAAU,CAACG,CAAC,CAAC;cAEd;YAED;YAEA9O,KAAK,IAAIL,MAAM,GAAG3E,KAAK;UAExB;QAED,CAAC,MAAM;UAEN,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGgE,OAAO,CAAC/D,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI6F,MAAM,EAAE;YAEvDgP,UAAU,CAAC7U,CAAC,CAAC;UAEd;QAED;MAED;MAEA,SAASmV,WAAWA,CAACnS,EAAE,EAAE;QAExB,OAAOP,QAAQ,CAACN,OAAO,CAAC4H,UAAU,CAAC/G,EAAE,CAAC,EAAE4Q,aAAa,CAAC;MAEvD,CAAC,CAAC;;MAGF,SAASwB,oBAAoBA,CAACxV,GAAG,EAAE;QAElC,MAAM0C,IAAI,GAAG;UACZzC,IAAI,EAAED,GAAG,CAACkC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE;UACpCwH,MAAM,EAAE,CAAC,CAAC;UACV+L,KAAK,EAAE;QACR,CAAC;QAED,KAAK,IAAIrV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,kBAAkB;cACtBkV,8BAA8B,CAACnV,KAAK,EAAEmC,IAAI,CAAC;cAC3C;UAEF;QAED;QAEAH,OAAO,CAACoT,gBAAgB,CAAC3V,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAExD;MAEA,SAASkT,oBAAoBA,CAAClT,IAAI,EAAE;QAEnC,IAAIA,IAAI,CAACE,KAAK,KAAKZ,SAAS,EAAE,OAAOU,IAAI,CAACE,KAAK;QAC/C,OAAOF,IAAI;MAEZ;MAEA,SAASmT,kBAAkBA,CAACzS,EAAE,EAAE;QAE/B,OAAOP,QAAQ,CAACN,OAAO,CAACoT,gBAAgB,CAACvS,EAAE,CAAC,EAAEwS,oBAAoB,CAAC;MAEpE;MAEA,SAASF,8BAA8BA,CAAC1V,GAAG,EAAE0C,IAAI,EAAE;QAElD,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,OAAO;cACXkC,IAAI,CAACgH,MAAM,CAACnJ,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC,GAAG4T,oBAAoB,CAACvV,KAAK,CAAC;cACpE;YAED,KAAK,MAAM;cACVmC,IAAI,CAAC+S,KAAK,CAAChV,IAAI,CAACsV,mBAAmB,CAACxV,KAAK,CAAC,CAAC;cAC3C;UAEF;QAED;MAED;MAEA,SAASuV,oBAAoBA,CAAC9V,GAAG,EAAE;QAElC,IAAI0C,IAAI;QAER,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,WAAW;YAChB,KAAK,UAAU;cACdkC,IAAI,GAAGsT,6BAA6B,CAACzV,KAAK,CAAC;cAC3C;UAEF;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAASsT,6BAA6BA,CAAChW,GAAG,EAAE;QAE3C,MAAM0C,IAAI,GAAG;UACZsB,GAAG,EAAEhE,GAAG,CAACkC,YAAY,CAAC,KAAK,CAAC;UAC5BjC,IAAI,EAAED,GAAG,CAACkC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE;UACpC+T,IAAI,EAAE,IAAI9X,KAAK,CAAC8I,OAAO,CAAC,CAAC;UACzBiP,MAAM,EAAE;YACPC,GAAG,EAAE,CAAC;YACNxC,GAAG,EAAE;UACN,CAAC;UACD5G,IAAI,EAAE/M,GAAG,CAACQ,QAAQ;UAClB4V,MAAM,EAAE,KAAK;UACbC,YAAY,EAAE,CAAC;UACfC,cAAc,EAAE;QACjB,CAAC;QAED,KAAK,IAAIlW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,MAAM;cACV,MAAMN,KAAK,GAAGa,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cAC5CO,IAAI,CAACuT,IAAI,CAACvO,SAAS,CAACxH,KAAK,CAAC;cAC1B;YAED,KAAK,QAAQ;cACZ,MAAMyT,GAAG,GAAGpT,KAAK,CAACR,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;cAChD,MAAMoW,GAAG,GAAG5V,KAAK,CAACR,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;cAChD2C,IAAI,CAACwT,MAAM,CAACvC,GAAG,GAAG3S,UAAU,CAAC2S,GAAG,CAACxR,WAAW,CAAC;cAC7CO,IAAI,CAACwT,MAAM,CAACC,GAAG,GAAGnV,UAAU,CAACmV,GAAG,CAAChU,WAAW,CAAC;cAC7C;UAEF;QAED,CAAC,CAAC;;QAGF,IAAIO,IAAI,CAACwT,MAAM,CAACC,GAAG,IAAIzT,IAAI,CAACwT,MAAM,CAACvC,GAAG,EAAE;UAEvCjR,IAAI,CAAC0T,MAAM,GAAG,IAAI;QAEnB,CAAC,CAAC;;QAGF1T,IAAI,CAAC4T,cAAc,GAAG,CAAC5T,IAAI,CAACwT,MAAM,CAACC,GAAG,GAAGzT,IAAI,CAACwT,MAAM,CAACvC,GAAG,IAAI,GAAG;QAC/D,OAAOjR,IAAI;MAEZ;MAEA,SAASqT,mBAAmBA,CAAC/V,GAAG,EAAE;QAEjC,MAAM0C,IAAI,GAAG;UACZsB,GAAG,EAAEhE,GAAG,CAACkC,YAAY,CAAC,KAAK,CAAC;UAC5BjC,IAAI,EAAED,GAAG,CAACkC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE;UACpCqU,WAAW,EAAE,EAAE;UACf5Q,UAAU,EAAE;QACb,CAAC;QAED,KAAK,IAAIvF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,iBAAiB;cACrBkC,IAAI,CAAC6T,WAAW,CAAC9V,IAAI,CAAC+V,yBAAyB,CAACjW,KAAK,CAAC,CAAC;cACvD;YAED,KAAK,QAAQ;YACb,KAAK,WAAW;YAChB,KAAK,QAAQ;cACZmC,IAAI,CAACiD,UAAU,CAAClF,IAAI,CAACgW,wBAAwB,CAAClW,KAAK,CAAC,CAAC;cACrD;UAEF;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAAS8T,yBAAyBA,CAACxW,GAAG,EAAE;QAEvC,MAAM0C,IAAI,GAAG;UACZgU,KAAK,EAAE1W,GAAG,CAACkC,YAAY,CAAC,OAAO,CAAC,CAACrB,KAAK,CAAC,GAAG,CAAC,CAAC8V,GAAG,CAAC,CAAC;UACjDhR,UAAU,EAAE,EAAE;UACd8P,KAAK,EAAE;QACR,CAAC;QAED,KAAK,IAAIrV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,MAAM;cACVkC,IAAI,CAAC+S,KAAK,CAAChV,IAAI,CAACsV,mBAAmB,CAACxV,KAAK,CAAC,CAAC;cAC3C;YAED,KAAK,QAAQ;YACb,KAAK,WAAW;YAChB,KAAK,QAAQ;cACZmC,IAAI,CAACiD,UAAU,CAAClF,IAAI,CAACgW,wBAAwB,CAAClW,KAAK,CAAC,CAAC;cACrD;UAEF;QAED;QAEA,OAAOmC,IAAI;MAEZ;MAEA,SAAS+T,wBAAwBA,CAACzW,GAAG,EAAE;QAEtC,MAAM0C,IAAI,GAAG;UACZqK,IAAI,EAAE/M,GAAG,CAACQ;QACX,CAAC;QACD,MAAMN,KAAK,GAAGa,WAAW,CAACf,GAAG,CAACmC,WAAW,CAAC;QAE1C,QAAQO,IAAI,CAACqK,IAAI;UAEhB,KAAK,QAAQ;YACZrK,IAAI,CAACkU,GAAG,GAAG,IAAIzY,KAAK,CAACsN,OAAO,CAAC,CAAC;YAC9B/I,IAAI,CAACkU,GAAG,CAAClP,SAAS,CAACxH,KAAK,CAAC,CAAC6F,SAAS,CAAC,CAAC;YACrC;UAED,KAAK,WAAW;YACfrD,IAAI,CAACkU,GAAG,GAAG,IAAIzY,KAAK,CAAC8I,OAAO,CAAC,CAAC;YAC9BvE,IAAI,CAACkU,GAAG,CAAClP,SAAS,CAACxH,KAAK,CAAC;YACzB;UAED,KAAK,QAAQ;YACZwC,IAAI,CAACkU,GAAG,GAAG,IAAIzY,KAAK,CAAC8I,OAAO,CAAC,CAAC;YAC9BvE,IAAI,CAACkU,GAAG,CAAClP,SAAS,CAACxH,KAAK,CAAC;YACzBwC,IAAI,CAACmU,KAAK,GAAG1Y,KAAK,CAACuF,SAAS,CAACoT,QAAQ,CAAC5W,KAAK,CAAC,CAAC,CAAC,CAAC;YAC/C;QAEF;QAEA,OAAOwC,IAAI;MAEZ,CAAC,CAAC;;MAGF,SAASqU,iBAAiBA,CAAC/W,GAAG,EAAE;QAE/B,MAAM0C,IAAI,GAAG;UACZzC,IAAI,EAAED,GAAG,CAACkC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE;UACpC8U,WAAW,EAAE,CAAC;QACf,CAAC;QAED,KAAK,IAAI5W,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,YAAY;cAChBkC,IAAI,CAACsU,WAAW,CAACzW,KAAK,CAAC2B,YAAY,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;cACjD+U,qBAAqB,CAAC1W,KAAK,EAAEmC,IAAI,CAACsU,WAAW,CAACzW,KAAK,CAAC2B,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC;cAC1E;UAEF;QAED;QAEAK,OAAO,CAAC2U,aAAa,CAAClX,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAErD;MAEA,SAASuU,qBAAqBA,CAACjX,GAAG,EAAE0C,IAAI,EAAE;QAEzC,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,kBAAkB;cACtB2W,2BAA2B,CAAC5W,KAAK,EAAEmC,IAAI,CAAC;cACxC;UAEF;QAED;MAED;MAEA,SAASyU,2BAA2BA,CAACnX,GAAG,EAAE0C,IAAI,EAAE;QAE/C,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,SAAS;cACbkC,IAAI,CAAC0U,OAAO,GAAGrW,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cAC7C;YAED,KAAK,MAAM;cACVO,IAAI,CAAC2U,IAAI,GAAGtW,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC,CAAC,CAAC,CAAC;cAC7C;UAEF;QAED;MAED,CAAC,CAAC;;MAGF,SAASmV,oBAAoBA,CAACtX,GAAG,EAAE;QAElC,MAAM0C,IAAI,GAAG;UACZ6U,aAAa,EAAE;QAChB,CAAC;QAED,KAAK,IAAInX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,iBAAiB;cACrBkC,IAAI,CAAC6U,aAAa,CAAC9W,IAAI,CAAC+W,4BAA4B,CAACjX,KAAK,CAAC,CAAC;cAC5D;UAEF;QAED;QAEAgC,OAAO,CAACkV,gBAAgB,CAACtW,OAAO,CAACnB,GAAG,CAACkC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,GAAGQ,IAAI;MAElE;MAEA,SAAS8U,4BAA4BA,CAACxX,GAAG,EAAE;QAE1C,MAAM0C,IAAI,GAAG;UACZoB,MAAM,EAAE9D,GAAG,CAACkC,YAAY,CAAC,QAAQ,CAAC,CAACrB,KAAK,CAAC,GAAG,CAAC,CAAC8V,GAAG,CAAC;QACnD,CAAC;QAED,KAAK,IAAIvW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAE1B,QAAQ5C,KAAK,CAACC,QAAQ;YAErB,KAAK,MAAM;cACV,MAAMkX,KAAK,GAAGnX,KAAK,CAACR,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;cACpD2C,IAAI,CAACuT,IAAI,GAAGyB,KAAK,CAACvV,WAAW;cAC7B,MAAMwV,aAAa,GAAGjV,IAAI,CAACuT,IAAI,CAACpV,KAAK,CAAC,OAAO,CAAC,CAAC8V,GAAG,CAAC,CAAC,CAAC9V,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;cACrE6B,IAAI,CAACkV,UAAU,GAAGD,aAAa,CAACE,MAAM,CAAC,CAAC,EAAEF,aAAa,CAACrX,MAAM,GAAG,CAAC,CAAC;cACnE;UAEF;QAED;QAEA,OAAOoC,IAAI;MAEZ;MAEA,SAASoV,oBAAoBA,CAACpV,IAAI,EAAE;QAEnC,IAAIA,IAAI,CAACE,KAAK,KAAKZ,SAAS,EAAE,OAAOU,IAAI,CAACE,KAAK;QAC/C,OAAOF,IAAI;MAEZ;MAEA,SAASqV,kBAAkBA,CAAC3U,EAAE,EAAE;QAE/B,OAAOP,QAAQ,CAACN,OAAO,CAACkV,gBAAgB,CAACrU,EAAE,CAAC,EAAE0U,oBAAoB,CAAC;MAEpE;MAEA,SAASE,eAAeA,CAAA,EAAG;QAE1B,MAAMC,iBAAiB,GAAGxW,MAAM,CAACC,IAAI,CAACa,OAAO,CAACoT,gBAAgB,CAAC,CAAC,CAAC,CAAC;QAClE,MAAMuC,iBAAiB,GAAGzW,MAAM,CAACC,IAAI,CAACa,OAAO,CAACkV,gBAAgB,CAAC,CAAC,CAAC,CAAC;QAClE,MAAMU,aAAa,GAAG1W,MAAM,CAACC,IAAI,CAACa,OAAO,CAAC6V,YAAY,CAAC,CAAC,CAAC,CAAC;QAC1D,IAAIH,iBAAiB,KAAKjW,SAAS,IAAIkW,iBAAiB,KAAKlW,SAAS,EAAE;QACxE,MAAMqW,eAAe,GAAGxC,kBAAkB,CAACoC,iBAAiB,CAAC;QAC7D,MAAMK,eAAe,GAAGP,kBAAkB,CAACG,iBAAiB,CAAC;QAC7D,MAAMK,WAAW,GAAGC,cAAc,CAACL,aAAa,CAAC;QACjD,MAAMZ,aAAa,GAAGe,eAAe,CAACf,aAAa;QACnD,MAAMkB,QAAQ,GAAG,CAAC,CAAC;QAEnB,KAAK,IAAIrY,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGkX,aAAa,CAACjX,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAErD,MAAM6V,IAAI,GAAGsB,aAAa,CAACnX,CAAC,CAAC,CAAC,CAAC;;UAE/B,MAAMsY,aAAa,GAAGC,OAAO,CAACC,aAAa,CAAC,QAAQ,GAAG3C,IAAI,CAACnS,MAAM,GAAG,IAAI,CAAC;UAE1E,IAAI4U,aAAa,EAAE;YAElB;YACA,MAAMG,mBAAmB,GAAGH,aAAa,CAACI,aAAa,CAAC,CAAC;;YAEzDC,OAAO,CAAC9C,IAAI,CAAC2B,UAAU,EAAEiB,mBAAmB,CAAC;UAE9C;QAED;QAEA,SAASE,OAAOA,CAACnB,UAAU,EAAEoB,aAAa,EAAE;UAE3C,MAAMC,iBAAiB,GAAGD,aAAa,CAAC9W,YAAY,CAAC,MAAM,CAAC;UAC5D,MAAMwU,KAAK,GAAG2B,eAAe,CAAC3O,MAAM,CAACkO,UAAU,CAAC;UAChDW,WAAW,CAACW,QAAQ,CAAC,UAAU1X,MAAM,EAAE;YAEtC,IAAIA,MAAM,CAACvB,IAAI,KAAKgZ,iBAAiB,EAAE;cAEtCR,QAAQ,CAACb,UAAU,CAAC,GAAG;gBACtBpW,MAAM,EAAEA,MAAM;gBACdmE,UAAU,EAAEwT,kBAAkB,CAACH,aAAa,CAAC;gBAC7CtC,KAAK,EAAEA,KAAK;gBACZ1P,QAAQ,EAAE0P,KAAK,CAACL;cACjB,CAAC;YAEF;UAED,CAAC,CAAC;QAEH;QAEA,MAAM+C,EAAE,GAAG,IAAIjb,KAAK,CAACsN,OAAO,CAAC,CAAC;QAC9B4N,UAAU,GAAG;UACZ3P,MAAM,EAAE2O,eAAe,IAAIA,eAAe,CAAC3O,MAAM;UACjD4P,aAAa,EAAE,SAAAA,CAAU1B,UAAU,EAAE;YAEpC,MAAM2B,SAAS,GAAGd,QAAQ,CAACb,UAAU,CAAC;YAEtC,IAAI2B,SAAS,EAAE;cAEd,OAAOA,SAAS,CAACvS,QAAQ;YAE1B,CAAC,MAAM;cAENpH,OAAO,CAAC2G,IAAI,CAAC,6BAA6B,GAAGqR,UAAU,GAAG,kBAAkB,CAAC;YAE9E;UAED,CAAC;UACD4B,aAAa,EAAE,SAAAA,CAAU5B,UAAU,EAAEvR,KAAK,EAAE;YAE3C,MAAMkT,SAAS,GAAGd,QAAQ,CAACb,UAAU,CAAC;YAEtC,IAAI2B,SAAS,EAAE;cAEd,MAAM7C,KAAK,GAAG6C,SAAS,CAAC7C,KAAK;cAE7B,IAAIrQ,KAAK,GAAGqQ,KAAK,CAACR,MAAM,CAACvC,GAAG,IAAItN,KAAK,GAAGqQ,KAAK,CAACR,MAAM,CAACC,GAAG,EAAE;gBAEzDvW,OAAO,CAAC2G,IAAI,CAAC,6BAA6B,GAAGqR,UAAU,GAAG,SAAS,GAAGvR,KAAK,GAAG,2BAA2B,GAAGqQ,KAAK,CAACR,MAAM,CAACC,GAAG,GAAG,SAAS,GAAGO,KAAK,CAACR,MAAM,CAACvC,GAAG,GAAG,IAAI,CAAC;cAEpK,CAAC,MAAM,IAAI+C,KAAK,CAACN,MAAM,EAAE;gBAExBxW,OAAO,CAAC2G,IAAI,CAAC,6BAA6B,GAAGqR,UAAU,GAAG,aAAa,CAAC;cAEzE,CAAC,MAAM;gBAEN,MAAMpW,MAAM,GAAG+X,SAAS,CAAC/X,MAAM;gBAC/B,MAAMyU,IAAI,GAAGS,KAAK,CAACT,IAAI;gBACvB,MAAMtQ,UAAU,GAAG4T,SAAS,CAAC5T,UAAU;gBACvCE,MAAM,CAAC6F,QAAQ,CAAC,CAAC,CAAC,CAAC;;gBAEnB,KAAK,IAAItL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuF,UAAU,CAACrF,MAAM,EAAEF,CAAC,EAAE,EAAE;kBAE3C,MAAMsF,SAAS,GAAGC,UAAU,CAACvF,CAAC,CAAC,CAAC,CAAC;;kBAEjC,IAAIsF,SAAS,CAAC1B,GAAG,IAAI0B,SAAS,CAAC1B,GAAG,CAACE,OAAO,CAAC0T,UAAU,CAAC,KAAK,CAAE,CAAC,EAAE;oBAE/D,QAAQlB,KAAK,CAAC3J,IAAI;sBAEjB,KAAK,UAAU;wBACdlH,MAAM,CAAC4T,QAAQ,CAACL,EAAE,CAACM,gBAAgB,CAACzD,IAAI,EAAE9X,KAAK,CAACuF,SAAS,CAACoT,QAAQ,CAACzQ,KAAK,CAAC,CAAC,CAAC;wBAC3E;sBAED,KAAK,WAAW;wBACfR,MAAM,CAAC4T,QAAQ,CAACL,EAAE,CAACO,eAAe,CAAC1D,IAAI,CAACrO,CAAC,GAAGvB,KAAK,EAAE4P,IAAI,CAACpO,CAAC,GAAGxB,KAAK,EAAE4P,IAAI,CAACnO,CAAC,GAAGzB,KAAK,CAAC,CAAC;wBACnF;sBAED;wBACCzG,OAAO,CAAC2G,IAAI,CAAC,2CAA2C,GAAGmQ,KAAK,CAAC3J,IAAI,CAAC;wBACtE;oBAEF;kBAED,CAAC,MAAM;oBAEN,QAAQrH,SAAS,CAACqH,IAAI;sBAErB,KAAK,QAAQ;wBACZlH,MAAM,CAAC4T,QAAQ,CAAC/T,SAAS,CAACkR,GAAG,CAAC;wBAC9B;sBAED,KAAK,WAAW;wBACf/Q,MAAM,CAAC4T,QAAQ,CAACL,EAAE,CAACO,eAAe,CAACjU,SAAS,CAACkR,GAAG,CAAChP,CAAC,EAAElC,SAAS,CAACkR,GAAG,CAAC/O,CAAC,EAAEnC,SAAS,CAACkR,GAAG,CAAC9O,CAAC,CAAC,CAAC;wBACtF;sBAED,KAAK,OAAO;wBACXjC,MAAM,CAACqB,KAAK,CAACxB,SAAS,CAACkR,GAAG,CAAC;wBAC3B;sBAED,KAAK,QAAQ;wBACZ/Q,MAAM,CAAC4T,QAAQ,CAACL,EAAE,CAACM,gBAAgB,CAAChU,SAAS,CAACkR,GAAG,EAAElR,SAAS,CAACmR,KAAK,CAAC,CAAC;wBACpE;oBAEF;kBAED;gBAED;gBAEArV,MAAM,CAACqE,MAAM,CAACkN,IAAI,CAAClN,MAAM,CAAC;gBAC1BrE,MAAM,CAACqE,MAAM,CAAC8B,SAAS,CAACnG,MAAM,CAACwF,QAAQ,EAAExF,MAAM,CAAC2F,UAAU,EAAE3F,MAAM,CAAC0F,KAAK,CAAC;gBACzEuR,QAAQ,CAACb,UAAU,CAAC,CAAC5Q,QAAQ,GAAGX,KAAK;cAEtC;YAED,CAAC,MAAM;cAENzG,OAAO,CAAC4D,GAAG,CAAC,uBAAuB,GAAGoU,UAAU,GAAG,kBAAkB,CAAC;YAEvE;UAED;QACD,CAAC;MAEF;MAEA,SAASuB,kBAAkBA,CAAC7T,IAAI,EAAE;QAEjC,MAAMK,UAAU,GAAG,EAAE;QACrB,MAAM3F,GAAG,GAAG2Y,OAAO,CAACC,aAAa,CAAC,OAAO,GAAGtT,IAAI,CAAClC,EAAE,GAAG,IAAI,CAAC;QAE3D,KAAK,IAAIhD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAC1B,IAAIjD,KAAK,EAAE0Z,MAAM;UAEjB,QAAQrZ,KAAK,CAACC,QAAQ;YAErB,KAAK,QAAQ;cACZN,KAAK,GAAGa,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cACtC,MAAM0D,MAAM,GAAG,IAAI1H,KAAK,CAACsN,OAAO,CAAC,CAAC,CAAC/D,SAAS,CAACxH,KAAK,CAAC,CAAC6F,SAAS,CAAC,CAAC;cAC/DJ,UAAU,CAAClF,IAAI,CAAC;gBACfuD,GAAG,EAAEzD,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC;gBAC9B6K,IAAI,EAAExM,KAAK,CAACC,QAAQ;gBACpBoW,GAAG,EAAE/Q;cACN,CAAC,CAAC;cACF;YAED,KAAK,WAAW;YAChB,KAAK,OAAO;cACX3F,KAAK,GAAGa,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cACtCyX,MAAM,GAAG,IAAIzb,KAAK,CAAC8I,OAAO,CAAC,CAAC,CAACS,SAAS,CAACxH,KAAK,CAAC;cAC7CyF,UAAU,CAAClF,IAAI,CAAC;gBACfuD,GAAG,EAAEzD,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC;gBAC9B6K,IAAI,EAAExM,KAAK,CAACC,QAAQ;gBACpBoW,GAAG,EAAEgD;cACN,CAAC,CAAC;cACF;YAED,KAAK,QAAQ;cACZ1Z,KAAK,GAAGa,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cACtCyX,MAAM,GAAG,IAAIzb,KAAK,CAAC8I,OAAO,CAAC,CAAC,CAACS,SAAS,CAACxH,KAAK,CAAC;cAC7C,MAAM2W,KAAK,GAAG1Y,KAAK,CAACuF,SAAS,CAACoT,QAAQ,CAAC5W,KAAK,CAAC,CAAC,CAAC,CAAC;cAChDyF,UAAU,CAAClF,IAAI,CAAC;gBACfuD,GAAG,EAAEzD,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC;gBAC9B6K,IAAI,EAAExM,KAAK,CAACC,QAAQ;gBACpBoW,GAAG,EAAEgD,MAAM;gBACX/C,KAAK,EAAEA;cACR,CAAC,CAAC;cACF;UAEF;QAED;QAEA,OAAOlR,UAAU;MAElB,CAAC,CAAC;;MAGF,SAASkU,YAAYA,CAAC7Z,GAAG,EAAE;QAE1B,MAAMwC,QAAQ,GAAGxC,GAAG,CAACD,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC;;QAEnD,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,QAAQ,CAAClC,MAAM,EAAEF,CAAC,EAAE,EAAE;UAEzC,MAAM0Z,OAAO,GAAGtX,QAAQ,CAACpC,CAAC,CAAC;UAE3B,IAAI0Z,OAAO,CAAC7X,YAAY,CAAC,IAAI,CAAC,KAAK,KAAK,EAAE;YAEzC6X,OAAO,CAAC/E,YAAY,CAAC,IAAI,EAAE1T,UAAU,CAAC,CAAC,CAAC;UAEzC;QAED;MAED;MAEA,MAAMwE,MAAM,GAAG,IAAI1H,KAAK,CAACsN,OAAO,CAAC,CAAC;MAClC,MAAMmO,MAAM,GAAG,IAAIzb,KAAK,CAAC8I,OAAO,CAAC,CAAC;MAElC,SAAS8S,SAASA,CAAC/Z,GAAG,EAAE;QAEvB,MAAM0C,IAAI,GAAG;UACZzC,IAAI,EAAED,GAAG,CAACkC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE;UACpC6K,IAAI,EAAE/M,GAAG,CAACkC,YAAY,CAAC,MAAM,CAAC;UAC9BkB,EAAE,EAAEpD,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC;UAC1B8B,GAAG,EAAEhE,GAAG,CAACkC,YAAY,CAAC,KAAK,CAAC;UAC5B2D,MAAM,EAAE,IAAI1H,KAAK,CAACsN,OAAO,CAAC,CAAC;UAC3BlG,KAAK,EAAE,EAAE;UACTyU,eAAe,EAAE,EAAE;UACnBC,mBAAmB,EAAE,EAAE;UACvBC,cAAc,EAAE,EAAE;UAClBC,kBAAkB,EAAE,EAAE;UACtBC,aAAa,EAAE,EAAE;UACjBzU,UAAU,EAAE,CAAC;QACd,CAAC;QAED,KAAK,IAAIvF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAC/B,IAAIG,KAAK,CAAC4C,QAAQ,KAAK,CAAC,EAAE;UAC1B,IAAIjD,KAAK;UAET,QAAQK,KAAK,CAACC,QAAQ;YAErB,KAAK,MAAM;cACVkC,IAAI,CAAC6C,KAAK,CAAC9E,IAAI,CAACF,KAAK,CAAC2B,YAAY,CAAC,IAAI,CAAC,CAAC;cACzC6X,SAAS,CAACxZ,KAAK,CAAC;cAChB;YAED,KAAK,iBAAiB;cACrBmC,IAAI,CAACsX,eAAe,CAACvZ,IAAI,CAACU,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;cAC7D;YAED,KAAK,qBAAqB;cACzBQ,IAAI,CAACuX,mBAAmB,CAACxZ,IAAI,CAAC4Z,iBAAiB,CAAC9Z,KAAK,CAAC,CAAC;cACvD;YAED,KAAK,gBAAgB;cACpBmC,IAAI,CAACwX,cAAc,CAACzZ,IAAI,CAACU,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;cAC5D;YAED,KAAK,mBAAmB;cACvBQ,IAAI,CAACyX,kBAAkB,CAAC1Z,IAAI,CAAC4Z,iBAAiB,CAAC9Z,KAAK,CAAC,CAAC;cACtD;YAED,KAAK,eAAe;cACnBmC,IAAI,CAAC0X,aAAa,CAAC3Z,IAAI,CAACU,OAAO,CAACZ,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;cAC3D;YAED,KAAK,QAAQ;cACZhC,KAAK,GAAGa,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cACtCO,IAAI,CAACmD,MAAM,CAAC4T,QAAQ,CAAC5T,MAAM,CAAC6B,SAAS,CAACxH,KAAK,CAAC,CAAC6F,SAAS,CAAC,CAAC,CAAC;cACzDrD,IAAI,CAACiD,UAAU,CAACpF,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC,GAAG3B,KAAK,CAACC,QAAQ;cAC3D;YAED,KAAK,WAAW;cACfN,KAAK,GAAGa,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cACtCyX,MAAM,CAAClS,SAAS,CAACxH,KAAK,CAAC;cACvBwC,IAAI,CAACmD,MAAM,CAAC4T,QAAQ,CAAC5T,MAAM,CAAC8T,eAAe,CAACC,MAAM,CAAChS,CAAC,EAAEgS,MAAM,CAAC/R,CAAC,EAAE+R,MAAM,CAAC9R,CAAC,CAAC,CAAC;cAC1EpF,IAAI,CAACiD,UAAU,CAACpF,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC,GAAG3B,KAAK,CAACC,QAAQ;cAC3D;YAED,KAAK,QAAQ;cACZN,KAAK,GAAGa,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cACtC,MAAM0U,KAAK,GAAG1Y,KAAK,CAACuF,SAAS,CAACoT,QAAQ,CAAC5W,KAAK,CAAC,CAAC,CAAC,CAAC;cAChDwC,IAAI,CAACmD,MAAM,CAAC4T,QAAQ,CAAC5T,MAAM,CAAC6T,gBAAgB,CAACE,MAAM,CAAClS,SAAS,CAACxH,KAAK,CAAC,EAAE2W,KAAK,CAAC,CAAC;cAC7EnU,IAAI,CAACiD,UAAU,CAACpF,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC,GAAG3B,KAAK,CAACC,QAAQ;cAC3D;YAED,KAAK,OAAO;cACXN,KAAK,GAAGa,WAAW,CAACR,KAAK,CAAC4B,WAAW,CAAC;cACtCO,IAAI,CAACmD,MAAM,CAACqB,KAAK,CAAC0S,MAAM,CAAClS,SAAS,CAACxH,KAAK,CAAC,CAAC;cAC1CwC,IAAI,CAACiD,UAAU,CAACpF,KAAK,CAAC2B,YAAY,CAAC,KAAK,CAAC,CAAC,GAAG3B,KAAK,CAACC,QAAQ;cAC3D;YAED,KAAK,OAAO;cACX;YAED;cACCZ,OAAO,CAAC4D,GAAG,CAACjD,KAAK,CAAC;UAEpB;QAED;QAEA,IAAI+Z,OAAO,CAAC5X,IAAI,CAACU,EAAE,CAAC,EAAE;UAErBxD,OAAO,CAAC2G,IAAI,CAAC,wGAAwG,EAAE7D,IAAI,CAACU,EAAE,CAAC;QAEhI,CAAC,MAAM;UAENb,OAAO,CAACgD,KAAK,CAAC7C,IAAI,CAACU,EAAE,CAAC,GAAGV,IAAI;QAE9B;QAEA,OAAOA,IAAI;MAEZ;MAEA,SAAS2X,iBAAiBA,CAACra,GAAG,EAAE;QAE/B,MAAM0C,IAAI,GAAG;UACZU,EAAE,EAAEjC,OAAO,CAACnB,GAAG,CAACkC,YAAY,CAAC,KAAK,CAAC,CAAC;UACpC0L,SAAS,EAAE,CAAC,CAAC;UACb2M,SAAS,EAAE;QACZ,CAAC;QAED,KAAK,IAAIna,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,UAAU,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE/C,MAAMG,KAAK,GAAGP,GAAG,CAACG,UAAU,CAACC,CAAC,CAAC;UAE/B,QAAQG,KAAK,CAACC,QAAQ;YAErB,KAAK,eAAe;cACnB,MAAMga,SAAS,GAAGja,KAAK,CAACR,oBAAoB,CAAC,mBAAmB,CAAC;cAEjE,KAAK,IAAIoG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqU,SAAS,CAACla,MAAM,EAAE6F,CAAC,EAAE,EAAE;gBAE1C,MAAMsU,QAAQ,GAAGD,SAAS,CAACrU,CAAC,CAAC;gBAC7B,MAAMuU,MAAM,GAAGD,QAAQ,CAACvY,YAAY,CAAC,QAAQ,CAAC;gBAC9C,MAAM4B,MAAM,GAAG2W,QAAQ,CAACvY,YAAY,CAAC,QAAQ,CAAC;gBAC9CQ,IAAI,CAACkL,SAAS,CAAC8M,MAAM,CAAC,GAAGvZ,OAAO,CAAC2C,MAAM,CAAC;cAEzC;cAEA;YAED,KAAK,UAAU;cACdpB,IAAI,CAAC6X,SAAS,CAAC9Z,IAAI,CAACU,OAAO,CAACZ,KAAK,CAAC4B,WAAW,CAAC,CAAC;cAC/C;YAED;cACC;UAEF;QAED;QAEA,OAAOO,IAAI;MAEZ;MAEA,SAASiY,aAAaA,CAACJ,SAAS,EAAE7Q,MAAM,EAAE;QAEzC,MAAMkR,QAAQ,GAAG,EAAE;QACnB,MAAMC,cAAc,GAAG,EAAE;QACzB,IAAIza,CAAC,EAAE+F,CAAC,EAAEzD,IAAI,CAAC,CAAC;QAChB;;QAEA,KAAKtC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGma,SAAS,CAACja,MAAM,EAAEF,CAAC,EAAE,EAAE;UAEtC,MAAM0a,QAAQ,GAAGP,SAAS,CAACna,CAAC,CAAC;UAC7B,IAAI2a,IAAI;UAER,IAAIT,OAAO,CAACQ,QAAQ,CAAC,EAAE;YAEtBC,IAAI,GAAGtV,OAAO,CAACqV,QAAQ,CAAC;YACxBE,kBAAkB,CAACD,IAAI,EAAErR,MAAM,EAAEkR,QAAQ,CAAC;UAE3C,CAAC,MAAM,IAAIK,cAAc,CAACH,QAAQ,CAAC,EAAE;YAEpC;YACA,MAAMvC,WAAW,GAAGhW,OAAO,CAAC6V,YAAY,CAAC0C,QAAQ,CAAC;YAClD,MAAMI,QAAQ,GAAG3C,WAAW,CAAC2C,QAAQ;YAErC,KAAK,IAAI/U,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+U,QAAQ,CAAC5a,MAAM,EAAE6F,CAAC,EAAE,EAAE;cAEzC,MAAM5F,KAAK,GAAG2a,QAAQ,CAAC/U,CAAC,CAAC;cAEzB,IAAI5F,KAAK,CAACwM,IAAI,KAAK,OAAO,EAAE;gBAE3B,MAAMgO,IAAI,GAAGtV,OAAO,CAAClF,KAAK,CAAC6C,EAAE,CAAC;gBAC9B4X,kBAAkB,CAACD,IAAI,EAAErR,MAAM,EAAEkR,QAAQ,CAAC;cAE3C;YAED;UAED,CAAC,MAAM;YAENhb,OAAO,CAACC,KAAK,CAAC,oEAAoE,EAAEib,QAAQ,CAAC;UAE9F;QAED,CAAC,CAAC;;QAGF,KAAK1a,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsJ,MAAM,CAACpJ,MAAM,EAAEF,CAAC,EAAE,EAAE;UAEnC,KAAK+F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyU,QAAQ,CAACta,MAAM,EAAE6F,CAAC,EAAE,EAAE;YAErCzD,IAAI,GAAGkY,QAAQ,CAACzU,CAAC,CAAC;YAElB,IAAIzD,IAAI,CAACyY,IAAI,CAAClb,IAAI,KAAKyJ,MAAM,CAACtJ,CAAC,CAAC,CAACH,IAAI,EAAE;cAEtC4a,cAAc,CAACza,CAAC,CAAC,GAAGsC,IAAI;cACxBA,IAAI,CAAC0Y,SAAS,GAAG,IAAI;cACrB;YAED;UAED;QAED,CAAC,CAAC;;QAGF,KAAKhb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwa,QAAQ,CAACta,MAAM,EAAEF,CAAC,EAAE,EAAE;UAErCsC,IAAI,GAAGkY,QAAQ,CAACxa,CAAC,CAAC;UAElB,IAAIsC,IAAI,CAAC0Y,SAAS,KAAK,KAAK,EAAE;YAE7BP,cAAc,CAACpa,IAAI,CAACiC,IAAI,CAAC;YACzBA,IAAI,CAAC0Y,SAAS,GAAG,IAAI;UAEtB;QAED,CAAC,CAAC;;QAGF,MAAMC,KAAK,GAAG,EAAE;QAChB,MAAMC,YAAY,GAAG,EAAE;QAEvB,KAAKlb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGya,cAAc,CAACva,MAAM,EAAEF,CAAC,EAAE,EAAE;UAE3CsC,IAAI,GAAGmY,cAAc,CAACza,CAAC,CAAC;UACxBib,KAAK,CAAC5a,IAAI,CAACiC,IAAI,CAACyY,IAAI,CAAC;UACrBG,YAAY,CAAC7a,IAAI,CAACiC,IAAI,CAACiJ,WAAW,CAAC;QAEpC;QAEA,OAAO,IAAIxN,KAAK,CAACod,QAAQ,CAACF,KAAK,EAAEC,YAAY,CAAC;MAE/C;MAEA,SAASN,kBAAkBA,CAACD,IAAI,EAAErR,MAAM,EAAEkR,QAAQ,EAAE;QAEnD;QACAG,IAAI,CAAC7B,QAAQ,CAAC,UAAU1X,MAAM,EAAE;UAE/B,IAAIA,MAAM,CAACga,MAAM,KAAK,IAAI,EAAE;YAE3B,IAAI7P,WAAW,CAAC,CAAC;;YAEjB,KAAK,IAAIvL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsJ,MAAM,CAACpJ,MAAM,EAAEF,CAAC,EAAE,EAAE;cAEvC,MAAMsW,KAAK,GAAGhN,MAAM,CAACtJ,CAAC,CAAC;cAEvB,IAAIsW,KAAK,CAACzW,IAAI,KAAKuB,MAAM,CAACvB,IAAI,EAAE;gBAE/B0L,WAAW,GAAG+K,KAAK,CAAC/K,WAAW;gBAC/B;cAED;YAED;YAEA,IAAIA,WAAW,KAAK3J,SAAS,EAAE;cAE9B;cACA;cACA;cACA;cACA;cACA2J,WAAW,GAAG,IAAIxN,KAAK,CAACsN,OAAO,CAAC,CAAC;YAElC;YAEAmP,QAAQ,CAACna,IAAI,CAAC;cACb0a,IAAI,EAAE3Z,MAAM;cACZmK,WAAW,EAAEA,WAAW;cACxByP,SAAS,EAAE;YACZ,CAAC,CAAC;UAEH;QAED,CAAC,CAAC;MAEH;MAEA,SAASK,SAASA,CAAC/Y,IAAI,EAAE;QAExB,MAAMgZ,OAAO,GAAG,EAAE;QAClB,MAAM7V,MAAM,GAAGnD,IAAI,CAACmD,MAAM;QAC1B,MAAMN,KAAK,GAAG7C,IAAI,CAAC6C,KAAK;QACxB,MAAMwH,IAAI,GAAGrK,IAAI,CAACqK,IAAI;QACtB,MAAMiN,eAAe,GAAGtX,IAAI,CAACsX,eAAe;QAC5C,MAAMC,mBAAmB,GAAGvX,IAAI,CAACuX,mBAAmB;QACpD,MAAMC,cAAc,GAAGxX,IAAI,CAACwX,cAAc;QAC1C,MAAMC,kBAAkB,GAAGzX,IAAI,CAACyX,kBAAkB;QAClD,MAAMC,aAAa,GAAG1X,IAAI,CAAC0X,aAAa,CAAC,CAAC;;QAE1C,KAAK,IAAIha,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGkF,KAAK,CAACjF,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAE7Csb,OAAO,CAACjb,IAAI,CAACgF,OAAO,CAACF,KAAK,CAACnF,CAAC,CAAC,CAAC,CAAC;QAEhC,CAAC,CAAC;;QAGF,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG2Z,eAAe,CAAC1Z,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEvD,MAAMub,cAAc,GAAG7J,SAAS,CAACkI,eAAe,CAAC5Z,CAAC,CAAC,CAAC;UAEpD,IAAIub,cAAc,KAAK,IAAI,EAAE;YAE5BD,OAAO,CAACjb,IAAI,CAACkb,cAAc,CAAC7V,KAAK,CAAC,CAAC,CAAC;UAErC;QAED,CAAC,CAAC;;QAGF,KAAK,IAAI1F,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG4Z,mBAAmB,CAAC3Z,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAE3D,MAAMqa,QAAQ,GAAGR,mBAAmB,CAAC7Z,CAAC,CAAC;UACvC,MAAMwb,UAAU,GAAGhQ,aAAa,CAAC6O,QAAQ,CAACrX,EAAE,CAAC;UAC7C,MAAM+G,UAAU,GAAGoL,WAAW,CAACqG,UAAU,CAACxY,EAAE,CAAC;UAC7C,MAAMyY,UAAU,GAAGC,YAAY,CAAC3R,UAAU,EAAEsQ,QAAQ,CAAC7M,SAAS,CAAC;UAC/D,MAAM2M,SAAS,GAAGE,QAAQ,CAACF,SAAS;UACpC,MAAM7Q,MAAM,GAAGkS,UAAU,CAACtS,IAAI,CAACI,MAAM;UACrC,MAAMoR,QAAQ,GAAGH,aAAa,CAACJ,SAAS,EAAE7Q,MAAM,CAAC;UAEjD,KAAK,IAAIvD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGyV,UAAU,CAACvb,MAAM,EAAE6F,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;YAEpD,MAAM3E,MAAM,GAAGqa,UAAU,CAAC1V,CAAC,CAAC;YAE5B,IAAI3E,MAAM,CAACua,aAAa,EAAE;cAEzBva,MAAM,CAACwa,IAAI,CAAClB,QAAQ,EAAEc,UAAU,CAACtS,IAAI,CAACkC,UAAU,CAAC;cACjDhK,MAAM,CAACya,oBAAoB,CAAC,CAAC;YAE9B;YAEAP,OAAO,CAACjb,IAAI,CAACe,MAAM,CAAC;UAErB;QAED,CAAC,CAAC;;QAGF,KAAK,IAAIpB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG6Z,cAAc,CAAC5Z,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAEtD,MAAM8b,aAAa,GAAGlJ,QAAQ,CAACkH,cAAc,CAAC9Z,CAAC,CAAC,CAAC;UAEjD,IAAI8b,aAAa,KAAK,IAAI,EAAE;YAE3BR,OAAO,CAACjb,IAAI,CAACyb,aAAa,CAACpW,KAAK,CAAC,CAAC,CAAC;UAEpC;QAED,CAAC,CAAC;;QAGF,KAAK,IAAI1F,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG8Z,kBAAkB,CAAC7Z,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAE1D,MAAMqa,QAAQ,GAAGN,kBAAkB,CAAC/Z,CAAC,CAAC,CAAC,CAAC;UACxC;;UAEA,MAAM+J,UAAU,GAAGoL,WAAW,CAACkF,QAAQ,CAACrX,EAAE,CAAC;UAC3C,MAAMyY,UAAU,GAAGC,YAAY,CAAC3R,UAAU,EAAEsQ,QAAQ,CAAC7M,SAAS,CAAC;UAE/D,KAAK,IAAIzH,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGyV,UAAU,CAACvb,MAAM,EAAE6F,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAE;YAEpDuV,OAAO,CAACjb,IAAI,CAACob,UAAU,CAAC1V,CAAC,CAAC,CAAC;UAE5B;QAED,CAAC,CAAC;;QAGF,KAAK,IAAI/F,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG+Z,aAAa,CAAC9Z,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAErDsb,OAAO,CAACjb,IAAI,CAACgF,OAAO,CAAC2U,aAAa,CAACha,CAAC,CAAC,CAAC,CAAC0F,KAAK,CAAC,CAAC,CAAC;QAEhD;QAEA,IAAItE,MAAM;QAEV,IAAI+D,KAAK,CAACjF,MAAM,KAAK,CAAC,IAAIob,OAAO,CAACpb,MAAM,KAAK,CAAC,EAAE;UAE/CkB,MAAM,GAAGka,OAAO,CAAC,CAAC,CAAC;QAEpB,CAAC,MAAM;UAENla,MAAM,GAAGuL,IAAI,KAAK,OAAO,GAAG,IAAI5O,KAAK,CAACge,IAAI,CAAC,CAAC,GAAG,IAAIhe,KAAK,CAACie,KAAK,CAAC,CAAC;UAEhE,KAAK,IAAIhc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsb,OAAO,CAACpb,MAAM,EAAEF,CAAC,EAAE,EAAE;YAExCoB,MAAM,CAAC6a,GAAG,CAACX,OAAO,CAACtb,CAAC,CAAC,CAAC;UAEvB;QAED;QAEAoB,MAAM,CAACvB,IAAI,GAAG8M,IAAI,KAAK,OAAO,GAAGrK,IAAI,CAACsB,GAAG,GAAGtB,IAAI,CAACzC,IAAI;QACrDuB,MAAM,CAACqE,MAAM,CAACkN,IAAI,CAAClN,MAAM,CAAC;QAC1BrE,MAAM,CAACqE,MAAM,CAAC8B,SAAS,CAACnG,MAAM,CAACwF,QAAQ,EAAExF,MAAM,CAAC2F,UAAU,EAAE3F,MAAM,CAAC0F,KAAK,CAAC;QACzE,OAAO1F,MAAM;MAEd;MAEA,MAAM8a,gBAAgB,GAAG,IAAIne,KAAK,CAACuQ,iBAAiB,CAAC;QACpDkB,KAAK,EAAE;MACR,CAAC,CAAC;MAEF,SAAS2M,sBAAsBA,CAAC7a,IAAI,EAAE8a,iBAAiB,EAAE;QAExD,MAAM5O,SAAS,GAAG,EAAE;QAEpB,KAAK,IAAIxN,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGqB,IAAI,CAACpB,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAE5C,MAAMgD,EAAE,GAAGoZ,iBAAiB,CAAC9a,IAAI,CAACtB,CAAC,CAAC,CAAC;UAErC,IAAIgD,EAAE,KAAKpB,SAAS,EAAE;YAErBpC,OAAO,CAAC2G,IAAI,CAAC,+EAA+E,EAAE7E,IAAI,CAACtB,CAAC,CAAC,CAAC;YACtGwN,SAAS,CAACnN,IAAI,CAAC6b,gBAAgB,CAAC;UAEjC,CAAC,MAAM;YAEN1O,SAAS,CAACnN,IAAI,CAACmQ,WAAW,CAACxN,EAAE,CAAC,CAAC;UAEhC;QAED;QAEA,OAAOwK,SAAS;MAEjB;MAEA,SAASkO,YAAYA,CAAC3R,UAAU,EAAEqS,iBAAiB,EAAE;QAEpD,MAAMd,OAAO,GAAG,EAAE;QAElB,KAAK,MAAM3O,IAAI,IAAI5C,UAAU,EAAE;UAE9B,MAAMD,QAAQ,GAAGC,UAAU,CAAC4C,IAAI,CAAC;UACjC,MAAMa,SAAS,GAAG2O,sBAAsB,CAACrS,QAAQ,CAACsK,YAAY,EAAEgI,iBAAiB,CAAC,CAAC,CAAC;;UAEpF,IAAI5O,SAAS,CAACtN,MAAM,KAAK,CAAC,EAAE;YAE3B,IAAIyM,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,YAAY,EAAE;cAE9Ca,SAAS,CAACnN,IAAI,CAAC,IAAItC,KAAK,CAACse,iBAAiB,CAAC,CAAC,CAAC;YAE9C,CAAC,MAAM;cAEN7O,SAAS,CAACnN,IAAI,CAAC,IAAItC,KAAK,CAACqQ,iBAAiB,CAAC,CAAC,CAAC;YAE9C;UAED,CAAC,CAAC;;UAGF,MAAMkO,QAAQ,GAAGxS,QAAQ,CAACxH,IAAI,CAACia,UAAU,CAACzR,SAAS,KAAKlJ,SAAS,CAAC,CAAC;;UAEnE,MAAMuM,QAAQ,GAAGX,SAAS,CAACtN,MAAM,KAAK,CAAC,GAAGsN,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC;;UAEpE,IAAIpM,MAAM;UAEV,QAAQuL,IAAI;YAEX,KAAK,OAAO;cACXvL,MAAM,GAAG,IAAIrD,KAAK,CAACye,YAAY,CAAC1S,QAAQ,CAACxH,IAAI,EAAE6L,QAAQ,CAAC;cACxD;YAED,KAAK,YAAY;cAChB/M,MAAM,GAAG,IAAIrD,KAAK,CAAC0e,IAAI,CAAC3S,QAAQ,CAACxH,IAAI,EAAE6L,QAAQ,CAAC;cAChD;YAED,KAAK,WAAW;YAChB,KAAK,UAAU;cACd,IAAImO,QAAQ,EAAE;gBAEblb,MAAM,GAAG,IAAIrD,KAAK,CAAC2e,WAAW,CAAC5S,QAAQ,CAACxH,IAAI,EAAE6L,QAAQ,CAAC;cAExD,CAAC,MAAM;gBAEN/M,MAAM,GAAG,IAAIrD,KAAK,CAAC4e,IAAI,CAAC7S,QAAQ,CAACxH,IAAI,EAAE6L,QAAQ,CAAC;cAEjD;cAEA;UAEF;UAEAmN,OAAO,CAACjb,IAAI,CAACe,MAAM,CAAC;QAErB;QAEA,OAAOka,OAAO;MAEf;MAEA,SAASpB,OAAOA,CAAClX,EAAE,EAAE;QAEpB,OAAOb,OAAO,CAACgD,KAAK,CAACnC,EAAE,CAAC,KAAKpB,SAAS;MAEvC;MAEA,SAASyD,OAAOA,CAACrC,EAAE,EAAE;QAEpB,OAAOP,QAAQ,CAACN,OAAO,CAACgD,KAAK,CAACnC,EAAE,CAAC,EAAEqY,SAAS,CAAC;MAE9C,CAAC,CAAC;;MAGF,SAASuB,gBAAgBA,CAAChd,GAAG,EAAE;QAE9B,MAAM0C,IAAI,GAAG;UACZzC,IAAI,EAAED,GAAG,CAACkC,YAAY,CAAC,MAAM,CAAC;UAC9BgZ,QAAQ,EAAE;QACX,CAAC;QACDrB,YAAY,CAAC7Z,GAAG,CAAC;QACjB,MAAMwC,QAAQ,GAAGzC,oBAAoB,CAACC,GAAG,EAAE,MAAM,CAAC;QAElD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,QAAQ,CAAClC,MAAM,EAAEF,CAAC,EAAE,EAAE;UAEzCsC,IAAI,CAACwY,QAAQ,CAACza,IAAI,CAACsZ,SAAS,CAACvX,QAAQ,CAACpC,CAAC,CAAC,CAAC,CAAC;QAE3C;QAEAmC,OAAO,CAAC6V,YAAY,CAACpY,GAAG,CAACkC,YAAY,CAAC,IAAI,CAAC,CAAC,GAAGQ,IAAI;MAEpD;MAEA,SAASua,gBAAgBA,CAACva,IAAI,EAAE;QAE/B,MAAMwa,KAAK,GAAG,IAAI/e,KAAK,CAACie,KAAK,CAAC,CAAC;QAC/Bc,KAAK,CAACjd,IAAI,GAAGyC,IAAI,CAACzC,IAAI;QACtB,MAAMib,QAAQ,GAAGxY,IAAI,CAACwY,QAAQ;QAE9B,KAAK,IAAI9a,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8a,QAAQ,CAAC5a,MAAM,EAAEF,CAAC,EAAE,EAAE;UAEzC,MAAMG,KAAK,GAAG2a,QAAQ,CAAC9a,CAAC,CAAC;UACzB8c,KAAK,CAACb,GAAG,CAAC5W,OAAO,CAAClF,KAAK,CAAC6C,EAAE,CAAC,CAAC;QAE7B;QAEA,OAAO8Z,KAAK;MAEb;MAEA,SAASjC,cAAcA,CAAC7X,EAAE,EAAE;QAE3B,OAAOb,OAAO,CAAC6V,YAAY,CAAChV,EAAE,CAAC,KAAKpB,SAAS;MAE9C;MAEA,SAASwW,cAAcA,CAACpV,EAAE,EAAE;QAE3B,OAAOP,QAAQ,CAACN,OAAO,CAAC6V,YAAY,CAAChV,EAAE,CAAC,EAAE6Z,gBAAgB,CAAC;MAE5D,CAAC,CAAC;;MAGF,SAASE,UAAUA,CAACnd,GAAG,EAAE;QAExB,MAAMya,QAAQ,GAAG1a,oBAAoB,CAACC,GAAG,EAAE,uBAAuB,CAAC,CAAC,CAAC,CAAC;QACtE,OAAOwY,cAAc,CAACrX,OAAO,CAACsZ,QAAQ,CAACvY,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;MAE7D;MAEA,SAASkb,eAAeA,CAAA,EAAG;QAE1B,MAAMrU,KAAK,GAAGxG,OAAO,CAACwG,KAAK;QAE3B,IAAIxH,OAAO,CAACwH,KAAK,CAAC,KAAK,IAAI,EAAE;UAE5B,IAAIxH,OAAO,CAACgB,OAAO,CAACkB,UAAU,CAAC,KAAK,KAAK,EAAE;YAE1C;YACA,MAAMgB,MAAM,GAAG,EAAE;YAEjB,KAAK,MAAMrB,EAAE,IAAIb,OAAO,CAACkB,UAAU,EAAE;cAEpC,MAAMyF,eAAe,GAAG7D,YAAY,CAACjC,EAAE,CAAC;cAExC,KAAK,IAAIhD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG6I,eAAe,CAAC5I,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;gBAEvDqE,MAAM,CAAChE,IAAI,CAACyI,eAAe,CAAC9I,CAAC,CAAC,CAAC;cAEhC;YAED;YAEAqD,UAAU,CAAChD,IAAI,CAAC,IAAItC,KAAK,CAACgL,aAAa,CAAC,SAAS,EAAE,CAAE,CAAC,EAAE1E,MAAM,CAAC,CAAC;UAEjE;QAED,CAAC,MAAM;UAEN,KAAK,MAAMrB,EAAE,IAAI2F,KAAK,EAAE;YAEvBtF,UAAU,CAAChD,IAAI,CAAC2I,gBAAgB,CAAChG,EAAE,CAAC,CAAC;UAEtC;QAED;MAED,CAAC,CAAC;MACF;;MAGA,SAASia,iBAAiBA,CAACC,WAAW,EAAE;QAEvC,IAAIC,MAAM,GAAG,EAAE;QACf,MAAMC,KAAK,GAAG,CAACF,WAAW,CAAC;QAE3B,OAAOE,KAAK,CAACld,MAAM,EAAE;UAEpB,MAAMgF,IAAI,GAAGkY,KAAK,CAACzZ,KAAK,CAAC,CAAC;UAE1B,IAAIuB,IAAI,CAACnC,QAAQ,KAAKsa,IAAI,CAACC,SAAS,EAAE;YAErCH,MAAM,IAAIjY,IAAI,CAACnD,WAAW;UAE3B,CAAC,MAAM;YAENob,MAAM,IAAI,IAAI;YACdC,KAAK,CAAC/c,IAAI,CAACkd,KAAK,CAACH,KAAK,EAAElY,IAAI,CAACnF,UAAU,CAAC;UAEzC;QAED;QAEA,OAAOod,MAAM,CAAC3c,IAAI,CAAC,CAAC;MAErB;MAEA,IAAInB,IAAI,CAACa,MAAM,KAAK,CAAC,EAAE;QAEtB,OAAO;UACNsd,KAAK,EAAE,IAAIzf,KAAK,CAAC0f,KAAK,CAAC;QACxB,CAAC;MAEF;MAEA,MAAM7d,GAAG,GAAG,IAAI8d,SAAS,CAAC,CAAC,CAACC,eAAe,CAACte,IAAI,EAAE,iBAAiB,CAAC;MACpE,MAAMkZ,OAAO,GAAG5Y,oBAAoB,CAACC,GAAG,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;MACvD,MAAMsd,WAAW,GAAGtd,GAAG,CAACD,oBAAoB,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;MAE9D,IAAIud,WAAW,KAAKtb,SAAS,EAAE;QAE9B;QACA,MAAMgc,YAAY,GAAGje,oBAAoB,CAACud,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;QAChE,IAAIW,SAAS;QAEb,IAAID,YAAY,EAAE;UAEjBC,SAAS,GAAGD,YAAY,CAAC7b,WAAW;QAErC,CAAC,MAAM;UAEN8b,SAAS,GAAGZ,iBAAiB,CAACC,WAAW,CAAC;QAE3C;QAEA1d,OAAO,CAACC,KAAK,CAAC,sDAAsD,EAAEoe,SAAS,CAAC;QAChF,OAAO,IAAI;MAEZ,CAAC,CAAC;;MAGF,MAAMC,OAAO,GAAGvF,OAAO,CAACzW,YAAY,CAAC,SAAS,CAAC;MAC/CtC,OAAO,CAAC4D,GAAG,CAAC,mCAAmC,EAAE0a,OAAO,CAAC;MACzD,MAAMC,KAAK,GAAGxc,UAAU,CAAC5B,oBAAoB,CAAC4Y,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;MACnE,MAAMvK,aAAa,GAAG,IAAIjQ,KAAK,CAACigB,aAAa,CAAC,IAAI,CAAC5f,OAAO,CAAC;MAC3D4P,aAAa,CAAChP,OAAO,CAAC,IAAI,CAACif,YAAY,IAAItf,IAAI,CAAC,CAACuf,cAAc,CAAC,IAAI,CAACC,WAAW,CAAC;MACjF,IAAIpQ,SAAS;MAEb,IAAIhQ,KAAK,CAACqgB,SAAS,EAAE;QAEpBrQ,SAAS,GAAG,IAAIhQ,KAAK,CAACqgB,SAAS,CAAC,IAAI,CAAChgB,OAAO,CAAC;QAC7C2P,SAAS,CAAC/O,OAAO,CAAC,IAAI,CAACif,YAAY,IAAItf,IAAI,CAAC;MAE7C,CAAC,CAAC;;MAGF,MAAM0E,UAAU,GAAG,EAAE;MACrB,IAAI4V,UAAU,GAAG,CAAC,CAAC;MACnB,IAAI/X,KAAK,GAAG,CAAC,CAAC,CAAC;;MAEf,MAAMiB,OAAO,GAAG;QACfkB,UAAU,EAAE,CAAC,CAAC;QACdsF,KAAK,EAAE,CAAC,CAAC;QACTS,WAAW,EAAE,CAAC,CAAC;QACfuC,MAAM,EAAE,CAAC,CAAC;QACVM,OAAO,EAAE,CAAC,CAAC;QACXuB,SAAS,EAAE,CAAC,CAAC;QACboD,OAAO,EAAE,CAAC,CAAC;QACXiB,MAAM,EAAE,CAAC,CAAC;QACV9H,UAAU,EAAE,CAAC,CAAC;QACd5E,KAAK,EAAE,CAAC,CAAC;QACT6S,YAAY,EAAE,CAAC,CAAC;QAChBzC,gBAAgB,EAAE,CAAC,CAAC;QACpBuB,aAAa,EAAE,CAAC,CAAC;QACjBO,gBAAgB,EAAE,CAAC;MACpB,CAAC;MACDrV,YAAY,CAACuW,OAAO,EAAE,oBAAoB,EAAE,WAAW,EAAE7V,cAAc,CAAC;MACxEV,YAAY,CAACuW,OAAO,EAAE,yBAAyB,EAAE,gBAAgB,EAAE/P,kBAAkB,CAAC;MACtFxG,YAAY,CAACuW,OAAO,EAAE,qBAAqB,EAAE,YAAY,EAAEtP,eAAe,CAAC;MAC3EjH,YAAY,CAACuW,OAAO,EAAE,gBAAgB,EAAE,OAAO,EAAE9M,UAAU,CAAC;MAC5DzJ,YAAY,CAACuW,OAAO,EAAE,iBAAiB,EAAE,QAAQ,EAAEzM,WAAW,CAAC;MAC/D9J,YAAY,CAACuW,OAAO,EAAE,mBAAmB,EAAE,UAAU,EAAEhL,aAAa,CAAC;MACrEvL,YAAY,CAACuW,OAAO,EAAE,iBAAiB,EAAE,QAAQ,EAAE9H,WAAW,CAAC;MAC/DzO,YAAY,CAACuW,OAAO,EAAE,gBAAgB,EAAE,OAAO,EAAE5G,UAAU,CAAC;MAC5D3P,YAAY,CAACuW,OAAO,EAAE,oBAAoB,EAAE,UAAU,EAAE1F,aAAa,CAAC;MACtE7Q,YAAY,CAACuW,OAAO,EAAE,eAAe,EAAE,MAAM,EAAEoB,SAAS,CAAC;MACzD3X,YAAY,CAACuW,OAAO,EAAE,uBAAuB,EAAE,cAAc,EAAEqE,gBAAgB,CAAC;MAChF5a,YAAY,CAACuW,OAAO,EAAE,2BAA2B,EAAE,kBAAkB,EAAEnD,oBAAoB,CAAC;MAC5FpT,YAAY,CAACuW,OAAO,EAAE,wBAAwB,EAAE,eAAe,EAAE5B,iBAAiB,CAAC;MACnF3U,YAAY,CAACuW,OAAO,EAAE,OAAO,EAAE,2BAA2B,EAAErB,oBAAoB,CAAC;MACjF7U,YAAY,CAACF,OAAO,CAACkB,UAAU,EAAEe,cAAc,CAAC;MAChD/B,YAAY,CAACF,OAAO,CAACwG,KAAK,EAAEC,kBAAkB,CAAC;MAC/CvG,YAAY,CAACF,OAAO,CAACiH,WAAW,EAAES,eAAe,CAAC;MAClDxH,YAAY,CAACF,OAAO,CAACwJ,MAAM,EAAEC,UAAU,CAAC;MACxCvJ,YAAY,CAACF,OAAO,CAAC8J,OAAO,EAAEoB,WAAW,CAAC;MAC1ChL,YAAY,CAACF,OAAO,CAACqL,SAAS,EAAES,aAAa,CAAC;MAC9C5L,YAAY,CAACF,OAAO,CAACyO,OAAO,EAAEG,WAAW,CAAC;MAC1C1O,YAAY,CAACF,OAAO,CAAC0P,MAAM,EAAEQ,UAAU,CAAC;MACxChQ,YAAY,CAACF,OAAO,CAAC4H,UAAU,EAAE6J,aAAa,CAAC;MAC/CvR,YAAY,CAACF,OAAO,CAAC6V,YAAY,EAAE6E,gBAAgB,CAAC;MACpDG,eAAe,CAAC,CAAC;MACjBpF,eAAe,CAAC,CAAC;MACjB,MAAM4F,KAAK,GAAGT,UAAU,CAACpd,oBAAoB,CAAC4Y,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;MACnEiF,KAAK,CAACna,UAAU,GAAGA,UAAU;MAE7B,IAAI0a,KAAK,CAACrc,MAAM,KAAK,MAAM,EAAE;QAE5B8b,KAAK,CAACzW,UAAU,CAACsX,YAAY,CAAC,IAAItgB,KAAK,CAACugB,KAAK,CAAC,CAAEnM,IAAI,CAACoM,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAEpE;MAEAf,KAAK,CAAC1W,KAAK,CAAC0X,cAAc,CAACT,KAAK,CAACvc,IAAI,CAAC;MACtC,OAAO;QACN,IAAI6B,UAAUA,CAAA,EAAG;UAEhB7D,OAAO,CAAC2G,IAAI,CAAC,0EAA0E,CAAC;UACxF,OAAO9C,UAAU;QAElB,CAAC;QAED4V,UAAU,EAAEA,UAAU;QACtB9W,OAAO,EAAEA,OAAO;QAChBqb,KAAK,EAAEA;MACR,CAAC;IAEF;EAED;EAEAzf,KAAK,CAACE,aAAa,GAAGA,aAAa;AAEpC,CAAC,EAAE,CAAC;AAEJwgB,MAAM,CAACC,OAAO,GAAGA,OAAO,GAAG3gB,KAAK,CAACE,aAAa","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
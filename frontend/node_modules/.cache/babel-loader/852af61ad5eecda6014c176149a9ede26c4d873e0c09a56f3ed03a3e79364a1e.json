{"ast":null,"code":"/**\r\n * @author peterqliu / https://github.com/peterqliu\r\n * @author jscastro / https://github.com/jscastro76\r\n */\nconst THREE = require(\"../three.js\");\nconst utils = require(\"../utils/utils.js\");\nconst ThreeboxConstants = require(\"../utils/constants.js\");\nfunction CameraSync(map, camera, world) {\n  //    console.log(\"CameraSync constructor\");\n  this.map = map;\n  this.camera = camera;\n  this.active = true;\n  this.camera.matrixAutoUpdate = false; // We're in charge of the camera now!\n\n  // Postion and configure the world group so we can scale it appropriately when the camera zooms\n  this.world = world || new THREE.Group();\n  this.world.position.x = this.world.position.y = ThreeboxConstants.WORLD_SIZE / 2;\n  this.world.matrixAutoUpdate = false;\n\n  // set up basic camera state\n  this.state = {\n    translateCenter: new THREE.Matrix4().makeTranslation(ThreeboxConstants.WORLD_SIZE / 2, -ThreeboxConstants.WORLD_SIZE / 2, 0),\n    worldSizeRatio: ThreeboxConstants.TILE_SIZE / ThreeboxConstants.WORLD_SIZE,\n    worldSize: ThreeboxConstants.TILE_SIZE * this.map.transform.scale\n  };\n\n  // Listen for move events from the map and update the Three.js camera\n  let _this = this; // keep the function on _this\n  this.map.on('move', function () {\n    _this.updateCamera();\n  }).on('resize', function () {\n    _this.setupCamera();\n  });\n  this.setupCamera();\n}\nCameraSync.prototype = {\n  setupCamera: function () {\n    const t = this.map.transform;\n    this.camera.aspect = t.width / t.height; //bug fixed, if aspect is not reset raycast will fail on map resize\n    this.halfFov = t._fov / 2;\n    this.cameraToCenterDistance = 0.5 / Math.tan(this.halfFov) * t.height;\n    const maxPitch = t._maxPitch * Math.PI / 180;\n    this.acuteAngle = Math.PI / 2 - maxPitch;\n    this.updateCamera();\n  },\n  updateCamera: function (ev) {\n    if (!this.camera) {\n      console.log('nocamera');\n      return;\n    }\n    const t = this.map.transform;\n    this.camera.aspect = t.width / t.height; //bug fixed, if aspect is not reset raycast will fail on map resize\n    const offset = t.centerOffset || new THREE.Vector3(); //{ x: t.width / 2, y: t.height / 2 };\n    let farZ = 0;\n    let furthestDistance = 0;\n    this.halfFov = t._fov / 2;\n    const groundAngle = Math.PI / 2 + t._pitch;\n    const pitchAngle = Math.cos(Math.PI / 2 - t._pitch); //pitch seems to influence heavily the depth calculation and cannot be more than 60 = PI/3 < v1 and 85 > v2\n    this.cameraToCenterDistance = 0.5 / Math.tan(this.halfFov) * t.height;\n    let pixelsPerMeter = 1;\n    const worldSize = this.worldSize();\n    if (this.map.tb.mapboxVersion >= 2.0) {\n      // mapbox version >= 2.0\n      pixelsPerMeter = this.mercatorZfromAltitude(1, t.center.lat) * worldSize;\n      const fovAboveCenter = t._fov * (0.5 + t.centerOffset.y / t.height);\n\n      // Adjust distance to MSL by the minimum possible elevation visible on screen,\n      // this way the far plane is pushed further in the case of negative elevation.\n      const minElevationInPixels = t.elevation ? t.elevation.getMinElevationBelowMSL() * pixelsPerMeter : 0;\n      const cameraToSeaLevelDistance = (t._camera.position[2] * worldSize - minElevationInPixels) / Math.cos(t._pitch);\n      const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(utils.clamp(Math.PI - groundAngle - fovAboveCenter, 0.01, Math.PI - 0.01));\n\n      // Calculate z distance of the farthest fragment that should be rendered.\n      furthestDistance = pitchAngle * topHalfSurfaceDistance + cameraToSeaLevelDistance;\n\n      // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\n      const horizonDistance = cameraToSeaLevelDistance * (1 / t._horizonShift);\n      farZ = Math.min(furthestDistance * 1.01, horizonDistance);\n    } else {\n      // mapbox version < 2.0 or azure maps\n      // Furthest distance optimized by @jscastro76\n      const topHalfSurfaceDistance = Math.sin(this.halfFov) * this.cameraToCenterDistance / Math.sin(Math.PI - groundAngle - this.halfFov);\n\n      // Calculate z distance of the farthest fragment that should be rendered. \n      furthestDistance = pitchAngle * topHalfSurfaceDistance + this.cameraToCenterDistance;\n\n      // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\n      farZ = furthestDistance * 1.01;\n    }\n    this.cameraTranslateZ = new THREE.Matrix4().makeTranslation(0, 0, this.cameraToCenterDistance);\n\n    // someday @ansis set further near plane to fix precision for deckgl,so we should fix it to use mapbox-gl v1.3+ correctly\n    // https://github.com/mapbox/mapbox-gl-js/commit/5cf6e5f523611bea61dae155db19a7cb19eb825c#diff-5dddfe9d7b5b4413ee54284bc1f7966d\n    const nz = t.height / 50; //min near z as coded by @ansis\n    const nearZ = Math.max(nz * pitchAngle, nz); //on changes in the pitch nz could be too low\n\n    const h = t.height;\n    const w = t.width;\n    if (this.camera instanceof THREE.OrthographicCamera) {\n      this.camera.projectionMatrix = utils.makeOrthographicMatrix(w / -2, w / 2, h / 2, h / -2, nearZ, farZ);\n    } else {\n      this.camera.projectionMatrix = utils.makePerspectiveMatrix(t._fov, w / h, nearZ, farZ);\n    }\n    this.camera.projectionMatrix.elements[8] = -offset.x * 2 / t.width;\n    this.camera.projectionMatrix.elements[9] = offset.y * 2 / t.height;\n\n    // Unlike the Mapbox GL JS camera, separate camera translation and rotation out into its world matrix\n    // If this is applied directly to the projection matrix, it will work OK but break raycasting\n    let cameraWorldMatrix = this.calcCameraMatrix(t._pitch, t.angle);\n    // When terrain layers are included, height of 3D layers must be modified from t_camera.z * worldSize\n    if (t.elevation) cameraWorldMatrix.elements[14] = t._camera.position[2] * worldSize;\n    //this.camera.matrixWorld.elements is equivalent to t._camera._transform\n    this.camera.matrixWorld.copy(cameraWorldMatrix);\n    let zoomPow = t.scale * this.state.worldSizeRatio;\n    // Handle scaling and translation of objects in the map in the world's matrix transform, not the camera\n    let scale = new THREE.Matrix4();\n    let translateMap = new THREE.Matrix4();\n    let rotateMap = new THREE.Matrix4();\n    scale.makeScale(zoomPow, zoomPow, zoomPow);\n    let x = t.x || t.point.x;\n    let y = t.y || t.point.y;\n    translateMap.makeTranslation(-x, y, 0);\n    rotateMap.makeRotationZ(Math.PI);\n    this.world.matrix = new THREE.Matrix4().premultiply(rotateMap).premultiply(this.state.translateCenter).premultiply(scale).premultiply(translateMap);\n\n    // utils.prettyPrintMatrix(this.camera.projectionMatrix.elements);\n    this.map.fire('CameraSynced', {\n      detail: {\n        nearZ: nearZ,\n        farZ: farZ,\n        pitch: t._pitch,\n        angle: t.angle,\n        furthestDistance: furthestDistance,\n        cameraToCenterDistance: this.cameraToCenterDistance,\n        t: this.map.transform,\n        tbProjMatrix: this.camera.projectionMatrix.elements,\n        tbWorldMatrix: this.world.matrix.elements,\n        cameraSyn: CameraSync\n      }\n    });\n  },\n  worldSize() {\n    let t = this.map.transform;\n    return t.tileSize * t.scale;\n  },\n  worldSizeFromZoom() {\n    let t = this.map.transform;\n    return Math.pow(2.0, t.zoom) * t.tileSize;\n  },\n  mercatorZfromAltitude(altitude, lat) {\n    return altitude / this.circumferenceAtLatitude(lat);\n  },\n  mercatorZfromZoom() {\n    return this.cameraToCenterDistance / this.worldSizeFromZoom();\n  },\n  circumferenceAtLatitude(latitude) {\n    return ThreeboxConstants.EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);\n  },\n  calcCameraMatrix(pitch, angle, trz) {\n    const t = this.map.transform;\n    const _pitch = pitch === undefined ? t._pitch : pitch;\n    const _angle = angle === undefined ? t.angle : angle;\n    const _trz = trz === undefined ? this.cameraTranslateZ : trz;\n    return new THREE.Matrix4().premultiply(_trz).premultiply(new THREE.Matrix4().makeRotationX(_pitch)).premultiply(new THREE.Matrix4().makeRotationZ(_angle));\n  },\n  updateCameraState() {\n    let t = this.map.transform;\n    if (!t.height) return;\n\n    // Set camera orientation and move it to a proper distance from the map\n    //t._camera.setPitchBearing(t._pitch, t.angle);\n\n    const dir = t._camera.forward();\n    const distance = t.cameraToCenterDistance;\n    const center = t.point;\n\n    // Use camera zoom (if terrain is enabled) to maintain constant altitude to sea level\n    const zoom = t._cameraZoom ? t._cameraZoom : t._zoom;\n    const altitude = this.mercatorZfromZoom(t);\n    const height = altitude - this.mercatorZfromAltitude(t._centerAltitude, t.center.lat);\n\n    // simplified version of: this._worldSizeFromZoom(this._zoomFromMercatorZ(height))\n    const updatedWorldSize = t.cameraToCenterDistance / height;\n    return [center.x / this.worldSize() - dir[0] * distance / updatedWorldSize, center.y / this.worldSize() - dir[1] * distance / updatedWorldSize, this.mercatorZfromAltitude(t._centerAltitude, t._center.lat) + -dir[2] * distance / updatedWorldSize];\n  },\n  getWorldToCamera(worldSize, pixelsPerMeter) {\n    // transformation chain from world space to camera space:\n    // 1. Height value (z) of renderables is in meters. Scale z coordinate by pixelsPerMeter\n    // 2. Transform from pixel coordinates to camera space with cameraMatrix^-1\n    // 3. flip Y if required\n\n    // worldToCamera: flip * cam^-1 * zScale\n    // cameraToWorld: (flip * cam^-1 * zScale)^-1 => (zScale^-1 * cam * flip^-1)\n    let t = this.map.transform;\n    const matrix = new THREE.Matrix4();\n    const matrixT = new THREE.Matrix4();\n\n    // Compute inverse of camera matrix and post-multiply negated translation\n    const o = t._camera._orientation;\n    const p = t._camera.position;\n    const invPosition = new THREE.Vector3(p[0], p[1], p[2]);\n    const quat = new THREE.Quaternion();\n    quat.set(o[0], o[1], o[2], o[3]);\n    const invOrientation = quat.conjugate();\n    invPosition.multiplyScalar(-worldSize);\n    matrixT.makeTranslation(invPosition.x, invPosition.y, invPosition.z);\n    matrix.makeRotationFromQuaternion(invOrientation).premultiply(matrixT);\n    //this would make the matrix exact to getWorldToCamera but breaks\n    //this.translate(matrix.elements, matrix.elements, invPosition);\n\n    // Pre-multiply y (2nd row)\n    matrix.elements[1] *= -1.0;\n    matrix.elements[5] *= -1.0;\n    matrix.elements[9] *= -1.0;\n    matrix.elements[13] *= -1.0;\n\n    // Post-multiply z (3rd column)\n    matrix.elements[8] *= pixelsPerMeter;\n    matrix.elements[9] *= pixelsPerMeter;\n    matrix.elements[10] *= pixelsPerMeter;\n    matrix.elements[11] *= pixelsPerMeter;\n    //console.log(matrix.elements);\n    return matrix;\n  },\n  translate(out, a, v) {\n    let x = v[0] || v.x,\n      y = v[1] || v.y,\n      z = v[2] || v.z;\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n    if (a === out) {\n      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n      a00 = a[0];\n      a01 = a[1];\n      a02 = a[2];\n      a03 = a[3];\n      a10 = a[4];\n      a11 = a[5];\n      a12 = a[6];\n      a13 = a[7];\n      a20 = a[8];\n      a21 = a[9];\n      a22 = a[10];\n      a23 = a[11];\n      out[0] = a00;\n      out[1] = a01;\n      out[2] = a02;\n      out[3] = a03;\n      out[4] = a10;\n      out[5] = a11;\n      out[6] = a12;\n      out[7] = a13;\n      out[8] = a20;\n      out[9] = a21;\n      out[10] = a22;\n      out[11] = a23;\n      out[12] = a00 * x + a10 * y + a20 * z + a[12];\n      out[13] = a01 * x + a11 * y + a21 * z + a[13];\n      out[14] = a02 * x + a12 * y + a22 * z + a[14];\n      out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n    return out;\n  }\n};\nmodule.exports = exports = CameraSync;","map":{"version":3,"names":["THREE","require","utils","ThreeboxConstants","CameraSync","map","camera","world","active","matrixAutoUpdate","Group","position","x","y","WORLD_SIZE","state","translateCenter","Matrix4","makeTranslation","worldSizeRatio","TILE_SIZE","worldSize","transform","scale","_this","on","updateCamera","setupCamera","prototype","t","aspect","width","height","halfFov","_fov","cameraToCenterDistance","Math","tan","maxPitch","_maxPitch","PI","acuteAngle","ev","console","log","offset","centerOffset","Vector3","farZ","furthestDistance","groundAngle","_pitch","pitchAngle","cos","pixelsPerMeter","tb","mapboxVersion","mercatorZfromAltitude","center","lat","fovAboveCenter","minElevationInPixels","elevation","getMinElevationBelowMSL","cameraToSeaLevelDistance","_camera","topHalfSurfaceDistance","sin","clamp","horizonDistance","_horizonShift","min","cameraTranslateZ","nz","nearZ","max","h","w","OrthographicCamera","projectionMatrix","makeOrthographicMatrix","makePerspectiveMatrix","elements","cameraWorldMatrix","calcCameraMatrix","angle","matrixWorld","copy","zoomPow","translateMap","rotateMap","makeScale","point","makeRotationZ","matrix","premultiply","fire","detail","pitch","tbProjMatrix","tbWorldMatrix","cameraSyn","tileSize","worldSizeFromZoom","pow","zoom","altitude","circumferenceAtLatitude","mercatorZfromZoom","latitude","EARTH_CIRCUMFERENCE","trz","undefined","_angle","_trz","makeRotationX","updateCameraState","dir","forward","distance","_cameraZoom","_zoom","_centerAltitude","updatedWorldSize","_center","getWorldToCamera","matrixT","o","_orientation","p","invPosition","quat","Quaternion","set","invOrientation","conjugate","multiplyScalar","z","makeRotationFromQuaternion","translate","out","a","v","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","module","exports"],"sources":["/Users/mihailbaleev/Documents/GitHub/lastochka_spraying/node_modules/threebox-plugin/src/camera/CameraSync.js"],"sourcesContent":["/**\r\n * @author peterqliu / https://github.com/peterqliu\r\n * @author jscastro / https://github.com/jscastro76\r\n */\r\nconst THREE = require(\"../three.js\");\r\nconst utils = require(\"../utils/utils.js\");\r\nconst ThreeboxConstants = require(\"../utils/constants.js\");\r\n\r\nfunction CameraSync(map, camera, world) {\r\n    //    console.log(\"CameraSync constructor\");\r\n    this.map = map;\r\n    this.camera = camera;\r\n    this.active = true;\r\n\r\n    this.camera.matrixAutoUpdate = false; // We're in charge of the camera now!\r\n\r\n    // Postion and configure the world group so we can scale it appropriately when the camera zooms\r\n    this.world = world || new THREE.Group();\r\n    this.world.position.x = this.world.position.y = ThreeboxConstants.WORLD_SIZE / 2\r\n    this.world.matrixAutoUpdate = false;\r\n\r\n    // set up basic camera state\r\n    this.state = {\r\n        translateCenter: new THREE.Matrix4().makeTranslation(ThreeboxConstants.WORLD_SIZE / 2, -ThreeboxConstants.WORLD_SIZE / 2, 0),\r\n        worldSizeRatio: ThreeboxConstants.TILE_SIZE / ThreeboxConstants.WORLD_SIZE,\r\n        worldSize: ThreeboxConstants.TILE_SIZE * this.map.transform.scale\r\n    };\r\n\r\n    // Listen for move events from the map and update the Three.js camera\r\n    let _this = this; // keep the function on _this\r\n    this.map\r\n        .on('move', function () {\r\n            _this.updateCamera();\r\n        })\r\n        .on('resize', function () {\r\n            _this.setupCamera();\r\n        })\r\n\r\n    this.setupCamera();\r\n}\r\n\r\nCameraSync.prototype = {\r\n    setupCamera: function () {\r\n        const t = this.map.transform;\r\n        this.camera.aspect = t.width / t.height; //bug fixed, if aspect is not reset raycast will fail on map resize\r\n        this.halfFov = t._fov / 2;\r\n        this.cameraToCenterDistance = 0.5 / Math.tan(this.halfFov) * t.height;\r\n        const maxPitch = t._maxPitch * Math.PI / 180;\r\n        this.acuteAngle = Math.PI / 2 - maxPitch;\r\n        this.updateCamera();\r\n    },\r\n\r\n    updateCamera: function (ev) {\r\n        if (!this.camera) {\r\n            console.log('nocamera')\r\n            return;\r\n        }\r\n\r\n        const t = this.map.transform;\r\n        this.camera.aspect = t.width / t.height; //bug fixed, if aspect is not reset raycast will fail on map resize\r\n        const offset = t.centerOffset || new THREE.Vector3(); //{ x: t.width / 2, y: t.height / 2 };\r\n        let farZ = 0;\r\n        let furthestDistance = 0;\r\n        this.halfFov = t._fov / 2;\r\n        const groundAngle = Math.PI / 2 + t._pitch;\r\n        const pitchAngle = Math.cos((Math.PI / 2) - t._pitch); //pitch seems to influence heavily the depth calculation and cannot be more than 60 = PI/3 < v1 and 85 > v2\r\n        this.cameraToCenterDistance = 0.5 / Math.tan(this.halfFov) * t.height;\r\n        let pixelsPerMeter = 1;\r\n        const worldSize = this.worldSize();\r\n\r\n        if (this.map.tb.mapboxVersion >= 2.0) {\r\n            // mapbox version >= 2.0\r\n            pixelsPerMeter = this.mercatorZfromAltitude(1, t.center.lat) * worldSize;\r\n            const fovAboveCenter = t._fov * (0.5 + t.centerOffset.y / t.height);\r\n\r\n            // Adjust distance to MSL by the minimum possible elevation visible on screen,\r\n            // this way the far plane is pushed further in the case of negative elevation.\r\n            const minElevationInPixels = t.elevation ? t.elevation.getMinElevationBelowMSL() * pixelsPerMeter : 0;\r\n            const cameraToSeaLevelDistance = ((t._camera.position[2] * worldSize) - minElevationInPixels) / Math.cos(t._pitch);\r\n            const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(utils.clamp(Math.PI - groundAngle - fovAboveCenter, 0.01, Math.PI - 0.01));\r\n\r\n            // Calculate z distance of the farthest fragment that should be rendered.\r\n            furthestDistance = pitchAngle * topHalfSurfaceDistance + cameraToSeaLevelDistance;\r\n\r\n            // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\r\n            const horizonDistance = cameraToSeaLevelDistance * (1 / t._horizonShift);\r\n            farZ = Math.min(furthestDistance * 1.01, horizonDistance);\r\n        } else {\r\n            // mapbox version < 2.0 or azure maps\r\n            // Furthest distance optimized by @jscastro76\r\n            const topHalfSurfaceDistance = Math.sin(this.halfFov) * this.cameraToCenterDistance / Math.sin(Math.PI - groundAngle - this.halfFov);\r\n\r\n            // Calculate z distance of the farthest fragment that should be rendered. \r\n            furthestDistance = pitchAngle * topHalfSurfaceDistance + this.cameraToCenterDistance;\r\n\r\n            // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`\r\n            farZ = furthestDistance * 1.01;\r\n        }\r\n        this.cameraTranslateZ = new THREE.Matrix4().makeTranslation(0, 0, this.cameraToCenterDistance);\r\n\r\n        // someday @ansis set further near plane to fix precision for deckgl,so we should fix it to use mapbox-gl v1.3+ correctly\r\n        // https://github.com/mapbox/mapbox-gl-js/commit/5cf6e5f523611bea61dae155db19a7cb19eb825c#diff-5dddfe9d7b5b4413ee54284bc1f7966d\r\n        const nz = (t.height / 50); //min near z as coded by @ansis\r\n        const nearZ = Math.max(nz * pitchAngle, nz); //on changes in the pitch nz could be too low\r\n\r\n        const h = t.height;\r\n        const w = t.width;\r\n        if (this.camera instanceof THREE.OrthographicCamera) {\r\n            this.camera.projectionMatrix = utils.makeOrthographicMatrix(w / - 2, w / 2, h / 2, h / - 2, nearZ, farZ);\r\n        } else {\r\n            this.camera.projectionMatrix = utils.makePerspectiveMatrix(t._fov, w / h, nearZ, farZ);\r\n        }\r\n        this.camera.projectionMatrix.elements[8] = -offset.x * 2 / t.width;\r\n        this.camera.projectionMatrix.elements[9] = offset.y * 2 / t.height;\r\n\r\n        // Unlike the Mapbox GL JS camera, separate camera translation and rotation out into its world matrix\r\n        // If this is applied directly to the projection matrix, it will work OK but break raycasting\r\n        let cameraWorldMatrix = this.calcCameraMatrix(t._pitch, t.angle);\r\n        // When terrain layers are included, height of 3D layers must be modified from t_camera.z * worldSize\r\n        if (t.elevation) cameraWorldMatrix.elements[14] = t._camera.position[2] * worldSize;\r\n        //this.camera.matrixWorld.elements is equivalent to t._camera._transform\r\n        this.camera.matrixWorld.copy(cameraWorldMatrix);\r\n        \r\n        let zoomPow = t.scale * this.state.worldSizeRatio;\r\n        // Handle scaling and translation of objects in the map in the world's matrix transform, not the camera\r\n        let scale = new THREE.Matrix4;\r\n        let translateMap = new THREE.Matrix4;\r\n        let rotateMap = new THREE.Matrix4;\r\n\r\n        scale.makeScale(zoomPow, zoomPow, zoomPow);\r\n\r\n        let x = t.x || t.point.x;\r\n        let y = t.y || t.point.y;\r\n        translateMap.makeTranslation(-x, y, 0);\r\n        rotateMap.makeRotationZ(Math.PI);\r\n\r\n        this.world.matrix = new THREE.Matrix4()\r\n            .premultiply(rotateMap)\r\n            .premultiply(this.state.translateCenter)\r\n            .premultiply(scale)\r\n            .premultiply(translateMap)\r\n\r\n        // utils.prettyPrintMatrix(this.camera.projectionMatrix.elements);\r\n        this.map.fire('CameraSynced', { detail: { nearZ: nearZ, farZ: farZ, pitch: t._pitch, angle: t.angle, furthestDistance: furthestDistance, cameraToCenterDistance: this.cameraToCenterDistance, t: this.map.transform, tbProjMatrix: this.camera.projectionMatrix.elements, tbWorldMatrix: this.world.matrix.elements, cameraSyn: CameraSync } });\r\n\r\n    },\r\n\r\n    worldSize() {\r\n        let t = this.map.transform;\r\n        return t.tileSize * t.scale;\r\n    },\r\n\r\n    worldSizeFromZoom() {\r\n        let t = this.map.transform;\r\n        return Math.pow(2.0, t.zoom) * t.tileSize;\r\n    },\r\n\r\n    mercatorZfromAltitude(altitude, lat) {\r\n        return altitude / this.circumferenceAtLatitude(lat);\r\n    },\r\n\r\n    mercatorZfromZoom() {\r\n        return this.cameraToCenterDistance / this.worldSizeFromZoom();\r\n    },\r\n\r\n    circumferenceAtLatitude(latitude) {\r\n        return ThreeboxConstants.EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);\r\n    },\r\n\r\n    calcCameraMatrix(pitch, angle, trz) {\r\n        const t = this.map.transform;\r\n        const _pitch = (pitch === undefined) ? t._pitch : pitch;\r\n        const _angle = (angle === undefined) ? t.angle : angle;\r\n        const _trz = (trz === undefined) ? this.cameraTranslateZ : trz;\r\n\r\n        return new THREE.Matrix4()\r\n            .premultiply(_trz)\r\n            .premultiply(new THREE.Matrix4().makeRotationX(_pitch))\r\n            .premultiply(new THREE.Matrix4().makeRotationZ(_angle));\r\n    },\r\n\r\n    updateCameraState() {\r\n        let t = this.map.transform;\r\n        if (!t.height) return;\r\n\r\n        // Set camera orientation and move it to a proper distance from the map\r\n        //t._camera.setPitchBearing(t._pitch, t.angle);\r\n\r\n        const dir = t._camera.forward();\r\n        const distance = t.cameraToCenterDistance;\r\n        const center = t.point;\r\n\r\n        // Use camera zoom (if terrain is enabled) to maintain constant altitude to sea level\r\n        const zoom = t._cameraZoom ? t._cameraZoom : t._zoom;\r\n        const altitude = this.mercatorZfromZoom(t);\r\n        const height = altitude - this.mercatorZfromAltitude(t._centerAltitude, t.center.lat);\r\n\r\n        // simplified version of: this._worldSizeFromZoom(this._zoomFromMercatorZ(height))\r\n        const updatedWorldSize = t.cameraToCenterDistance / height;\r\n        return [\r\n            center.x / this.worldSize() - (dir[0] * distance) / updatedWorldSize,\r\n            center.y / this.worldSize() - (dir[1] * distance) / updatedWorldSize,\r\n            this.mercatorZfromAltitude(t._centerAltitude, t._center.lat) + (-dir[2] * distance) / updatedWorldSize\r\n        ];\r\n\r\n    },\r\n\r\n    getWorldToCamera(worldSize, pixelsPerMeter) {\r\n        // transformation chain from world space to camera space:\r\n        // 1. Height value (z) of renderables is in meters. Scale z coordinate by pixelsPerMeter\r\n        // 2. Transform from pixel coordinates to camera space with cameraMatrix^-1\r\n        // 3. flip Y if required\r\n\r\n        // worldToCamera: flip * cam^-1 * zScale\r\n        // cameraToWorld: (flip * cam^-1 * zScale)^-1 => (zScale^-1 * cam * flip^-1)\r\n        let t = this.map.transform;\r\n        const matrix = new THREE.Matrix4();\r\n        const matrixT = new THREE.Matrix4();\r\n\r\n        // Compute inverse of camera matrix and post-multiply negated translation\r\n        const o = t._camera._orientation;\r\n        const p = t._camera.position;\r\n        const invPosition = new THREE.Vector3(p[0], p[1], p[2]);\r\n\r\n        const quat = new THREE.Quaternion();\r\n        quat.set(o[0], o[1], o[2], o[3]);\r\n        const invOrientation = quat.conjugate();\r\n        invPosition.multiplyScalar(-worldSize);\r\n\r\n        matrixT.makeTranslation(invPosition.x, invPosition.y, invPosition.z);\r\n        matrix\r\n            .makeRotationFromQuaternion(invOrientation)\r\n            .premultiply(matrixT);\r\n        //this would make the matrix exact to getWorldToCamera but breaks\r\n        //this.translate(matrix.elements, matrix.elements, invPosition);\r\n\r\n        // Pre-multiply y (2nd row)\r\n        matrix.elements[1] *= -1.0;\r\n        matrix.elements[5] *= -1.0;\r\n        matrix.elements[9] *= -1.0;\r\n        matrix.elements[13] *= -1.0;\r\n\r\n        // Post-multiply z (3rd column)\r\n        matrix.elements[8] *= pixelsPerMeter;\r\n        matrix.elements[9] *= pixelsPerMeter;\r\n        matrix.elements[10] *= pixelsPerMeter;\r\n        matrix.elements[11] *= pixelsPerMeter;\r\n        //console.log(matrix.elements);\r\n        return matrix;\r\n    },\r\n\r\n    translate(out, a, v) {\r\n        let x = v[0] || v.x,\r\n            y = v[1] || v.y,\r\n            z = v[2] || v.z;\r\n        let a00, a01, a02, a03;\r\n        let a10, a11, a12, a13;\r\n        let a20, a21, a22, a23;\r\n        if (a === out) {\r\n            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\r\n            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\r\n            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\r\n            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\r\n        } else {\r\n            a00 = a[0];\r\n            a01 = a[1];\r\n            a02 = a[2];\r\n            a03 = a[3];\r\n            a10 = a[4];\r\n            a11 = a[5];\r\n            a12 = a[6];\r\n            a13 = a[7];\r\n            a20 = a[8];\r\n            a21 = a[9];\r\n            a22 = a[10];\r\n            a23 = a[11];\r\n            out[0] = a00;\r\n            out[1] = a01;\r\n            out[2] = a02;\r\n            out[3] = a03;\r\n            out[4] = a10;\r\n            out[5] = a11;\r\n            out[6] = a12;\r\n            out[7] = a13;\r\n            out[8] = a20;\r\n            out[9] = a21;\r\n            out[10] = a22;\r\n            out[11] = a23;\r\n            out[12] = a00 * x + a10 * y + a20 * z + a[12];\r\n            out[13] = a01 * x + a11 * y + a21 * z + a[13];\r\n            out[14] = a02 * x + a12 * y + a22 * z + a[14];\r\n            out[15] = a03 * x + a13 * y + a23 * z + a[15];\r\n        }\r\n        return out;\r\n    }\r\n}\r\n\r\nmodule.exports = exports = CameraSync;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"const THREE = require('../../three.js');\n\n/**\r\n * @author Rich Tibbett / https://github.com/richtr\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Tony Parisi / http://www.tonyparisi.com/\r\n * @author Takahiro / https://github.com/takahirox\r\n * @author Don McCurdy / https://www.donmccurdy.com\r\n */\n\n(function () {\n  class GLTFLoader extends THREE.Loader {\n    constructor(manager) {\n      super(manager);\n      this.dracoLoader = null;\n      this.ktx2Loader = null;\n      this.meshoptDecoder = null;\n      this.pluginCallbacks = [];\n      this.register(function (parser) {\n        return new GLTFMaterialsClearcoatExtension(parser);\n      });\n      this.register(function (parser) {\n        return new GLTFTextureBasisUExtension(parser);\n      });\n      this.register(function (parser) {\n        return new GLTFTextureWebPExtension(parser);\n      });\n      this.register(function (parser) {\n        return new GLTFMaterialsTransmissionExtension(parser);\n      });\n      this.register(function (parser) {\n        return new GLTFMaterialsVolumeExtension(parser);\n      });\n      this.register(function (parser) {\n        return new GLTFMaterialsIorExtension(parser);\n      });\n      this.register(function (parser) {\n        return new GLTFMaterialsSpecularExtension(parser);\n      });\n      this.register(function (parser) {\n        return new GLTFLightsExtension(parser);\n      });\n      this.register(function (parser) {\n        return new GLTFMeshoptCompression(parser);\n      });\n    }\n    load(url, onLoad, onProgress, onError) {\n      const scope = this;\n      let resourcePath;\n      if (this.resourcePath !== '') {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== '') {\n        resourcePath = this.path;\n      } else {\n        resourcePath = THREE.LoaderUtils.extractUrlBase(url);\n      } // Tells the LoadingManager to track an extra item, which resolves after\n      // the model is fully loaded. This means the count of items loaded will\n      // be incorrect, but ensures manager.onLoad() does not fire early.\n\n      this.manager.itemStart(url);\n      const _onError = function (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      };\n      const loader = new THREE.FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          scope.parse(data, resourcePath, function (gltf) {\n            onLoad(gltf);\n            scope.manager.itemEnd(url);\n          }, _onError);\n        } catch (e) {\n          _onError(e);\n        }\n      }, onProgress, _onError);\n    }\n    setDRACOLoader(dracoLoader) {\n      this.dracoLoader = dracoLoader;\n      return this;\n    }\n    setDDSLoader() {\n      throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n    }\n    setKTX2Loader(ktx2Loader) {\n      this.ktx2Loader = ktx2Loader;\n      return this;\n    }\n    setMeshoptDecoder(meshoptDecoder) {\n      this.meshoptDecoder = meshoptDecoder;\n      return this;\n    }\n    register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    }\n    unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    }\n    parse(data, path, onLoad, onError) {\n      let content;\n      const extensions = {};\n      const plugins = {};\n      if (typeof data === 'string') {\n        content = data;\n      } else {\n        const magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n          try {\n            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n          } catch (error) {\n            if (onError) onError(error);\n            return;\n          }\n          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n        } else {\n          content = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n        }\n      }\n      const json = JSON.parse(content);\n      if (json.asset === undefined || json.asset.version[0] < 2) {\n        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\n        return;\n      }\n      const parser = new GLTFParser(json, {\n        path: path || this.resourcePath || '',\n        crossOrigin: this.crossOrigin,\n        requestHeader: this.requestHeader,\n        manager: this.manager,\n        ktx2Loader: this.ktx2Loader,\n        meshoptDecoder: this.meshoptDecoder\n      });\n      parser.fileLoader.setRequestHeader(this.requestHeader);\n      for (let i = 0; i < this.pluginCallbacks.length; i++) {\n        const plugin = this.pluginCallbacks[i](parser);\n        plugins[plugin.name] = plugin; // Workaround to avoid determining as unknown extension\n        // in addUnknownExtensionsToUserData().\n        // Remove this workaround if we move all the existing\n        // extension handlers to plugin system\n\n        extensions[plugin.name] = true;\n      }\n      if (json.extensionsUsed) {\n        for (let i = 0; i < json.extensionsUsed.length; ++i) {\n          const extensionName = json.extensionsUsed[i];\n          const extensionsRequired = json.extensionsRequired || [];\n          switch (extensionName) {\n            case EXTENSIONS.KHR_MATERIALS_UNLIT:\n              extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n              break;\n            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n              break;\n            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n              break;\n            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n              extensions[extensionName] = new GLTFTextureTransformExtension();\n              break;\n            case EXTENSIONS.KHR_MESH_QUANTIZATION:\n              extensions[extensionName] = new GLTFMeshQuantizationExtension();\n              break;\n            default:\n              if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n                console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n              }\n          }\n        }\n      }\n      parser.setExtensions(extensions);\n      parser.setPlugins(plugins);\n      parser.parse(onLoad, onError);\n    }\n  }\n  /* GLTFREGISTRY */\n\n  function GLTFRegistry() {\n    let objects = {};\n    return {\n      get: function (key) {\n        return objects[key];\n      },\n      add: function (key, object) {\n        objects[key] = object;\n      },\n      remove: function (key) {\n        delete objects[key];\n      },\n      removeAll: function () {\n        objects = {};\n      }\n    };\n  }\n  /*********************************/\n\n  /********** EXTENSIONS ***********/\n\n  /*********************************/\n\n  const EXTENSIONS = {\n    KHR_BINARY_GLTF: 'KHR_binary_glTF',\n    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n    KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n    KHR_MATERIALS_IOR: 'KHR_materials_ior',\n    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n    KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n    KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n    KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n    KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n    KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n    EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n    EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n  };\n  /**\r\n  * Punctual Lights Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n  */\n\n  class GLTFLightsExtension {\n    constructor(parser) {\n      this.parser = parser;\n      this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // THREE.Object3D instance caches\n\n      this.cache = {\n        refs: {},\n        uses: {}\n      };\n    }\n    _markDefs() {\n      const parser = this.parser;\n      const nodeDefs = this.parser.json.nodes || [];\n      for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n        const nodeDef = nodeDefs[nodeIndex];\n        if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n          parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n        }\n      }\n    }\n    _loadLight(lightIndex) {\n      const parser = this.parser;\n      const cacheKey = 'light:' + lightIndex;\n      let dependency = parser.cache.get(cacheKey);\n      if (dependency) return dependency;\n      const json = parser.json;\n      const extensions = json.extensions && json.extensions[this.name] || {};\n      const lightDefs = extensions.lights || [];\n      const lightDef = lightDefs[lightIndex];\n      let lightNode;\n      const color = new THREE.Color(0xffffff);\n      if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n      const range = lightDef.range !== undefined ? lightDef.range : 0;\n      switch (lightDef.type) {\n        case 'directional':\n          lightNode = new THREE.DirectionalLight(color);\n          lightNode.target.position.set(0, 0, -1);\n          lightNode.add(lightNode.target);\n          break;\n        case 'point':\n          lightNode = new THREE.PointLight(color);\n          lightNode.distance = range;\n          break;\n        case 'spot':\n          lightNode = new THREE.SpotLight(color);\n          lightNode.distance = range; // Handle spotlight properties.\n\n          lightDef.spot = lightDef.spot || {};\n          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n          lightNode.angle = lightDef.spot.outerConeAngle;\n          lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n          lightNode.target.position.set(0, 0, -1);\n          lightNode.add(lightNode.target);\n          break;\n        default:\n          throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);\n      } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n      // here, because node-level parsing will only override position if explicitly specified.\n\n      lightNode.position.set(0, 0, 0);\n      lightNode.decay = 2;\n      if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n      lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);\n      dependency = Promise.resolve(lightNode);\n      parser.cache.add(cacheKey, dependency);\n      return dependency;\n    }\n    createNodeAttachment(nodeIndex) {\n      const self = this;\n      const parser = this.parser;\n      const json = parser.json;\n      const nodeDef = json.nodes[nodeIndex];\n      const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n      const lightIndex = lightDef.light;\n      if (lightIndex === undefined) return null;\n      return this._loadLight(lightIndex).then(function (light) {\n        return parser._getNodeRef(self.cache, lightIndex, light);\n      });\n    }\n  }\n  /**\r\n  * Unlit Materials Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n  */\n\n  class GLTFMaterialsUnlitExtension {\n    constructor() {\n      this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n    }\n    getMaterialType() {\n      return THREE.MeshBasicMaterial;\n    }\n    extendParams(materialParams, materialDef, parser) {\n      const pending = [];\n      materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n      const metallicRoughness = materialDef.pbrMetallicRoughness;\n      if (metallicRoughness) {\n        if (Array.isArray(metallicRoughness.baseColorFactor)) {\n          const array = metallicRoughness.baseColorFactor;\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n        }\n        if (metallicRoughness.baseColorTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n        }\n      }\n      return Promise.all(pending);\n    }\n  }\n  /**\r\n  * Clearcoat Materials Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n  */\n\n  class GLTFMaterialsClearcoatExtension {\n    constructor(parser) {\n      this.parser = parser;\n      this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n    }\n    getMaterialType(materialIndex) {\n      const parser = this.parser;\n      const materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n      return THREE.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n      const parser = this.parser;\n      const materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n        return Promise.resolve();\n      }\n      const pending = [];\n      const extension = materialDef.extensions[this.name];\n      if (extension.clearcoatFactor !== undefined) {\n        materialParams.clearcoat = extension.clearcoatFactor;\n      }\n      if (extension.clearcoatTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));\n      }\n      if (extension.clearcoatRoughnessFactor !== undefined) {\n        materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n      }\n      if (extension.clearcoatRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));\n      }\n      if (extension.clearcoatNormalTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));\n        if (extension.clearcoatNormalTexture.scale !== undefined) {\n          const scale = extension.clearcoatNormalTexture.scale; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n          materialParams.clearcoatNormalScale = new THREE.Vector2(scale, -scale);\n        }\n      }\n      return Promise.all(pending);\n    }\n  }\n  /**\r\n  * Transmission Materials Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n  * Draft: https://github.com/KhronosGroup/glTF/pull/1698\r\n  */\n\n  class GLTFMaterialsTransmissionExtension {\n    constructor(parser) {\n      this.parser = parser;\n      this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n    }\n    getMaterialType(materialIndex) {\n      const parser = this.parser;\n      const materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n      return THREE.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n      const parser = this.parser;\n      const materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n        return Promise.resolve();\n      }\n      const pending = [];\n      const extension = materialDef.extensions[this.name];\n      if (extension.transmissionFactor !== undefined) {\n        materialParams.transmission = extension.transmissionFactor;\n      }\n      if (extension.transmissionTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));\n      }\n      return Promise.all(pending);\n    }\n  }\n  /**\r\n  * Materials Volume Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n  */\n\n  class GLTFMaterialsVolumeExtension {\n    constructor(parser) {\n      this.parser = parser;\n      this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n    }\n    getMaterialType(materialIndex) {\n      const parser = this.parser;\n      const materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n      return THREE.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n      const parser = this.parser;\n      const materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n        return Promise.resolve();\n      }\n      const pending = [];\n      const extension = materialDef.extensions[this.name];\n      materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n      if (extension.thicknessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));\n      }\n      materialParams.attenuationDistance = extension.attenuationDistance || 0;\n      const colorArray = extension.attenuationColor || [1, 1, 1];\n      materialParams.attenuationTint = new THREE.Color(colorArray[0], colorArray[1], colorArray[2]);\n      return Promise.all(pending);\n    }\n  }\n  /**\r\n  * Materials ior Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\r\n  */\n\n  class GLTFMaterialsIorExtension {\n    constructor(parser) {\n      this.parser = parser;\n      this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n    }\n    getMaterialType(materialIndex) {\n      const parser = this.parser;\n      const materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n      return THREE.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n      const parser = this.parser;\n      const materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n        return Promise.resolve();\n      }\n      const extension = materialDef.extensions[this.name];\n      materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n      return Promise.resolve();\n    }\n  }\n  /**\r\n  * Materials specular Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\r\n  */\n\n  class GLTFMaterialsSpecularExtension {\n    constructor(parser) {\n      this.parser = parser;\n      this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n    }\n    getMaterialType(materialIndex) {\n      const parser = this.parser;\n      const materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n      return THREE.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n      const parser = this.parser;\n      const materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n        return Promise.resolve();\n      }\n      const pending = [];\n      const extension = materialDef.extensions[this.name];\n      materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n      if (extension.specularTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));\n      }\n      const colorArray = extension.specularColorFactor || [1, 1, 1];\n      materialParams.specularTint = new THREE.Color(colorArray[0], colorArray[1], colorArray[2]);\n      if (extension.specularColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'specularTintMap', extension.specularColorTexture).then(function (texture) {\n          texture.encoding = THREE.sRGBEncoding;\n        }));\n      }\n      return Promise.all(pending);\n    }\n  }\n  /**\r\n  * BasisU THREE.Texture Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\r\n  */\n\n  class GLTFTextureBasisUExtension {\n    constructor(parser) {\n      this.parser = parser;\n      this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n    }\n    loadTexture(textureIndex) {\n      const parser = this.parser;\n      const json = parser.json;\n      const textureDef = json.textures[textureIndex];\n      if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n        return null;\n      }\n      const extension = textureDef.extensions[this.name];\n      const source = json.images[extension.source];\n      const loader = parser.options.ktx2Loader;\n      if (!loader) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');\n        } else {\n          // Assumes that the extension is optional and that a fallback texture is present\n          return null;\n        }\n      }\n      return parser.loadTextureImage(textureIndex, source, loader);\n    }\n  }\n  /**\r\n  * WebP THREE.Texture Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\r\n  */\n\n  class GLTFTextureWebPExtension {\n    constructor(parser) {\n      this.parser = parser;\n      this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n      this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n      const name = this.name;\n      const parser = this.parser;\n      const json = parser.json;\n      const textureDef = json.textures[textureIndex];\n      if (!textureDef.extensions || !textureDef.extensions[name]) {\n        return null;\n      }\n      const extension = textureDef.extensions[name];\n      const source = json.images[extension.source];\n      let loader = parser.textureLoader;\n      if (source.uri) {\n        const handler = parser.options.manager.getHandler(source.uri);\n        if (handler !== null) loader = handler;\n      }\n      return this.detectSupport().then(function (isSupported) {\n        if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n          throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');\n        } // Fall back to PNG or JPEG.\n\n        return parser.loadTexture(textureIndex);\n      });\n    }\n    detectSupport() {\n      if (!this.isSupported) {\n        this.isSupported = new Promise(function (resolve) {\n          const image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all\n          // WebP images, unfortunately.\n\n          image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n          image.onload = image.onerror = function () {\n            resolve(image.height === 1);\n          };\n        });\n      }\n      return this.isSupported;\n    }\n  }\n  /**\r\n  * meshopt BufferView Compression Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\r\n  */\n\n  class GLTFMeshoptCompression {\n    constructor(parser) {\n      this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n      this.parser = parser;\n    }\n    loadBufferView(index) {\n      const json = this.parser.json;\n      const bufferView = json.bufferViews[index];\n      if (bufferView.extensions && bufferView.extensions[this.name]) {\n        const extensionDef = bufferView.extensions[this.name];\n        const buffer = this.parser.getDependency('buffer', extensionDef.buffer);\n        const decoder = this.parser.options.meshoptDecoder;\n        if (!decoder || !decoder.supported) {\n          if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n            throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');\n          } else {\n            // Assumes that the extension is optional and that fallback buffer data is present\n            return null;\n          }\n        }\n        return Promise.all([buffer, decoder.ready]).then(function (res) {\n          const byteOffset = extensionDef.byteOffset || 0;\n          const byteLength = extensionDef.byteLength || 0;\n          const count = extensionDef.count;\n          const stride = extensionDef.byteStride;\n          const result = new ArrayBuffer(count * stride);\n          const source = new Uint8Array(res[0], byteOffset, byteLength);\n          decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n          return result;\n        });\n      } else {\n        return null;\n      }\n    }\n  }\n  /* BINARY EXTENSION */\n\n  const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n  const BINARY_EXTENSION_HEADER_LENGTH = 12;\n  const BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 0x4E4F534A,\n    BIN: 0x004E4942\n  };\n  class GLTFBinaryExtension {\n    constructor(data) {\n      this.name = EXTENSIONS.KHR_BINARY_GLTF;\n      this.content = null;\n      this.body = null;\n      const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n      this.header = {\n        magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n        version: headerView.getUint32(4, true),\n        length: headerView.getUint32(8, true)\n      };\n      if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n        throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n      } else if (this.header.version < 2.0) {\n        throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\n      }\n      const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n      const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n      let chunkIndex = 0;\n      while (chunkIndex < chunkContentsLength) {\n        const chunkLength = chunkView.getUint32(chunkIndex, true);\n        chunkIndex += 4;\n        const chunkType = chunkView.getUint32(chunkIndex, true);\n        chunkIndex += 4;\n        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n          const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n          this.content = THREE.LoaderUtils.decodeText(contentArray);\n        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n          const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n          this.body = data.slice(byteOffset, byteOffset + chunkLength);\n        } // Clients must ignore chunks with unknown types.\n\n        chunkIndex += chunkLength;\n      }\n      if (this.content === null) {\n        throw new Error('THREE.GLTFLoader: JSON content not found.');\n      }\n    }\n  }\n  /**\r\n  * DRACO THREE.Mesh Compression Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\r\n  */\n\n  class GLTFDracoMeshCompressionExtension {\n    constructor(json, dracoLoader) {\n      if (!dracoLoader) {\n        throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n      }\n      this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n      this.json = json;\n      this.dracoLoader = dracoLoader;\n      this.dracoLoader.preload();\n    }\n    decodePrimitive(primitive, parser) {\n      const json = this.json;\n      const dracoLoader = this.dracoLoader;\n      const bufferViewIndex = primitive.extensions[this.name].bufferView;\n      const gltfAttributeMap = primitive.extensions[this.name].attributes;\n      const threeAttributeMap = {};\n      const attributeNormalizedMap = {};\n      const attributeTypeMap = {};\n      for (const attributeName in gltfAttributeMap) {\n        const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n      }\n      for (const attributeName in primitive.attributes) {\n        const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n        if (gltfAttributeMap[attributeName] !== undefined) {\n          const accessorDef = json.accessors[primitive.attributes[attributeName]];\n          const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n          attributeTypeMap[threeAttributeName] = componentType;\n          attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n        }\n      }\n      return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n        return new Promise(function (resolve) {\n          dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName];\n              const normalized = attributeNormalizedMap[attributeName];\n              if (normalized !== undefined) attribute.normalized = normalized;\n            }\n            resolve(geometry);\n          }, threeAttributeMap, attributeTypeMap);\n        });\n      });\n    }\n  }\n  /**\r\n  * THREE.Texture Transform Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\r\n  */\n\n  class GLTFTextureTransformExtension {\n    constructor() {\n      this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n    }\n    extendTexture(texture, transform) {\n      if (transform.texCoord !== undefined) {\n        console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n      }\n      if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {\n        // See https://github.com/mrdoob/three.js/issues/21819.\n        return texture;\n      }\n      texture = texture.clone();\n      if (transform.offset !== undefined) {\n        texture.offset.fromArray(transform.offset);\n      }\n      if (transform.rotation !== undefined) {\n        texture.rotation = transform.rotation;\n      }\n      if (transform.scale !== undefined) {\n        texture.repeat.fromArray(transform.scale);\n      }\n      texture.needsUpdate = true;\n      return texture;\n    }\n  }\n  /**\r\n  * Specular-Glossiness Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\r\n  */\n\n  /**\r\n  * A sub class of StandardMaterial with some of the functionality\r\n  * changed via the `onBeforeCompile` callback\r\n  * @pailhead\r\n  */\n\n  class GLTFMeshStandardSGMaterial extends THREE.MeshStandardMaterial {\n    constructor(params) {\n      super();\n      this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing\n\n      const specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n      const glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n      const specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n      const glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n      const lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.roughness += geometryRoughness;', 'material.roughness = min( material.roughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\\n');\n      const uniforms = {\n        specular: {\n          value: new THREE.Color().setHex(0xffffff)\n        },\n        glossiness: {\n          value: 1\n        },\n        specularMap: {\n          value: null\n        },\n        glossinessMap: {\n          value: null\n        }\n      };\n      this._extraUniforms = uniforms;\n      this.onBeforeCompile = function (shader) {\n        for (const uniformName in uniforms) {\n          shader.uniforms[uniformName] = uniforms[uniformName];\n        }\n        shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n      };\n      Object.defineProperties(this, {\n        specular: {\n          get: function () {\n            return uniforms.specular.value;\n          },\n          set: function (v) {\n            uniforms.specular.value = v;\n          }\n        },\n        specularMap: {\n          get: function () {\n            return uniforms.specularMap.value;\n          },\n          set: function (v) {\n            uniforms.specularMap.value = v;\n            if (v) {\n              this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n            } else {\n              delete this.defines.USE_SPECULARMAP;\n            }\n          }\n        },\n        glossiness: {\n          get: function () {\n            return uniforms.glossiness.value;\n          },\n          set: function (v) {\n            uniforms.glossiness.value = v;\n          }\n        },\n        glossinessMap: {\n          get: function () {\n            return uniforms.glossinessMap.value;\n          },\n          set: function (v) {\n            uniforms.glossinessMap.value = v;\n            if (v) {\n              this.defines.USE_GLOSSINESSMAP = '';\n              this.defines.USE_UV = '';\n            } else {\n              delete this.defines.USE_GLOSSINESSMAP;\n              delete this.defines.USE_UV;\n            }\n          }\n        }\n      });\n      delete this.metalness;\n      delete this.roughness;\n      delete this.metalnessMap;\n      delete this.roughnessMap;\n      this.setValues(params);\n    }\n    copy(source) {\n      super.copy(source);\n      this.specularMap = source.specularMap;\n      this.specular.copy(source.specular);\n      this.glossinessMap = source.glossinessMap;\n      this.glossiness = source.glossiness;\n      delete this.metalness;\n      delete this.roughness;\n      delete this.metalnessMap;\n      delete this.roughnessMap;\n      return this;\n    }\n  }\n  class GLTFMaterialsPbrSpecularGlossinessExtension {\n    constructor() {\n      this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n      this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];\n    }\n    getMaterialType() {\n      return GLTFMeshStandardSGMaterial;\n    }\n    extendParams(materialParams, materialDef, parser) {\n      const pbrSpecularGlossiness = materialDef.extensions[this.name];\n      materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n      const pending = [];\n      if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n        const array = pbrSpecularGlossiness.diffuseFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n      if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n      }\n      materialParams.emissive = new THREE.Color(0.0, 0.0, 0.0);\n      materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n      materialParams.specular = new THREE.Color(1.0, 1.0, 1.0);\n      if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n        materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n      }\n      if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n        const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n        pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n        pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n      }\n      return Promise.all(pending);\n    }\n    createMaterial(materialParams) {\n      const material = new GLTFMeshStandardSGMaterial(materialParams);\n      material.fog = true;\n      material.color = materialParams.color;\n      material.map = materialParams.map === undefined ? null : materialParams.map;\n      material.lightMap = null;\n      material.lightMapIntensity = 1.0;\n      material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n      material.aoMapIntensity = 1.0;\n      material.emissive = materialParams.emissive;\n      material.emissiveIntensity = 1.0;\n      material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n      material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n      material.bumpScale = 1;\n      material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n      material.normalMapType = THREE.TangentSpaceNormalMap;\n      if (materialParams.normalScale) material.normalScale = materialParams.normalScale;\n      material.displacementMap = null;\n      material.displacementScale = 1;\n      material.displacementBias = 0;\n      material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n      material.specular = materialParams.specular;\n      material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n      material.glossiness = materialParams.glossiness;\n      material.alphaMap = null;\n      material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n      material.envMapIntensity = 1.0;\n      material.refractionRatio = 0.98;\n      return material;\n    }\n  }\n  /**\r\n  * THREE.Mesh Quantization Extension\r\n  *\r\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\r\n  */\n\n  class GLTFMeshQuantizationExtension {\n    constructor() {\n      this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n    }\n  }\n  /*********************************/\n\n  /********** INTERPOLATION ********/\n\n  /*********************************/\n  // Spline Interpolation\n  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n  class GLTFCubicSplineInterpolant extends THREE.Interpolant {\n    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n      super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    }\n    copySampleValue_(index) {\n      // Copies a sample value to the result buffer. See description of glTF\n      // CUBICSPLINE values layout in interpolate_() function below.\n      const result = this.resultBuffer,\n        values = this.sampleValues,\n        valueSize = this.valueSize,\n        offset = index * valueSize * 3 + valueSize;\n      for (let i = 0; i !== valueSize; i++) {\n        result[i] = values[offset + i];\n      }\n      return result;\n    }\n  }\n  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride]; // splineVertex_k\n\n      const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n      const p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n      const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  };\n  const _q = new THREE.Quaternion();\n  class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n    interpolate_(i1, t0, t, t1) {\n      const result = super.interpolate_(i1, t0, t, t1);\n      _q.fromArray(result).normalize().toArray(result);\n      return result;\n    }\n  }\n  /*********************************/\n\n  /********** INTERNALS ************/\n\n  /*********************************/\n\n  /* CONSTANTS */\n\n  const WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n  };\n  const WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n  };\n  const WEBGL_FILTERS = {\n    9728: THREE.NearestFilter,\n    9729: THREE.LinearFilter,\n    9984: THREE.NearestMipmapNearestFilter,\n    9985: THREE.LinearMipmapNearestFilter,\n    9986: THREE.NearestMipmapLinearFilter,\n    9987: THREE.LinearMipmapLinearFilter\n  };\n  const WEBGL_WRAPPINGS = {\n    33071: THREE.ClampToEdgeWrapping,\n    33648: THREE.MirroredRepeatWrapping,\n    10497: THREE.RepeatWrapping\n  };\n  const WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n  };\n  const ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex'\n  };\n  const PATH_PROPERTIES = {\n    scale: 'scale',\n    translation: 'position',\n    rotation: 'quaternion',\n    weights: 'morphTargetInfluences'\n  };\n  const INTERPOLATION = {\n    CUBICSPLINE: undefined,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: THREE.InterpolateLinear,\n    STEP: THREE.InterpolateDiscrete\n  };\n  const ALPHA_MODES = {\n    OPAQUE: 'OPAQUE',\n    MASK: 'MASK',\n    BLEND: 'BLEND'\n  };\n  /* UTILITY FUNCTIONS */\n\n  function resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return ''; // Host Relative URL\n\n    if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n      path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n    } // Absolute URL http://,https://,//\n\n    if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n    if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n    return path + url;\n  }\n  /**\r\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\r\n  */\n\n  function createDefaultMaterial(cache) {\n    if (cache['DefaultMaterial'] === undefined) {\n      cache['DefaultMaterial'] = new THREE.MeshStandardMaterial({\n        color: 0xFFFFFF,\n        emissive: 0x000000,\n        metalness: 1,\n        roughness: 1,\n        transparent: false,\n        depthTest: true,\n        side: THREE.FrontSide\n      });\n    }\n    return cache['DefaultMaterial'];\n  }\n  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    // Add unknown glTF extensions to an object's userData.\n    for (const name in objectDef.extensions) {\n      if (knownExtensions[name] === undefined) {\n        object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n        object.userData.gltfExtensions[name] = objectDef.extensions[name];\n      }\n    }\n  }\n  /**\r\n  * @param {Object3D|Material|BufferGeometry} object\r\n  * @param {GLTF.definition} gltfDef\r\n  */\n\n  function assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== undefined) {\n      if (typeof gltfDef.extras === 'object') {\n        Object.assign(object.userData, gltfDef.extras);\n      } else {\n        console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n      }\n    }\n  }\n  /**\r\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\r\n  *\r\n  * @param {BufferGeometry} geometry\r\n  * @param {Array<GLTF.Target>} targets\r\n  * @param {GLTFParser} parser\r\n  * @return {Promise<BufferGeometry>}\r\n  */\n\n  function addMorphTargets(geometry, targets, parser) {\n    let hasMorphPosition = false;\n    let hasMorphNormal = false;\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== undefined) hasMorphPosition = true;\n      if (target.NORMAL !== undefined) hasMorphNormal = true;\n      if (hasMorphPosition && hasMorphNormal) break;\n    }\n    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n    const pendingPositionAccessors = [];\n    const pendingNormalAccessors = [];\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (hasMorphPosition) {\n        const pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n        pendingPositionAccessors.push(pendingAccessor);\n      }\n      if (hasMorphNormal) {\n        const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n        pendingNormalAccessors.push(pendingAccessor);\n      }\n    }\n    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\n      const morphPositions = accessors[0];\n      const morphNormals = accessors[1];\n      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n      geometry.morphTargetsRelative = true;\n      return geometry;\n    });\n  }\n  /**\r\n  * @param {Mesh} mesh\r\n  * @param {GLTF.Mesh} meshDef\r\n  */\n\n  function updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n    if (meshDef.weights !== undefined) {\n      for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n        mesh.morphTargetInfluences[i] = meshDef.weights[i];\n      }\n    } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n      const targetNames = meshDef.extras.targetNames;\n      if (mesh.morphTargetInfluences.length === targetNames.length) {\n        mesh.morphTargetDictionary = {};\n        for (let i = 0, il = targetNames.length; i < il; i++) {\n          mesh.morphTargetDictionary[targetNames[i]] = i;\n        }\n      } else {\n        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n      }\n    }\n  }\n  function createPrimitiveKey(primitiveDef) {\n    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    let geometryKey;\n    if (dracoExtension) {\n      geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n    } else {\n      geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n    }\n    return geometryKey;\n  }\n  function createAttributesKey(attributes) {\n    let attributesKey = '';\n    const keys = Object.keys(attributes).sort();\n    for (let i = 0, il = keys.length; i < il; i++) {\n      attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n    }\n    return attributesKey;\n  }\n  function getNormalizedComponentScale(constructor) {\n    // Reference:\n    // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n    switch (constructor) {\n      case Int8Array:\n        return 1 / 127;\n      case Uint8Array:\n        return 1 / 255;\n      case Int16Array:\n        return 1 / 32767;\n      case Uint16Array:\n        return 1 / 65535;\n      default:\n        throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');\n    }\n  }\n  /* GLTF PARSER */\n\n  class GLTFParser {\n    constructor(json = {}, options = {}) {\n      this.json = json;\n      this.extensions = {};\n      this.plugins = {};\n      this.options = options; // loader object cache\n\n      this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements\n\n      this.associations = new Map(); // THREE.BufferGeometry caching\n\n      this.primitiveCache = {}; // THREE.Object3D instance caches\n\n      this.meshCache = {\n        refs: {},\n        uses: {}\n      };\n      this.cameraCache = {\n        refs: {},\n        uses: {}\n      };\n      this.lightCache = {\n        refs: {},\n        uses: {}\n      };\n      this.textureCache = {}; // Track node names, to ensure no duplicates\n\n      this.nodeNamesUsed = {}; // Use an THREE.ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n      // expensive work of uploading a texture to the GPU off the main thread.\n\n      if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {\n        this.textureLoader = new THREE.ImageBitmapLoader(this.options.manager);\n      } else {\n        this.textureLoader = new THREE.TextureLoader(this.options.manager);\n      }\n      this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n      this.textureLoader.setRequestHeader(this.options.requestHeader);\n      this.fileLoader = new THREE.FileLoader(this.options.manager);\n      this.fileLoader.setResponseType('arraybuffer');\n      if (this.options.crossOrigin === 'use-credentials') {\n        this.fileLoader.setWithCredentials(true);\n      }\n    }\n    setExtensions(extensions) {\n      this.extensions = extensions;\n    }\n    setPlugins(plugins) {\n      this.plugins = plugins;\n    }\n    parse(onLoad, onError) {\n      const parser = this;\n      const json = this.json;\n      const extensions = this.extensions; // Clear the loader cache\n\n      this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n      this._invokeAll(function (ext) {\n        return ext._markDefs && ext._markDefs();\n      });\n      Promise.all(this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      })).then(function () {\n        return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);\n      }).then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {}\n        };\n        addUnknownExtensionsToUserData(extensions, result, json);\n        assignExtrasToUserData(result, json);\n        Promise.all(parser._invokeAll(function (ext) {\n          return ext.afterRoot && ext.afterRoot(result);\n        })).then(function () {\n          onLoad(result);\n        });\n      }).catch(onError);\n    }\n    /**\r\n     * Marks the special nodes/meshes in json for efficient parse.\r\n     */\n\n    _markDefs() {\n      const nodeDefs = this.json.nodes || [];\n      const skinDefs = this.json.skins || [];\n      const meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a THREE.Bone or an\n      // THREE.Object3D. Use the skins' joint references to mark bones.\n\n      for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n        const joints = skinDefs[skinIndex].joints;\n        for (let i = 0, il = joints.length; i < il; i++) {\n          nodeDefs[joints[i]].isBone = true;\n        }\n      } // Iterate over all nodes, marking references to shared resources,\n      // as well as skeleton joints.\n\n      for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n        const nodeDef = nodeDefs[nodeIndex];\n        if (nodeDef.mesh !== undefined) {\n          this._addNodeRef(this.meshCache, nodeDef.mesh); // Nothing in the mesh definition indicates whether it is\n          // a THREE.SkinnedMesh or THREE.Mesh. Use the node's mesh reference\n          // to mark THREE.SkinnedMesh if node has skin.\n\n          if (nodeDef.skin !== undefined) {\n            meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n          }\n        }\n        if (nodeDef.camera !== undefined) {\n          this._addNodeRef(this.cameraCache, nodeDef.camera);\n        }\n      }\n    }\n    /**\r\n     * Counts references to shared node / THREE.Object3D resources. These resources\r\n     * can be reused, or \"instantiated\", at multiple nodes in the scene\r\n     * hierarchy. THREE.Mesh, Camera, and Light instances are instantiated and must\r\n     * be marked. Non-scenegraph resources (like Materials, Geometries, and\r\n     * Textures) can be reused directly and are not marked here.\r\n     *\r\n     * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\r\n     */\n\n    _addNodeRef(cache, index) {\n      if (index === undefined) return;\n      if (cache.refs[index] === undefined) {\n        cache.refs[index] = cache.uses[index] = 0;\n      }\n      cache.refs[index]++;\n    }\n    /** Returns a reference to a shared resource, cloning it if necessary. */\n\n    _getNodeRef(cache, index, object) {\n      if (cache.refs[index] <= 1) return object;\n      const ref = object.clone();\n      ref.name += '_instance_' + cache.uses[index]++;\n      return ref;\n    }\n    _invokeOne(func) {\n      const extensions = Object.values(this.plugins);\n      extensions.push(this);\n      for (let i = 0; i < extensions.length; i++) {\n        const result = func(extensions[i]);\n        if (result) return result;\n      }\n      return null;\n    }\n    _invokeAll(func) {\n      const extensions = Object.values(this.plugins);\n      extensions.unshift(this);\n      const pending = [];\n      for (let i = 0; i < extensions.length; i++) {\n        const result = func(extensions[i]);\n        if (result) pending.push(result);\n      }\n      return pending;\n    }\n    /**\r\n     * Requests the specified dependency asynchronously, with caching.\r\n     * @param {string} type\r\n     * @param {number} index\r\n     * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\r\n     */\n\n    getDependency(type, index) {\n      const cacheKey = type + ':' + index;\n      let dependency = this.cache.get(cacheKey);\n      if (!dependency) {\n        switch (type) {\n          case 'scene':\n            dependency = this.loadScene(index);\n            break;\n          case 'node':\n            dependency = this.loadNode(index);\n            break;\n          case 'mesh':\n            dependency = this._invokeOne(function (ext) {\n              return ext.loadMesh && ext.loadMesh(index);\n            });\n            break;\n          case 'accessor':\n            dependency = this.loadAccessor(index);\n            break;\n          case 'bufferView':\n            dependency = this._invokeOne(function (ext) {\n              return ext.loadBufferView && ext.loadBufferView(index);\n            });\n            break;\n          case 'buffer':\n            dependency = this.loadBuffer(index);\n            break;\n          case 'material':\n            dependency = this._invokeOne(function (ext) {\n              return ext.loadMaterial && ext.loadMaterial(index);\n            });\n            break;\n          case 'texture':\n            dependency = this._invokeOne(function (ext) {\n              return ext.loadTexture && ext.loadTexture(index);\n            });\n            break;\n          case 'skin':\n            dependency = this.loadSkin(index);\n            break;\n          case 'animation':\n            dependency = this.loadAnimation(index);\n            break;\n          case 'camera':\n            dependency = this.loadCamera(index);\n            break;\n          default:\n            throw new Error('Unknown type: ' + type);\n        }\n        this.cache.add(cacheKey, dependency);\n      }\n      return dependency;\n    }\n    /**\r\n     * Requests all dependencies of the specified type asynchronously, with caching.\r\n     * @param {string} type\r\n     * @return {Promise<Array<Object>>}\r\n     */\n\n    getDependencies(type) {\n      let dependencies = this.cache.get(type);\n      if (!dependencies) {\n        const parser = this;\n        const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n        dependencies = Promise.all(defs.map(function (def, index) {\n          return parser.getDependency(type, index);\n        }));\n        this.cache.add(type, dependencies);\n      }\n      return dependencies;\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n     * @param {number} bufferIndex\r\n     * @return {Promise<ArrayBuffer>}\r\n     */\n\n    loadBuffer(bufferIndex) {\n      const bufferDef = this.json.buffers[bufferIndex];\n      const loader = this.fileLoader;\n      if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n        throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n      } // If present, GLB container is required to be the first buffer.\n\n      if (bufferDef.uri === undefined && bufferIndex === 0) {\n        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n      }\n      const options = this.options;\n      return new Promise(function (resolve, reject) {\n        loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n          reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n        });\n      });\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n     * @param {number} bufferViewIndex\r\n     * @return {Promise<ArrayBuffer>}\r\n     */\n\n    loadBufferView(bufferViewIndex) {\n      const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n      return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n        const byteLength = bufferViewDef.byteLength || 0;\n        const byteOffset = bufferViewDef.byteOffset || 0;\n        return buffer.slice(byteOffset, byteOffset + byteLength);\n      });\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\r\n     * @param {number} accessorIndex\r\n     * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\r\n     */\n\n    loadAccessor(accessorIndex) {\n      const parser = this;\n      const json = this.json;\n      const accessorDef = this.json.accessors[accessorIndex];\n      if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n        // Ignore empty accessors, which may be used to declare runtime\n        // information about attributes coming from another source (e.g. Draco\n        // compression extension).\n        return Promise.resolve(null);\n      }\n      const pendingBufferViews = [];\n      if (accessorDef.bufferView !== undefined) {\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n      } else {\n        pendingBufferViews.push(null);\n      }\n      if (accessorDef.sparse !== undefined) {\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n      }\n      return Promise.all(pendingBufferViews).then(function (bufferViews) {\n        const bufferView = bufferViews[0];\n        const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n        const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n        const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n        const itemBytes = elementBytes * itemSize;\n        const byteOffset = accessorDef.byteOffset || 0;\n        const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n        const normalized = accessorDef.normalized === true;\n        let array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n        if (byteStride && byteStride !== itemBytes) {\n          // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own THREE.InterleavedBuffer\n          // This makes sure that IBA.count reflects accessor.count properly\n          const ibSlice = Math.floor(byteOffset / byteStride);\n          const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n          let ib = parser.cache.get(ibCacheKey);\n          if (!ib) {\n            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n            ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\n            parser.cache.add(ibCacheKey, ib);\n          }\n          bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n        } else {\n          if (bufferView === null) {\n            array = new TypedArray(accessorDef.count * itemSize);\n          } else {\n            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n          }\n          bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\n        } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n        if (accessorDef.sparse !== undefined) {\n          const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n          const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n          const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n          const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n          const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n          const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n          if (bufferView !== null) {\n            // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n            bufferAttribute = new THREE.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n          }\n          for (let i = 0, il = sparseIndices.length; i < il; i++) {\n            const index = sparseIndices[i];\n            bufferAttribute.setX(index, sparseValues[i * itemSize]);\n            if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n            if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n            if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n            if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.');\n          }\n        }\n        return bufferAttribute;\n      });\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\r\n     * @param {number} textureIndex\r\n     * @return {Promise<THREE.Texture>}\r\n     */\n\n    loadTexture(textureIndex) {\n      const json = this.json;\n      const options = this.options;\n      const textureDef = json.textures[textureIndex];\n      const source = json.images[textureDef.source];\n      let loader = this.textureLoader;\n      if (source.uri) {\n        const handler = options.manager.getHandler(source.uri);\n        if (handler !== null) loader = handler;\n      }\n      return this.loadTextureImage(textureIndex, source, loader);\n    }\n    loadTextureImage(textureIndex, source, loader) {\n      const parser = this;\n      const json = this.json;\n      const options = this.options;\n      const textureDef = json.textures[textureIndex];\n      const cacheKey = (source.uri || source.bufferView) + ':' + textureDef.sampler;\n      if (this.textureCache[cacheKey]) {\n        // See https://github.com/mrdoob/three.js/issues/21559.\n        return this.textureCache[cacheKey];\n      }\n      const URL = self.URL || self.webkitURL;\n      let sourceURI = source.uri || '';\n      let isObjectURL = false;\n      let hasAlpha = true;\n      const isJPEG = sourceURI.search(/\\.jpe?g($|\\?)/i) > 0 || sourceURI.search(/^data\\:image\\/jpeg/) === 0;\n      if (source.mimeType === 'image/jpeg' || isJPEG) hasAlpha = false;\n      if (source.bufferView !== undefined) {\n        // Load binary image data from bufferView, if provided.\n        sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n          if (source.mimeType === 'image/png') {\n            // Inspect the PNG 'IHDR' chunk to determine whether the image could have an\n            // alpha channel. This check is conservative  the image could have an alpha\n            // channel with all values == 1, and the indexed type (colorType == 3) only\n            // sometimes contains alpha.\n            //\n            // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n            const colorType = new DataView(bufferView, 25, 1).getUint8(0, false);\n            hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\n          }\n          isObjectURL = true;\n          const blob = new Blob([bufferView], {\n            type: source.mimeType\n          });\n          sourceURI = URL.createObjectURL(blob);\n          return sourceURI;\n        });\n      } else if (source.uri === undefined) {\n        throw new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView');\n      }\n      const promise = Promise.resolve(sourceURI).then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve;\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new THREE.Texture(imageBitmap);\n              texture.needsUpdate = true;\n              resolve(texture);\n            };\n          }\n          loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);\n        });\n      }).then(function (texture) {\n        // Clean up resources and configure THREE.Texture.\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI);\n        }\n        texture.flipY = false;\n        if (textureDef.name) texture.name = textureDef.name; // When there is definitely no alpha channel in the texture, set THREE.RGBFormat to save space.\n\n        if (!hasAlpha) texture.format = THREE.RGBFormat;\n        const samplers = json.samplers || {};\n        const sampler = samplers[textureDef.sampler] || {};\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipmapLinearFilter;\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n        parser.associations.set(texture, {\n          type: 'textures',\n          index: textureIndex\n        });\n        return texture;\n      }).catch(function () {\n        console.error('THREE.GLTFLoader: Couldn\\'t load texture', sourceURI);\n        return null;\n      });\n      this.textureCache[cacheKey] = promise;\n      return promise;\n    }\n    /**\r\n     * Asynchronously assigns a texture to the given material parameters.\r\n     * @param {Object} materialParams\r\n     * @param {string} mapName\r\n     * @param {Object} mapDef\r\n     * @return {Promise<Texture>}\r\n     */\n\n    assignTexture(materialParams, mapName, mapDef) {\n      const parser = this;\n      return this.getDependency('texture', mapDef.index).then(function (texture) {\n        // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n        // However, we will copy UV set 0 to UV set 1 on demand for aoMap\n        if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\n          console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\n        }\n        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n          const transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n          if (transform) {\n            const gltfReference = parser.associations.get(texture);\n            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n            parser.associations.set(texture, gltfReference);\n          }\n        }\n        materialParams[mapName] = texture;\n        return texture;\n      });\n    }\n    /**\r\n     * Assigns final material to a THREE.Mesh, THREE.Line, or THREE.Points instance. The instance\r\n     * already has a material (generated from the glTF material options alone)\r\n     * but reuse of the same glTF material may require multiple threejs materials\r\n     * to accommodate different primitive types, defines, etc. New materials will\r\n     * be created if necessary, and reused from a cache.\r\n     * @param  {Object3D} mesh THREE.Mesh, THREE.Line, or THREE.Points instance.\r\n     */\n\n    assignFinalMaterial(mesh) {\n      const geometry = mesh.geometry;\n      let material = mesh.material;\n      const useVertexTangents = geometry.attributes.tangent !== undefined;\n      const useVertexColors = geometry.attributes.color !== undefined;\n      const useFlatShading = geometry.attributes.normal === undefined;\n      if (mesh.isPoints) {\n        const cacheKey = 'PointsMaterial:' + material.uuid;\n        let pointsMaterial = this.cache.get(cacheKey);\n        if (!pointsMaterial) {\n          pointsMaterial = new THREE.PointsMaterial();\n          THREE.Material.prototype.copy.call(pointsMaterial, material);\n          pointsMaterial.color.copy(material.color);\n          pointsMaterial.map = material.map;\n          pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n          this.cache.add(cacheKey, pointsMaterial);\n        }\n        material = pointsMaterial;\n      } else if (mesh.isLine) {\n        const cacheKey = 'LineBasicMaterial:' + material.uuid;\n        let lineMaterial = this.cache.get(cacheKey);\n        if (!lineMaterial) {\n          lineMaterial = new THREE.LineBasicMaterial();\n          THREE.Material.prototype.copy.call(lineMaterial, material);\n          lineMaterial.color.copy(material.color);\n          this.cache.add(cacheKey, lineMaterial);\n        }\n        material = lineMaterial;\n      } // Clone the material if it will be modified\n\n      if (useVertexTangents || useVertexColors || useFlatShading) {\n        let cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n        if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n        if (useVertexTangents) cacheKey += 'vertex-tangents:';\n        if (useVertexColors) cacheKey += 'vertex-colors:';\n        if (useFlatShading) cacheKey += 'flat-shading:';\n        let cachedMaterial = this.cache.get(cacheKey);\n        if (!cachedMaterial) {\n          cachedMaterial = material.clone();\n          if (useVertexColors) cachedMaterial.vertexColors = true;\n          if (useFlatShading) cachedMaterial.flatShading = true;\n          if (useVertexTangents) {\n            // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n            if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n            if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n          }\n          this.cache.add(cacheKey, cachedMaterial);\n          this.associations.set(cachedMaterial, this.associations.get(material));\n        }\n        material = cachedMaterial;\n      } // workarounds for mesh and geometry\n\n      if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n        geometry.setAttribute('uv2', geometry.attributes.uv);\n      }\n      mesh.material = material;\n    }\n    getMaterialType() {\n      return THREE.MeshStandardMaterial;\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\r\n     * @param {number} materialIndex\r\n     * @return {Promise<Material>}\r\n     */\n\n    loadMaterial(materialIndex) {\n      const parser = this;\n      const json = this.json;\n      const extensions = this.extensions;\n      const materialDef = json.materials[materialIndex];\n      let materialType;\n      const materialParams = {};\n      const materialExtensions = materialDef.extensions || {};\n      const pending = [];\n      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n        const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n        materialType = sgExtension.getMaterialType();\n        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n      } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n        const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n        materialType = kmuExtension.getMaterialType();\n        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n      } else {\n        // Specification:\n        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n        const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n        materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n        materialParams.opacity = 1.0;\n        if (Array.isArray(metallicRoughness.baseColorFactor)) {\n          const array = metallicRoughness.baseColorFactor;\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n        }\n        if (metallicRoughness.baseColorTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n        }\n        materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n        materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n        if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n          pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n        }\n        materialType = this._invokeOne(function (ext) {\n          return ext.getMaterialType && ext.getMaterialType(materialIndex);\n        });\n        pending.push(Promise.all(this._invokeAll(function (ext) {\n          return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n        })));\n      }\n      if (materialDef.doubleSided === true) {\n        materialParams.side = THREE.DoubleSide;\n      }\n      const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n      if (alphaMode === ALPHA_MODES.BLEND) {\n        materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706\n\n        materialParams.depthWrite = false;\n      } else {\n        materialParams.format = THREE.RGBFormat;\n        materialParams.transparent = false;\n        if (alphaMode === ALPHA_MODES.MASK) {\n          materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n        }\n      }\n      if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n        pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture)); // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n        materialParams.normalScale = new THREE.Vector2(1, -1);\n        if (materialDef.normalTexture.scale !== undefined) {\n          materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);\n        }\n      }\n      if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n        pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n        if (materialDef.occlusionTexture.strength !== undefined) {\n          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n        }\n      }\n      if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\n        materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\n      }\n      if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n        pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n      }\n      return Promise.all(pending).then(function () {\n        let material;\n        if (materialType === GLTFMeshStandardSGMaterial) {\n          material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n        } else {\n          material = new materialType(materialParams);\n        }\n        if (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\n        if (material.map) material.map.encoding = THREE.sRGBEncoding;\n        if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;\n        assignExtrasToUserData(material, materialDef);\n        parser.associations.set(material, {\n          type: 'materials',\n          index: materialIndex\n        });\n        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n        return material;\n      });\n    }\n    /** When THREE.Object3D instances are targeted by animation, they need unique names. */\n\n    createUniqueName(originalName) {\n      const sanitizedName = THREE.PropertyBinding.sanitizeNodeName(originalName || '');\n      let name = sanitizedName;\n      for (let i = 1; this.nodeNamesUsed[name]; ++i) {\n        name = sanitizedName + '_' + i;\n      }\n      this.nodeNamesUsed[name] = true;\n      return name;\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\r\n     *\r\n     * Creates BufferGeometries from primitives.\r\n     *\r\n     * @param {Array<GLTF.Primitive>} primitives\r\n     * @return {Promise<Array<BufferGeometry>>}\r\n     */\n\n    loadGeometries(primitives) {\n      const parser = this;\n      const extensions = this.extensions;\n      const cache = this.primitiveCache;\n      function createDracoPrimitive(primitive) {\n        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser);\n        });\n      }\n      const pending = [];\n      for (let i = 0, il = primitives.length; i < il; i++) {\n        const primitive = primitives[i];\n        const cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n        const cached = cache[cacheKey];\n        if (cached) {\n          // Use the cached geometry if it exists\n          pending.push(cached.promise);\n        } else {\n          let geometryPromise;\n          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n            // Use DRACO geometry if available\n            geometryPromise = createDracoPrimitive(primitive);\n          } else {\n            // Otherwise create a new geometry\n            geometryPromise = addPrimitiveAttributes(new THREE.BufferGeometry(), primitive, parser);\n          } // Cache this geometry\n\n          cache[cacheKey] = {\n            primitive: primitive,\n            promise: geometryPromise\n          };\n          pending.push(geometryPromise);\n        }\n      }\n      return Promise.all(pending);\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\r\n     * @param {number} meshIndex\r\n     * @return {Promise<Group|Mesh|SkinnedMesh>}\r\n     */\n\n    loadMesh(meshIndex) {\n      const parser = this;\n      const json = this.json;\n      const extensions = this.extensions;\n      const meshDef = json.meshes[meshIndex];\n      const primitives = meshDef.primitives;\n      const pending = [];\n      for (let i = 0, il = primitives.length; i < il; i++) {\n        const material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\n        pending.push(material);\n      }\n      pending.push(parser.loadGeometries(primitives));\n      return Promise.all(pending).then(function (results) {\n        const materials = results.slice(0, results.length - 1);\n        const geometries = results[results.length - 1];\n        const meshes = [];\n        for (let i = 0, il = geometries.length; i < il; i++) {\n          const geometry = geometries[i];\n          const primitive = primitives[i]; // 1. create THREE.Mesh\n\n          let mesh;\n          const material = materials[i];\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n            // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n            mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh(geometry, material) : new THREE.Mesh(geometry, material);\n            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n              // we normalize floating point skin weight array to fix malformed assets (see #15319)\n              // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n              mesh.normalizeSkinWeights();\n            }\n            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n              mesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE.TriangleStripDrawMode);\n            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n              mesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE.TriangleFanDrawMode);\n            }\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n            mesh = new THREE.LineSegments(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n            mesh = new THREE.Line(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n            mesh = new THREE.LineLoop(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n            mesh = new THREE.Points(geometry, material);\n          } else {\n            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n          }\n          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n            updateMorphTargets(mesh, meshDef);\n          }\n          mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);\n          assignExtrasToUserData(mesh, meshDef);\n          if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n          parser.assignFinalMaterial(mesh);\n          meshes.push(mesh);\n        }\n        if (meshes.length === 1) {\n          return meshes[0];\n        }\n        const group = new THREE.Group();\n        for (let i = 0, il = meshes.length; i < il; i++) {\n          group.add(meshes[i]);\n        }\n        return group;\n      });\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\r\n     * @param {number} cameraIndex\r\n     * @return {Promise<THREE.Camera>}\r\n     */\n\n    loadCamera(cameraIndex) {\n      let camera;\n      const cameraDef = this.json.cameras[cameraIndex];\n      const params = cameraDef[cameraDef.type];\n      if (!params) {\n        console.warn('THREE.GLTFLoader: Missing camera parameters.');\n        return;\n      }\n      if (cameraDef.type === 'perspective') {\n        camera = new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n      } else if (cameraDef.type === 'orthographic') {\n        camera = new THREE.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n      }\n      if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n      assignExtrasToUserData(camera, cameraDef);\n      return Promise.resolve(camera);\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\r\n     * @param {number} skinIndex\r\n     * @return {Promise<Object>}\r\n     */\n\n    loadSkin(skinIndex) {\n      const skinDef = this.json.skins[skinIndex];\n      const skinEntry = {\n        joints: skinDef.joints\n      };\n      if (skinDef.inverseBindMatrices === undefined) {\n        return Promise.resolve(skinEntry);\n      }\n      return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n        skinEntry.inverseBindMatrices = accessor;\n        return skinEntry;\n      });\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n     * @param {number} animationIndex\r\n     * @return {Promise<AnimationClip>}\r\n     */\n\n    loadAnimation(animationIndex) {\n      const json = this.json;\n      const animationDef = json.animations[animationIndex];\n      const pendingNodes = [];\n      const pendingInputAccessors = [];\n      const pendingOutputAccessors = [];\n      const pendingSamplers = [];\n      const pendingTargets = [];\n      for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n        const channel = animationDef.channels[i];\n        const sampler = animationDef.samplers[channel.sampler];\n        const target = channel.target;\n        const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n        const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n        const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n        pendingNodes.push(this.getDependency('node', name));\n        pendingInputAccessors.push(this.getDependency('accessor', input));\n        pendingOutputAccessors.push(this.getDependency('accessor', output));\n        pendingSamplers.push(sampler);\n        pendingTargets.push(target);\n      }\n      return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n        const nodes = dependencies[0];\n        const inputAccessors = dependencies[1];\n        const outputAccessors = dependencies[2];\n        const samplers = dependencies[3];\n        const targets = dependencies[4];\n        const tracks = [];\n        for (let i = 0, il = nodes.length; i < il; i++) {\n          const node = nodes[i];\n          const inputAccessor = inputAccessors[i];\n          const outputAccessor = outputAccessors[i];\n          const sampler = samplers[i];\n          const target = targets[i];\n          if (node === undefined) continue;\n          node.updateMatrix();\n          node.matrixAutoUpdate = true;\n          let TypedKeyframeTrack;\n          switch (PATH_PROPERTIES[target.path]) {\n            case PATH_PROPERTIES.weights:\n              TypedKeyframeTrack = THREE.NumberKeyframeTrack;\n              break;\n            case PATH_PROPERTIES.rotation:\n              TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n              break;\n            case PATH_PROPERTIES.position:\n            case PATH_PROPERTIES.scale:\n            default:\n              TypedKeyframeTrack = THREE.VectorKeyframeTrack;\n              break;\n          }\n          const targetName = node.name ? node.name : node.uuid;\n          const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\n          const targetNames = [];\n          if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n            // Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.\n            node.traverse(function (object) {\n              if (object.isMesh === true && object.morphTargetInfluences) {\n                targetNames.push(object.name ? object.name : object.uuid);\n              }\n            });\n          } else {\n            targetNames.push(targetName);\n          }\n          let outputArray = outputAccessor.array;\n          if (outputAccessor.normalized) {\n            const scale = getNormalizedComponentScale(outputArray.constructor);\n            const scaled = new Float32Array(outputArray.length);\n            for (let j = 0, jl = outputArray.length; j < jl; j++) {\n              scaled[j] = outputArray[j] * scale;\n            }\n            outputArray = scaled;\n          }\n          for (let j = 0, jl = targetNames.length; j < jl; j++) {\n            const track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\n\n            if (sampler.interpolation === 'CUBICSPLINE') {\n              track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n                // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n                // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n                // must be divided by three to get the interpolant's sampleSize argument.\n                const interpolantType = this instanceof THREE.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n                return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n              }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n              track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n            }\n            tracks.push(track);\n          }\n        }\n        const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n        return new THREE.AnimationClip(name, undefined, tracks);\n      });\n    }\n    createNodeMesh(nodeIndex) {\n      const json = this.json;\n      const parser = this;\n      const nodeDef = json.nodes[nodeIndex];\n      if (nodeDef.mesh === undefined) return null;\n      return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n        const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh); // if weights are provided on the node, override weights on the mesh.\n\n        if (nodeDef.weights !== undefined) {\n          node.traverse(function (o) {\n            if (!o.isMesh) return;\n            for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n              o.morphTargetInfluences[i] = nodeDef.weights[i];\n            }\n          });\n        }\n        return node;\n      });\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\r\n     * @param {number} nodeIndex\r\n     * @return {Promise<Object3D>}\r\n     */\n\n    loadNode(nodeIndex) {\n      const json = this.json;\n      const extensions = this.extensions;\n      const parser = this;\n      const nodeDef = json.nodes[nodeIndex]; // reserve node's name before its dependencies, so the root has the intended name.\n\n      const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';\n      return function () {\n        const pending = [];\n        const meshPromise = parser._invokeOne(function (ext) {\n          return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n        });\n        if (meshPromise) {\n          pending.push(meshPromise);\n        }\n        if (nodeDef.camera !== undefined) {\n          pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n            return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n          }));\n        }\n        parser._invokeAll(function (ext) {\n          return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n        }).forEach(function (promise) {\n          pending.push(promise);\n        });\n        return Promise.all(pending);\n      }().then(function (objects) {\n        let node; // .isBone isn't in glTF spec. See ._markDefs\n\n        if (nodeDef.isBone === true) {\n          node = new THREE.Bone();\n        } else if (objects.length > 1) {\n          node = new THREE.Group();\n        } else if (objects.length === 1) {\n          node = objects[0];\n        } else {\n          node = new THREE.Object3D();\n        }\n        if (node !== objects[0]) {\n          for (let i = 0, il = objects.length; i < il; i++) {\n            node.add(objects[i]);\n          }\n        }\n        if (nodeDef.name) {\n          node.userData.name = nodeDef.name;\n          node.name = nodeName;\n        }\n        assignExtrasToUserData(node, nodeDef);\n        if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n        if (nodeDef.matrix !== undefined) {\n          const matrix = new THREE.Matrix4();\n          matrix.fromArray(nodeDef.matrix);\n          node.applyMatrix4(matrix);\n        } else {\n          if (nodeDef.translation !== undefined) {\n            node.position.fromArray(nodeDef.translation);\n          }\n          if (nodeDef.rotation !== undefined) {\n            node.quaternion.fromArray(nodeDef.rotation);\n          }\n          if (nodeDef.scale !== undefined) {\n            node.scale.fromArray(nodeDef.scale);\n          }\n        }\n        parser.associations.set(node, {\n          type: 'nodes',\n          index: nodeIndex\n        });\n        return node;\n      });\n    }\n    /**\r\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\r\n     * @param {number} sceneIndex\r\n     * @return {Promise<Group>}\r\n     */\n\n    loadScene(sceneIndex) {\n      const json = this.json;\n      const extensions = this.extensions;\n      const sceneDef = this.json.scenes[sceneIndex];\n      const parser = this; // THREE.Loader returns THREE.Group, not Scene.\n      // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\n      const scene = new THREE.Group();\n      if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n      assignExtrasToUserData(scene, sceneDef);\n      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n      const nodeIds = sceneDef.nodes || [];\n      const pending = [];\n      for (let i = 0, il = nodeIds.length; i < il; i++) {\n        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n      }\n      return Promise.all(pending).then(function () {\n        return scene;\n      });\n    }\n  }\n  function buildNodeHierachy(nodeId, parentObject, json, parser) {\n    const nodeDef = json.nodes[nodeId];\n    return parser.getDependency('node', nodeId).then(function (node) {\n      if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n      let skinEntry;\n      return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n        skinEntry = skin;\n        const pendingJoints = [];\n        for (let i = 0, il = skinEntry.joints.length; i < il; i++) {\n          pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n        }\n        return Promise.all(pendingJoints);\n      }).then(function (jointNodes) {\n        node.traverse(function (mesh) {\n          if (!mesh.isMesh) return;\n          const bones = [];\n          const boneInverses = [];\n          for (let j = 0, jl = jointNodes.length; j < jl; j++) {\n            const jointNode = jointNodes[j];\n            if (jointNode) {\n              bones.push(jointNode);\n              const mat = new THREE.Matrix4();\n              if (skinEntry.inverseBindMatrices !== undefined) {\n                mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n              }\n              boneInverses.push(mat);\n            } else {\n              console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n            }\n          }\n          mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\n        });\n        return node;\n      });\n    }).then(function (node) {\n      // build node hierachy\n      parentObject.add(node);\n      const pending = [];\n      if (nodeDef.children) {\n        const children = nodeDef.children;\n        for (let i = 0, il = children.length; i < il; i++) {\n          const child = children[i];\n          pending.push(buildNodeHierachy(child, node, json, parser));\n        }\n      }\n      return Promise.all(pending);\n    });\n  }\n  /**\r\n  * @param {BufferGeometry} geometry\r\n  * @param {GLTF.Primitive} primitiveDef\r\n  * @param {GLTFParser} parser\r\n  */\n\n  function computeBounds(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const box = new THREE.Box3();\n    if (attributes.POSITION !== undefined) {\n      const accessor = parser.json.accessors[attributes.POSITION];\n      const min = accessor.min;\n      const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n      if (min !== undefined && max !== undefined) {\n        box.set(new THREE.Vector3(min[0], min[1], min[2]), new THREE.Vector3(max[0], max[1], max[2]));\n        if (accessor.normalized) {\n          const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n          box.min.multiplyScalar(boxScale);\n          box.max.multiplyScalar(boxScale);\n        }\n      } else {\n        console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n        return;\n      }\n    } else {\n      return;\n    }\n    const targets = primitiveDef.targets;\n    if (targets !== undefined) {\n      const maxDisplacement = new THREE.Vector3();\n      const vector = new THREE.Vector3();\n      for (let i = 0, il = targets.length; i < il; i++) {\n        const target = targets[i];\n        if (target.POSITION !== undefined) {\n          const accessor = parser.json.accessors[target.POSITION];\n          const min = accessor.min;\n          const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n          if (min !== undefined && max !== undefined) {\n            // we need to get max of absolute components because target weight is [-1,1]\n            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n            if (accessor.normalized) {\n              const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n              vector.multiplyScalar(boxScale);\n            } // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n            // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n            // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n            // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\n            maxDisplacement.max(vector);\n          } else {\n            console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n          }\n        }\n      } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\n      box.expandByVector(maxDisplacement);\n    }\n    geometry.boundingBox = box;\n    const sphere = new THREE.Sphere();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n  }\n  /**\r\n  * @param {BufferGeometry} geometry\r\n  * @param {GLTF.Primitive} primitiveDef\r\n  * @param {GLTFParser} parser\r\n  * @return {Promise<BufferGeometry>}\r\n  */\n\n  function addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const pending = [];\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n      return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n        geometry.setAttribute(attributeName, accessor);\n      });\n    }\n    for (const gltfAttributeName in attributes) {\n      const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n      if (threeAttributeName in geometry.attributes) continue;\n      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n    if (primitiveDef.indices !== undefined && !geometry.index) {\n      const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n        geometry.setIndex(accessor);\n      });\n      pending.push(accessor);\n    }\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function () {\n      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n  }\n  /**\r\n  * @param {BufferGeometry} geometry\r\n  * @param {Number} drawMode\r\n  * @return {BufferGeometry}\r\n  */\n\n  function toTrianglesDrawMode(geometry, drawMode) {\n    let index = geometry.getIndex(); // generate index if not present\n\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute('position');\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    } //\n\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (drawMode === THREE.TriangleFanDrawMode) {\n      // gl.TRIANGLE_FAN\n      for (let i = 1; i <= numberOfTriangles; i++) {\n        newIndices.push(index.getX(0));\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n      }\n    } else {\n      // gl.TRIANGLE_STRIP\n      for (let i = 0; i < numberOfTriangles; i++) {\n        if (i % 2 === 0) {\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i + 2));\n        } else {\n          newIndices.push(index.getX(i + 2));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i));\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    } // build final geometry\n\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    return newGeometry;\n  }\n  THREE.GLTFLoader = GLTFLoader;\n})();\nmodule.exports = exports = THREE.GLTFLoader;","map":{"version":3,"names":["THREE","require","GLTFLoader","Loader","constructor","manager","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsSpecularExtension","GLTFLightsExtension","GLTFMeshoptCompression","load","url","onLoad","onProgress","onError","scope","resourcePath","path","LoaderUtils","extractUrlBase","itemStart","_onError","e","console","error","itemError","itemEnd","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","gltf","setDRACOLoader","setDDSLoader","Error","setKTX2Loader","setMeshoptDecoder","callback","indexOf","push","unregister","splice","content","extensions","plugins","magic","decodeText","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","json","JSON","asset","undefined","version","GLTFParser","crossOrigin","fileLoader","i","length","plugin","name","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","warn","setExtensions","setPlugins","GLTFRegistry","objects","get","key","add","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_IOR","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","EXT_TEXTURE_WEBP","EXT_MESHOPT_COMPRESSION","cache","refs","uses","_markDefs","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","_loadLight","lightIndex","cacheKey","dependency","lightDefs","lights","lightDef","lightNode","color","Color","fromArray","range","type","DirectionalLight","target","position","set","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","intensity","createUniqueName","Promise","resolve","createNodeAttachment","self","then","_getNodeRef","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","assignTexture","all","materialIndex","materials","MeshPhysicalMaterial","extendMaterialParams","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","scale","clearcoatNormalScale","Vector2","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","colorArray","attenuationColor","attenuationTint","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularTint","specularColorTexture","texture","encoding","sRGBEncoding","loadTexture","textureIndex","textureDef","textures","source","images","options","loadTextureImage","isSupported","textureLoader","uri","handler","getHandler","detectSupport","image","Image","src","onload","onerror","height","loadBufferView","index","bufferView","bufferViews","extensionDef","buffer","getDependency","decoder","supported","ready","res","byteOffset","byteLength","count","stride","byteStride","result","ArrayBuffer","decodeGltfBuffer","mode","filter","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","BIN","body","headerView","DataView","header","slice","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","preload","decodePrimitive","primitive","bufferViewIndex","gltfAttributeMap","attributes","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","attributeName","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","decodeDracoFile","geometry","attribute","extendTexture","transform","texCoord","offset","rotation","clone","repeat","needsUpdate","GLTFMeshStandardSGMaterial","MeshStandardMaterial","params","isGLTFSpecularGlossinessMaterial","specularMapParsFragmentChunk","join","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","uniforms","specular","value","setHex","glossiness","specularMap","glossinessMap","_extraUniforms","onBeforeCompile","shader","uniformName","fragmentShader","replace","Object","defineProperties","v","defines","USE_SPECULARMAP","USE_GLOSSINESSMAP","USE_UV","metalness","roughness","metalnessMap","roughnessMap","setValues","copy","specularGlossinessParams","pbrSpecularGlossiness","diffuseFactor","diffuseTexture","emissive","glossinessFactor","specularGlossinessTexture","specGlossMapDef","createMaterial","material","fog","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","TangentSpaceNormalMap","normalScale","displacementMap","displacementScale","displacementBias","alphaMap","envMap","envMapIntensity","refractionRatio","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","copySampleValue_","values","valueSize","prototype","beforeStart_","afterEnd_","interpolate_","i1","t0","t","t1","stride2","stride3","td","p","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_q","Quaternion","GLTFCubicSplineQuaternionInterpolant","normalize","toArray","WEBGL_CONSTANTS","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","Int8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","OPAQUE","MASK","BLEND","resolveURL","test","createDefaultMaterial","transparent","depthTest","side","FrontSide","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","assignExtrasToUserData","gltfDef","extras","assign","addMorphTargets","targets","hasMorphPosition","hasMorphNormal","il","pendingPositionAccessors","pendingNormalAccessors","pendingAccessor","normal","morphPositions","morphNormals","morphAttributes","morphTargetsRelative","updateMorphTargets","mesh","meshDef","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","dracoExtension","geometryKey","indices","createAttributesKey","attributesKey","keys","sort","getNormalizedComponentScale","associations","Map","primitiveCache","meshCache","cameraCache","lightCache","textureCache","nodeNamesUsed","createImageBitmap","navigator","userAgent","ImageBitmapLoader","TextureLoader","setCrossOrigin","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","catch","skinDefs","skins","meshDefs","meshes","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","camera","ref","_invokeOne","func","unshift","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","buffers","reject","bufferViewDef","accessorIndex","sparse","pendingBufferViews","itemSize","TypedArray","elementBytes","BYTES_PER_ELEMENT","itemBytes","bufferAttribute","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","BufferAttribute","itemSizeIndices","SCALAR","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sampler","URL","webkitURL","sourceURI","isObjectURL","hasAlpha","isJPEG","search","mimeType","colorType","getUint8","blob","Blob","createObjectURL","promise","isImageBitmapLoader","imageBitmap","Texture","revokeObjectURL","flipY","format","RGBFormat","samplers","magFilter","minFilter","wrapS","wrapT","mapName","mapDef","gltfReference","assignFinalMaterial","useVertexTangents","tangent","useVertexColors","useFlatShading","isPoints","uuid","pointsMaterial","PointsMaterial","Material","call","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","y","uv2","uv","setAttribute","materialType","materialExtensions","sgExtension","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","DoubleSide","alphaMode","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","loadGeometries","primitives","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","BufferGeometry","meshIndex","results","geometries","SkinnedMesh","Mesh","skinWeight","normalizeSkinWeights","toTrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LineSegments","Line","LineLoop","Points","group","Group","cameraIndex","cameraDef","PerspectiveCamera","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","accessor","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","channel","node","id","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","updateMatrix","matrixAutoUpdate","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","isMesh","outputArray","scaled","j","jl","track","createInterpolant","InterpolantFactoryMethodGLTFCubicSpline","interpolantType","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","createNodeMesh","o","nodeName","meshPromise","forEach","Bone","Object3D","matrix","Matrix4","applyMatrix4","quaternion","sceneIndex","sceneDef","nodeIds","buildNodeHierachy","nodeId","parentObject","pendingJoints","jointNodes","bones","boneInverses","jointNode","mat","bind","Skeleton","matrixWorld","children","child","computeBounds","box","Box3","min","max","Vector3","boxScale","multiplyScalar","maxDisplacement","vector","abs","expandByVector","boundingBox","sphere","Sphere","getCenter","center","radius","distanceTo","boundingSphere","assignAttributeAccessor","gltfAttributeName","setIndex","drawMode","getIndex","getAttribute","numberOfTriangles","newIndices","getX","newGeometry","module","exports"],"sources":["/Users/mihailbaleev/Documents/GitHub/lastochka_spraying/node_modules/threebox-plugin/src/objects/loaders/GLTFLoader.js"],"sourcesContent":["const THREE = require('../../three.js');\r\n\r\n/**\r\n * @author Rich Tibbett / https://github.com/richtr\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Tony Parisi / http://www.tonyparisi.com/\r\n * @author Takahiro / https://github.com/takahirox\r\n * @author Don McCurdy / https://www.donmccurdy.com\r\n */\r\n\r\n(function () {\r\n\r\n\tclass GLTFLoader extends THREE.Loader {\r\n\r\n\t\tconstructor(manager) {\r\n\r\n\t\t\tsuper(manager);\r\n\t\t\tthis.dracoLoader = null;\r\n\t\t\tthis.ktx2Loader = null;\r\n\t\t\tthis.meshoptDecoder = null;\r\n\t\t\tthis.pluginCallbacks = [];\r\n\t\t\tthis.register(function (parser) {\r\n\r\n\t\t\t\treturn new GLTFMaterialsClearcoatExtension(parser);\r\n\r\n\t\t\t});\r\n\t\t\tthis.register(function (parser) {\r\n\r\n\t\t\t\treturn new GLTFTextureBasisUExtension(parser);\r\n\r\n\t\t\t});\r\n\t\t\tthis.register(function (parser) {\r\n\r\n\t\t\t\treturn new GLTFTextureWebPExtension(parser);\r\n\r\n\t\t\t});\r\n\t\t\tthis.register(function (parser) {\r\n\r\n\t\t\t\treturn new GLTFMaterialsTransmissionExtension(parser);\r\n\r\n\t\t\t});\r\n\t\t\tthis.register(function (parser) {\r\n\r\n\t\t\t\treturn new GLTFMaterialsVolumeExtension(parser);\r\n\r\n\t\t\t});\r\n\t\t\tthis.register(function (parser) {\r\n\r\n\t\t\t\treturn new GLTFMaterialsIorExtension(parser);\r\n\r\n\t\t\t});\r\n\t\t\tthis.register(function (parser) {\r\n\r\n\t\t\t\treturn new GLTFMaterialsSpecularExtension(parser);\r\n\r\n\t\t\t});\r\n\t\t\tthis.register(function (parser) {\r\n\r\n\t\t\t\treturn new GLTFLightsExtension(parser);\r\n\r\n\t\t\t});\r\n\t\t\tthis.register(function (parser) {\r\n\r\n\t\t\t\treturn new GLTFMeshoptCompression(parser);\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tload(url, onLoad, onProgress, onError) {\r\n\r\n\t\t\tconst scope = this;\r\n\t\t\tlet resourcePath;\r\n\r\n\t\t\tif (this.resourcePath !== '') {\r\n\r\n\t\t\t\tresourcePath = this.resourcePath;\r\n\r\n\t\t\t} else if (this.path !== '') {\r\n\r\n\t\t\t\tresourcePath = this.path;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresourcePath = THREE.LoaderUtils.extractUrlBase(url);\r\n\r\n\t\t\t} // Tells the LoadingManager to track an extra item, which resolves after\r\n\t\t\t// the model is fully loaded. This means the count of items loaded will\r\n\t\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\r\n\r\n\r\n\t\t\tthis.manager.itemStart(url);\r\n\r\n\t\t\tconst _onError = function (e) {\r\n\r\n\t\t\t\tif (onError) {\r\n\r\n\t\t\t\t\tonError(e);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error(e);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError(url);\r\n\t\t\t\tscope.manager.itemEnd(url);\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconst loader = new THREE.FileLoader(this.manager);\r\n\t\t\tloader.setPath(this.path);\r\n\t\t\tloader.setResponseType('arraybuffer');\r\n\t\t\tloader.setRequestHeader(this.requestHeader);\r\n\t\t\tloader.setWithCredentials(this.withCredentials);\r\n\t\t\tloader.load(url, function (data) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tscope.parse(data, resourcePath, function (gltf) {\r\n\r\n\t\t\t\t\t\tonLoad(gltf);\r\n\t\t\t\t\t\tscope.manager.itemEnd(url);\r\n\r\n\t\t\t\t\t}, _onError);\r\n\r\n\t\t\t\t} catch (e) {\r\n\r\n\t\t\t\t\t_onError(e);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, _onError);\r\n\r\n\t\t}\r\n\r\n\t\tsetDRACOLoader(dracoLoader) {\r\n\r\n\t\t\tthis.dracoLoader = dracoLoader;\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tsetDDSLoader() {\r\n\r\n\t\t\tthrow new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\r\n\r\n\t\t}\r\n\r\n\t\tsetKTX2Loader(ktx2Loader) {\r\n\r\n\t\t\tthis.ktx2Loader = ktx2Loader;\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tsetMeshoptDecoder(meshoptDecoder) {\r\n\r\n\t\t\tthis.meshoptDecoder = meshoptDecoder;\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tregister(callback) {\r\n\r\n\t\t\tif (this.pluginCallbacks.indexOf(callback) === - 1) {\r\n\r\n\t\t\t\tthis.pluginCallbacks.push(callback);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tunregister(callback) {\r\n\r\n\t\t\tif (this.pluginCallbacks.indexOf(callback) !== - 1) {\r\n\r\n\t\t\t\tthis.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tparse(data, path, onLoad, onError) {\r\n\r\n\t\t\tlet content;\r\n\t\t\tconst extensions = {};\r\n\t\t\tconst plugins = {};\r\n\r\n\t\t\tif (typeof data === 'string') {\r\n\r\n\t\t\t\tcontent = data;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\r\n\r\n\t\t\t\tif (magic === BINARY_EXTENSION_HEADER_MAGIC) {\r\n\r\n\t\t\t\t\ttry {\r\n\r\n\t\t\t\t\t\textensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\r\n\r\n\t\t\t\t\t} catch (error) {\r\n\r\n\t\t\t\t\t\tif (onError) onError(error);\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontent = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcontent = THREE.LoaderUtils.decodeText(new Uint8Array(data));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst json = JSON.parse(content);\r\n\r\n\t\t\tif (json.asset === undefined || json.asset.version[0] < 2) {\r\n\r\n\t\t\t\tif (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst parser = new GLTFParser(json, {\r\n\t\t\t\tpath: path || this.resourcePath || '',\r\n\t\t\t\tcrossOrigin: this.crossOrigin,\r\n\t\t\t\trequestHeader: this.requestHeader,\r\n\t\t\t\tmanager: this.manager,\r\n\t\t\t\tktx2Loader: this.ktx2Loader,\r\n\t\t\t\tmeshoptDecoder: this.meshoptDecoder\r\n\t\t\t});\r\n\t\t\tparser.fileLoader.setRequestHeader(this.requestHeader);\r\n\r\n\t\t\tfor (let i = 0; i < this.pluginCallbacks.length; i++) {\r\n\r\n\t\t\t\tconst plugin = this.pluginCallbacks[i](parser);\r\n\t\t\t\tplugins[plugin.name] = plugin; // Workaround to avoid determining as unknown extension\r\n\t\t\t\t// in addUnknownExtensionsToUserData().\r\n\t\t\t\t// Remove this workaround if we move all the existing\r\n\t\t\t\t// extension handlers to plugin system\r\n\r\n\t\t\t\textensions[plugin.name] = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (json.extensionsUsed) {\r\n\r\n\t\t\t\tfor (let i = 0; i < json.extensionsUsed.length; ++i) {\r\n\r\n\t\t\t\t\tconst extensionName = json.extensionsUsed[i];\r\n\t\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\r\n\r\n\t\t\t\t\tswitch (extensionName) {\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\r\n\t\t\t\t\t\t\textensions[extensionName] = new GLTFMaterialsUnlitExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\r\n\t\t\t\t\t\t\textensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\r\n\t\t\t\t\t\t\textensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\r\n\t\t\t\t\t\t\textensions[extensionName] = new GLTFTextureTransformExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\r\n\t\t\t\t\t\t\textensions[extensionName] = new GLTFMeshQuantizationExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tif (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparser.setExtensions(extensions);\r\n\t\t\tparser.setPlugins(plugins);\r\n\t\t\tparser.parse(onLoad, onError);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/* GLTFREGISTRY */\r\n\r\n\r\n\tfunction GLTFRegistry() {\r\n\r\n\t\tlet objects = {};\r\n\t\treturn {\r\n\t\t\tget: function (key) {\r\n\r\n\t\t\t\treturn objects[key];\r\n\r\n\t\t\t},\r\n\t\t\tadd: function (key, object) {\r\n\r\n\t\t\t\tobjects[key] = object;\r\n\r\n\t\t\t},\r\n\t\t\tremove: function (key) {\r\n\r\n\t\t\t\tdelete objects[key];\r\n\r\n\t\t\t},\r\n\t\t\tremoveAll: function () {\r\n\r\n\t\t\t\tobjects = {};\r\n\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t}\r\n\t/*********************************/\r\n\r\n\t/********** EXTENSIONS ***********/\r\n\r\n\t/*********************************/\r\n\r\n\r\n\tconst EXTENSIONS = {\r\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\r\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\r\n\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\r\n\t\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\r\n\t\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\r\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\r\n\t\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\r\n\t\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\r\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\r\n\t\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\r\n\t\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\r\n\t\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\r\n\t\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\r\n\t\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\r\n\t\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\r\n\t};\r\n\t/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n */\r\n\r\n\tclass GLTFLightsExtension {\r\n\r\n\t\tconstructor(parser) {\r\n\r\n\t\t\tthis.parser = parser;\r\n\t\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // THREE.Object3D instance caches\r\n\r\n\t\t\tthis.cache = {\r\n\t\t\t\trefs: {},\r\n\t\t\t\tuses: {}\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t_markDefs() {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst nodeDefs = this.parser.json.nodes || [];\r\n\r\n\t\t\tfor (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\r\n\r\n\t\t\t\tconst nodeDef = nodeDefs[nodeIndex];\r\n\r\n\t\t\t\tif (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\r\n\r\n\t\t\t\t\tparser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_loadLight(lightIndex) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst cacheKey = 'light:' + lightIndex;\r\n\t\t\tlet dependency = parser.cache.get(cacheKey);\r\n\t\t\tif (dependency) return dependency;\r\n\t\t\tconst json = parser.json;\r\n\t\t\tconst extensions = json.extensions && json.extensions[this.name] || {};\r\n\t\t\tconst lightDefs = extensions.lights || [];\r\n\t\t\tconst lightDef = lightDefs[lightIndex];\r\n\t\t\tlet lightNode;\r\n\t\t\tconst color = new THREE.Color(0xffffff);\r\n\t\t\tif (lightDef.color !== undefined) color.fromArray(lightDef.color);\r\n\t\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\r\n\r\n\t\t\tswitch (lightDef.type) {\r\n\r\n\t\t\t\tcase 'directional':\r\n\t\t\t\t\tlightNode = new THREE.DirectionalLight(color);\r\n\t\t\t\t\tlightNode.target.position.set(0, 0, - 1);\r\n\t\t\t\t\tlightNode.add(lightNode.target);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'point':\r\n\t\t\t\t\tlightNode = new THREE.PointLight(color);\r\n\t\t\t\t\tlightNode.distance = range;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'spot':\r\n\t\t\t\t\tlightNode = new THREE.SpotLight(color);\r\n\t\t\t\t\tlightNode.distance = range; // Handle spotlight properties.\r\n\r\n\t\t\t\t\tlightDef.spot = lightDef.spot || {};\r\n\t\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\r\n\t\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\r\n\t\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\r\n\t\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\r\n\t\t\t\t\tlightNode.target.position.set(0, 0, - 1);\r\n\t\t\t\t\tlightNode.add(lightNode.target);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);\r\n\r\n\t\t\t} // Some lights (e.g. spot) default to a position other than the origin. Reset the position\r\n\t\t\t// here, because node-level parsing will only override position if explicitly specified.\r\n\r\n\r\n\t\t\tlightNode.position.set(0, 0, 0);\r\n\t\t\tlightNode.decay = 2;\r\n\t\t\tif (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\r\n\t\t\tlightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);\r\n\t\t\tdependency = Promise.resolve(lightNode);\r\n\t\t\tparser.cache.add(cacheKey, dependency);\r\n\t\t\treturn dependency;\r\n\r\n\t\t}\r\n\r\n\t\tcreateNodeAttachment(nodeIndex) {\r\n\r\n\t\t\tconst self = this;\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst json = parser.json;\r\n\t\t\tconst nodeDef = json.nodes[nodeIndex];\r\n\t\t\tconst lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\r\n\t\t\tconst lightIndex = lightDef.light;\r\n\t\t\tif (lightIndex === undefined) return null;\r\n\t\t\treturn this._loadLight(lightIndex).then(function (light) {\r\n\r\n\t\t\t\treturn parser._getNodeRef(self.cache, lightIndex, light);\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n */\r\n\r\n\r\n\tclass GLTFMaterialsUnlitExtension {\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\r\n\r\n\t\t}\r\n\r\n\t\tgetMaterialType() {\r\n\r\n\t\t\treturn THREE.MeshBasicMaterial;\r\n\r\n\t\t}\r\n\r\n\t\textendParams(materialParams, materialDef, parser) {\r\n\r\n\t\t\tconst pending = [];\r\n\t\t\tmaterialParams.color = new THREE.Color(1.0, 1.0, 1.0);\r\n\t\t\tmaterialParams.opacity = 1.0;\r\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\r\n\r\n\t\t\tif (metallicRoughness) {\r\n\r\n\t\t\t\tif (Array.isArray(metallicRoughness.baseColorFactor)) {\r\n\r\n\t\t\t\t\tconst array = metallicRoughness.baseColorFactor;\r\n\t\t\t\t\tmaterialParams.color.fromArray(array);\r\n\t\t\t\t\tmaterialParams.opacity = array[3];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (metallicRoughness.baseColorTexture !== undefined) {\r\n\r\n\t\t\t\t\tpending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(pending);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * Clearcoat Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n */\r\n\r\n\r\n\tclass GLTFMaterialsClearcoatExtension {\r\n\r\n\t\tconstructor(parser) {\r\n\r\n\t\t\tthis.parser = parser;\r\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\r\n\r\n\t\t}\r\n\r\n\t\tgetMaterialType(materialIndex) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst materialDef = parser.json.materials[materialIndex];\r\n\t\t\tif (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n\t\t\treturn THREE.MeshPhysicalMaterial;\r\n\r\n\t\t}\r\n\r\n\t\textendMaterialParams(materialIndex, materialParams) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst materialDef = parser.json.materials[materialIndex];\r\n\r\n\t\t\tif (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n\r\n\t\t\t\treturn Promise.resolve();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pending = [];\r\n\t\t\tconst extension = materialDef.extensions[this.name];\r\n\r\n\t\t\tif (extension.clearcoatFactor !== undefined) {\r\n\r\n\t\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (extension.clearcoatTexture !== undefined) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (extension.clearcoatRoughnessFactor !== undefined) {\r\n\r\n\t\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (extension.clearcoatRoughnessTexture !== undefined) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (extension.clearcoatNormalTexture !== undefined) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));\r\n\r\n\t\t\t\tif (extension.clearcoatNormalTexture.scale !== undefined) {\r\n\r\n\t\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\r\n\t\t\t\t\tmaterialParams.clearcoatNormalScale = new THREE.Vector2(scale, - scale);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(pending);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\r\n */\r\n\r\n\r\n\tclass GLTFMaterialsTransmissionExtension {\r\n\r\n\t\tconstructor(parser) {\r\n\r\n\t\t\tthis.parser = parser;\r\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\r\n\r\n\t\t}\r\n\r\n\t\tgetMaterialType(materialIndex) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst materialDef = parser.json.materials[materialIndex];\r\n\t\t\tif (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n\t\t\treturn THREE.MeshPhysicalMaterial;\r\n\r\n\t\t}\r\n\r\n\t\textendMaterialParams(materialIndex, materialParams) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst materialDef = parser.json.materials[materialIndex];\r\n\r\n\t\t\tif (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n\r\n\t\t\t\treturn Promise.resolve();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pending = [];\r\n\t\t\tconst extension = materialDef.extensions[this.name];\r\n\r\n\t\t\tif (extension.transmissionFactor !== undefined) {\r\n\r\n\t\t\t\tmaterialParams.transmission = extension.transmissionFactor;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (extension.transmissionTexture !== undefined) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(pending);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * Materials Volume Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n */\r\n\r\n\r\n\tclass GLTFMaterialsVolumeExtension {\r\n\r\n\t\tconstructor(parser) {\r\n\r\n\t\t\tthis.parser = parser;\r\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\r\n\r\n\t\t}\r\n\r\n\t\tgetMaterialType(materialIndex) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst materialDef = parser.json.materials[materialIndex];\r\n\t\t\tif (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n\t\t\treturn THREE.MeshPhysicalMaterial;\r\n\r\n\t\t}\r\n\r\n\t\textendMaterialParams(materialIndex, materialParams) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst materialDef = parser.json.materials[materialIndex];\r\n\r\n\t\t\tif (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n\r\n\t\t\t\treturn Promise.resolve();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pending = [];\r\n\t\t\tconst extension = materialDef.extensions[this.name];\r\n\t\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\r\n\r\n\t\t\tif (extension.thicknessTexture !== undefined) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || 0;\r\n\t\t\tconst colorArray = extension.attenuationColor || [1, 1, 1];\r\n\t\t\tmaterialParams.attenuationTint = new THREE.Color(colorArray[0], colorArray[1], colorArray[2]);\r\n\t\t\treturn Promise.all(pending);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * Materials ior Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\r\n */\r\n\r\n\r\n\tclass GLTFMaterialsIorExtension {\r\n\r\n\t\tconstructor(parser) {\r\n\r\n\t\t\tthis.parser = parser;\r\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\r\n\r\n\t\t}\r\n\r\n\t\tgetMaterialType(materialIndex) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst materialDef = parser.json.materials[materialIndex];\r\n\t\t\tif (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n\t\t\treturn THREE.MeshPhysicalMaterial;\r\n\r\n\t\t}\r\n\r\n\t\textendMaterialParams(materialIndex, materialParams) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst materialDef = parser.json.materials[materialIndex];\r\n\r\n\t\t\tif (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n\r\n\t\t\t\treturn Promise.resolve();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst extension = materialDef.extensions[this.name];\r\n\t\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * Materials specular Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\r\n */\r\n\r\n\r\n\tclass GLTFMaterialsSpecularExtension {\r\n\r\n\t\tconstructor(parser) {\r\n\r\n\t\t\tthis.parser = parser;\r\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\r\n\r\n\t\t}\r\n\r\n\t\tgetMaterialType(materialIndex) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst materialDef = parser.json.materials[materialIndex];\r\n\t\t\tif (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n\t\t\treturn THREE.MeshPhysicalMaterial;\r\n\r\n\t\t}\r\n\r\n\t\textendMaterialParams(materialIndex, materialParams) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst materialDef = parser.json.materials[materialIndex];\r\n\r\n\t\t\tif (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n\r\n\t\t\t\treturn Promise.resolve();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pending = [];\r\n\t\t\tconst extension = materialDef.extensions[this.name];\r\n\t\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\r\n\r\n\t\t\tif (extension.specularTexture !== undefined) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst colorArray = extension.specularColorFactor || [1, 1, 1];\r\n\t\t\tmaterialParams.specularTint = new THREE.Color(colorArray[0], colorArray[1], colorArray[2]);\r\n\r\n\t\t\tif (extension.specularColorTexture !== undefined) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'specularTintMap', extension.specularColorTexture).then(function (texture) {\r\n\r\n\t\t\t\t\ttexture.encoding = THREE.sRGBEncoding;\r\n\r\n\t\t\t\t}));\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(pending);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * BasisU THREE.Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\r\n */\r\n\r\n\r\n\tclass GLTFTextureBasisUExtension {\r\n\r\n\t\tconstructor(parser) {\r\n\r\n\t\t\tthis.parser = parser;\r\n\t\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\r\n\r\n\t\t}\r\n\r\n\t\tloadTexture(textureIndex) {\r\n\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst json = parser.json;\r\n\t\t\tconst textureDef = json.textures[textureIndex];\r\n\r\n\t\t\tif (!textureDef.extensions || !textureDef.extensions[this.name]) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst extension = textureDef.extensions[this.name];\r\n\t\t\tconst source = json.images[extension.source];\r\n\t\t\tconst loader = parser.options.ktx2Loader;\r\n\r\n\t\t\tif (!loader) {\r\n\r\n\t\t\t\tif (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\r\n\r\n\t\t\t\t\tthrow new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn parser.loadTextureImage(textureIndex, source, loader);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * WebP THREE.Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\r\n */\r\n\r\n\r\n\tclass GLTFTextureWebPExtension {\r\n\r\n\t\tconstructor(parser) {\r\n\r\n\t\t\tthis.parser = parser;\r\n\t\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\r\n\t\t\tthis.isSupported = null;\r\n\r\n\t\t}\r\n\r\n\t\tloadTexture(textureIndex) {\r\n\r\n\t\t\tconst name = this.name;\r\n\t\t\tconst parser = this.parser;\r\n\t\t\tconst json = parser.json;\r\n\t\t\tconst textureDef = json.textures[textureIndex];\r\n\r\n\t\t\tif (!textureDef.extensions || !textureDef.extensions[name]) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst extension = textureDef.extensions[name];\r\n\t\t\tconst source = json.images[extension.source];\r\n\t\t\tlet loader = parser.textureLoader;\r\n\r\n\t\t\tif (source.uri) {\r\n\r\n\t\t\t\tconst handler = parser.options.manager.getHandler(source.uri);\r\n\t\t\t\tif (handler !== null) loader = handler;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.detectSupport().then(function (isSupported) {\r\n\r\n\t\t\t\tif (isSupported) return parser.loadTextureImage(textureIndex, source, loader);\r\n\r\n\t\t\t\tif (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\r\n\r\n\t\t\t\t\tthrow new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');\r\n\r\n\t\t\t\t} // Fall back to PNG or JPEG.\r\n\r\n\r\n\t\t\t\treturn parser.loadTexture(textureIndex);\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tdetectSupport() {\r\n\r\n\t\t\tif (!this.isSupported) {\r\n\r\n\t\t\t\tthis.isSupported = new Promise(function (resolve) {\r\n\r\n\t\t\t\t\tconst image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all\r\n\t\t\t\t\t// WebP images, unfortunately.\r\n\r\n\t\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\r\n\r\n\t\t\t\t\timage.onload = image.onerror = function () {\r\n\r\n\t\t\t\t\t\tresolve(image.height === 1);\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.isSupported;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * meshopt BufferView Compression Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\r\n */\r\n\r\n\r\n\tclass GLTFMeshoptCompression {\r\n\r\n\t\tconstructor(parser) {\r\n\r\n\t\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\r\n\t\t\tthis.parser = parser;\r\n\r\n\t\t}\r\n\r\n\t\tloadBufferView(index) {\r\n\r\n\t\t\tconst json = this.parser.json;\r\n\t\t\tconst bufferView = json.bufferViews[index];\r\n\r\n\t\t\tif (bufferView.extensions && bufferView.extensions[this.name]) {\r\n\r\n\t\t\t\tconst extensionDef = bufferView.extensions[this.name];\r\n\t\t\t\tconst buffer = this.parser.getDependency('buffer', extensionDef.buffer);\r\n\t\t\t\tconst decoder = this.parser.options.meshoptDecoder;\r\n\r\n\t\t\t\tif (!decoder || !decoder.supported) {\r\n\r\n\t\t\t\t\tif (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\r\n\r\n\t\t\t\t\t\tthrow new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\r\n\t\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Promise.all([buffer, decoder.ready]).then(function (res) {\r\n\r\n\t\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\r\n\t\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\r\n\t\t\t\t\tconst count = extensionDef.count;\r\n\t\t\t\t\tconst stride = extensionDef.byteStride;\r\n\t\t\t\t\tconst result = new ArrayBuffer(count * stride);\r\n\t\t\t\t\tconst source = new Uint8Array(res[0], byteOffset, byteLength);\r\n\t\t\t\t\tdecoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\r\n\t\t\t\t\treturn result;\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/* BINARY EXTENSION */\r\n\r\n\r\n\tconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\r\n\tconst BINARY_EXTENSION_HEADER_LENGTH = 12;\r\n\tconst BINARY_EXTENSION_CHUNK_TYPES = {\r\n\t\tJSON: 0x4E4F534A,\r\n\t\tBIN: 0x004E4942\r\n\t};\r\n\r\n\tclass GLTFBinaryExtension {\r\n\r\n\t\tconstructor(data) {\r\n\r\n\t\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\r\n\t\t\tthis.content = null;\r\n\t\t\tthis.body = null;\r\n\t\t\tconst headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\r\n\t\t\tthis.header = {\r\n\t\t\t\tmagic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\r\n\t\t\t\tversion: headerView.getUint32(4, true),\r\n\t\t\t\tlength: headerView.getUint32(8, true)\r\n\t\t\t};\r\n\r\n\t\t\tif (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\r\n\r\n\t\t\t\tthrow new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\r\n\r\n\t\t\t} else if (this.header.version < 2.0) {\r\n\r\n\t\t\t\tthrow new Error('THREE.GLTFLoader: Legacy binary file detected.');\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\r\n\t\t\tconst chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\r\n\t\t\tlet chunkIndex = 0;\r\n\r\n\t\t\twhile (chunkIndex < chunkContentsLength) {\r\n\r\n\t\t\t\tconst chunkLength = chunkView.getUint32(chunkIndex, true);\r\n\t\t\t\tchunkIndex += 4;\r\n\t\t\t\tconst chunkType = chunkView.getUint32(chunkIndex, true);\r\n\t\t\t\tchunkIndex += 4;\r\n\r\n\t\t\t\tif (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\r\n\r\n\t\t\t\t\tconst contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\r\n\t\t\t\t\tthis.content = THREE.LoaderUtils.decodeText(contentArray);\r\n\r\n\t\t\t\t} else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\r\n\r\n\t\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\r\n\t\t\t\t\tthis.body = data.slice(byteOffset, byteOffset + chunkLength);\r\n\r\n\t\t\t\t} // Clients must ignore chunks with unknown types.\r\n\r\n\r\n\t\t\t\tchunkIndex += chunkLength;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (this.content === null) {\r\n\r\n\t\t\t\tthrow new Error('THREE.GLTFLoader: JSON content not found.');\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * DRACO THREE.Mesh Compression Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\r\n */\r\n\r\n\r\n\tclass GLTFDracoMeshCompressionExtension {\r\n\r\n\t\tconstructor(json, dracoLoader) {\r\n\r\n\t\t\tif (!dracoLoader) {\r\n\r\n\t\t\t\tthrow new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\r\n\t\t\tthis.json = json;\r\n\t\t\tthis.dracoLoader = dracoLoader;\r\n\t\t\tthis.dracoLoader.preload();\r\n\r\n\t\t}\r\n\r\n\t\tdecodePrimitive(primitive, parser) {\r\n\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst dracoLoader = this.dracoLoader;\r\n\t\t\tconst bufferViewIndex = primitive.extensions[this.name].bufferView;\r\n\t\t\tconst gltfAttributeMap = primitive.extensions[this.name].attributes;\r\n\t\t\tconst threeAttributeMap = {};\r\n\t\t\tconst attributeNormalizedMap = {};\r\n\t\t\tconst attributeTypeMap = {};\r\n\r\n\t\t\tfor (const attributeName in gltfAttributeMap) {\r\n\r\n\t\t\t\tconst threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\r\n\t\t\t\tthreeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor (const attributeName in primitive.attributes) {\r\n\r\n\t\t\t\tconst threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\r\n\r\n\t\t\t\tif (gltfAttributeMap[attributeName] !== undefined) {\r\n\r\n\t\t\t\t\tconst accessorDef = json.accessors[primitive.attributes[attributeName]];\r\n\t\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\r\n\t\t\t\t\tattributeTypeMap[threeAttributeName] = componentType;\r\n\t\t\t\t\tattributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\r\n\r\n\t\t\t\treturn new Promise(function (resolve) {\r\n\r\n\t\t\t\t\tdracoLoader.decodeDracoFile(bufferView, function (geometry) {\r\n\r\n\t\t\t\t\t\tfor (const attributeName in geometry.attributes) {\r\n\r\n\t\t\t\t\t\t\tconst attribute = geometry.attributes[attributeName];\r\n\t\t\t\t\t\t\tconst normalized = attributeNormalizedMap[attributeName];\r\n\t\t\t\t\t\t\tif (normalized !== undefined) attribute.normalized = normalized;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tresolve(geometry);\r\n\r\n\t\t\t\t\t}, threeAttributeMap, attributeTypeMap);\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * THREE.Texture Transform Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\r\n */\r\n\r\n\r\n\tclass GLTFTextureTransformExtension {\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\r\n\r\n\t\t}\r\n\r\n\t\textendTexture(texture, transform) {\r\n\r\n\t\t\tif (transform.texCoord !== undefined) {\r\n\r\n\t\t\t\tconsole.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {\r\n\r\n\t\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\r\n\t\t\t\treturn texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture = texture.clone();\r\n\r\n\t\t\tif (transform.offset !== undefined) {\r\n\r\n\t\t\t\ttexture.offset.fromArray(transform.offset);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (transform.rotation !== undefined) {\r\n\r\n\t\t\t\ttexture.rotation = transform.rotation;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (transform.scale !== undefined) {\r\n\r\n\t\t\t\ttexture.repeat.fromArray(transform.scale);\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\t\t\treturn texture;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * Specular-Glossiness Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\r\n */\r\n\r\n\t/**\r\n * A sub class of StandardMaterial with some of the functionality\r\n * changed via the `onBeforeCompile` callback\r\n * @pailhead\r\n */\r\n\r\n\r\n\tclass GLTFMeshStandardSGMaterial extends THREE.MeshStandardMaterial {\r\n\r\n\t\tconstructor(params) {\r\n\r\n\t\t\tsuper();\r\n\t\t\tthis.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing\r\n\r\n\t\t\tconst specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\r\n\t\t\tconst glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\r\n\t\t\tconst specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\r\n\t\t\tconst glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\r\n\t\t\tconst lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.roughness += geometryRoughness;', 'material.roughness = min( material.roughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\\n');\r\n\t\t\tconst uniforms = {\r\n\t\t\t\tspecular: {\r\n\t\t\t\t\tvalue: new THREE.Color().setHex(0xffffff)\r\n\t\t\t\t},\r\n\t\t\t\tglossiness: {\r\n\t\t\t\t\tvalue: 1\r\n\t\t\t\t},\r\n\t\t\t\tspecularMap: {\r\n\t\t\t\t\tvalue: null\r\n\t\t\t\t},\r\n\t\t\t\tglossinessMap: {\r\n\t\t\t\t\tvalue: null\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tthis._extraUniforms = uniforms;\r\n\r\n\t\t\tthis.onBeforeCompile = function (shader) {\r\n\r\n\t\t\t\tfor (const uniformName in uniforms) {\r\n\r\n\t\t\t\t\tshader.uniforms[uniformName] = uniforms[uniformName];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\r\n\r\n\t\t\t};\r\n\r\n\t\t\tObject.defineProperties(this, {\r\n\t\t\t\tspecular: {\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn uniforms.specular.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (v) {\r\n\r\n\t\t\t\t\t\tuniforms.specular.value = v;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tspecularMap: {\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn uniforms.specularMap.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (v) {\r\n\r\n\t\t\t\t\t\tuniforms.specularMap.value = v;\r\n\r\n\t\t\t\t\t\tif (v) {\r\n\r\n\t\t\t\t\t\t\tthis.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tdelete this.defines.USE_SPECULARMAP;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tglossiness: {\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn uniforms.glossiness.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (v) {\r\n\r\n\t\t\t\t\t\tuniforms.glossiness.value = v;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tglossinessMap: {\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn uniforms.glossinessMap.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (v) {\r\n\r\n\t\t\t\t\t\tuniforms.glossinessMap.value = v;\r\n\r\n\t\t\t\t\t\tif (v) {\r\n\r\n\t\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\r\n\t\t\t\t\t\t\tthis.defines.USE_UV = '';\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\r\n\t\t\t\t\t\t\tdelete this.defines.USE_UV;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tdelete this.metalness;\r\n\t\t\tdelete this.roughness;\r\n\t\t\tdelete this.metalnessMap;\r\n\t\t\tdelete this.roughnessMap;\r\n\t\t\tthis.setValues(params);\r\n\r\n\t\t}\r\n\r\n\t\tcopy(source) {\r\n\r\n\t\t\tsuper.copy(source);\r\n\t\t\tthis.specularMap = source.specularMap;\r\n\t\t\tthis.specular.copy(source.specular);\r\n\t\t\tthis.glossinessMap = source.glossinessMap;\r\n\t\t\tthis.glossiness = source.glossiness;\r\n\t\t\tdelete this.metalness;\r\n\t\t\tdelete this.roughness;\r\n\t\t\tdelete this.metalnessMap;\r\n\t\t\tdelete this.roughnessMap;\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tclass GLTFMaterialsPbrSpecularGlossinessExtension {\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\t\t\tthis.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];\r\n\r\n\t\t}\r\n\r\n\t\tgetMaterialType() {\r\n\r\n\t\t\treturn GLTFMeshStandardSGMaterial;\r\n\r\n\t\t}\r\n\r\n\t\textendParams(materialParams, materialDef, parser) {\r\n\r\n\t\t\tconst pbrSpecularGlossiness = materialDef.extensions[this.name];\r\n\t\t\tmaterialParams.color = new THREE.Color(1.0, 1.0, 1.0);\r\n\t\t\tmaterialParams.opacity = 1.0;\r\n\t\t\tconst pending = [];\r\n\r\n\t\t\tif (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\r\n\r\n\t\t\t\tconst array = pbrSpecularGlossiness.diffuseFactor;\r\n\t\t\t\tmaterialParams.color.fromArray(array);\r\n\t\t\t\tmaterialParams.opacity = array[3];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (pbrSpecularGlossiness.diffuseTexture !== undefined) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams.emissive = new THREE.Color(0.0, 0.0, 0.0);\r\n\t\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\r\n\t\t\tmaterialParams.specular = new THREE.Color(1.0, 1.0, 1.0);\r\n\r\n\t\t\tif (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\r\n\r\n\t\t\t\tmaterialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\r\n\r\n\t\t\t\tconst specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(pending);\r\n\r\n\t\t}\r\n\r\n\t\tcreateMaterial(materialParams) {\r\n\r\n\t\t\tconst material = new GLTFMeshStandardSGMaterial(materialParams);\r\n\t\t\tmaterial.fog = true;\r\n\t\t\tmaterial.color = materialParams.color;\r\n\t\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\r\n\t\t\tmaterial.lightMap = null;\r\n\t\t\tmaterial.lightMapIntensity = 1.0;\r\n\t\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\r\n\t\t\tmaterial.aoMapIntensity = 1.0;\r\n\t\t\tmaterial.emissive = materialParams.emissive;\r\n\t\t\tmaterial.emissiveIntensity = 1.0;\r\n\t\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\r\n\t\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\r\n\t\t\tmaterial.bumpScale = 1;\r\n\t\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\r\n\t\t\tmaterial.normalMapType = THREE.TangentSpaceNormalMap;\r\n\t\t\tif (materialParams.normalScale) material.normalScale = materialParams.normalScale;\r\n\t\t\tmaterial.displacementMap = null;\r\n\t\t\tmaterial.displacementScale = 1;\r\n\t\t\tmaterial.displacementBias = 0;\r\n\t\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\r\n\t\t\tmaterial.specular = materialParams.specular;\r\n\t\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\r\n\t\t\tmaterial.glossiness = materialParams.glossiness;\r\n\t\t\tmaterial.alphaMap = null;\r\n\t\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\r\n\t\t\tmaterial.envMapIntensity = 1.0;\r\n\t\t\tmaterial.refractionRatio = 0.98;\r\n\t\t\treturn material;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * THREE.Mesh Quantization Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\r\n */\r\n\r\n\r\n\tclass GLTFMeshQuantizationExtension {\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/*********************************/\r\n\r\n\t/********** INTERPOLATION ********/\r\n\r\n\t/*********************************/\r\n\t// Spline Interpolation\r\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\r\n\r\n\r\n\tclass GLTFCubicSplineInterpolant extends THREE.Interpolant {\r\n\r\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\r\n\r\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\r\n\r\n\t\t}\r\n\r\n\t\tcopySampleValue_(index) {\r\n\r\n\t\t\t// Copies a sample value to the result buffer. See description of glTF\r\n\t\t\t// CUBICSPLINE values layout in interpolate_() function below.\r\n\t\t\tconst result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tvalueSize = this.valueSize,\r\n\t\t\t\toffset = index * valueSize * 3 + valueSize;\r\n\r\n\t\t\tfor (let i = 0; i !== valueSize; i++) {\r\n\r\n\t\t\t\tresult[i] = values[offset + i];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\tGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\r\n\r\n\t\tconst result = this.resultBuffer;\r\n\t\tconst values = this.sampleValues;\r\n\t\tconst stride = this.valueSize;\r\n\t\tconst stride2 = stride * 2;\r\n\t\tconst stride3 = stride * 3;\r\n\t\tconst td = t1 - t0;\r\n\t\tconst p = (t - t0) / td;\r\n\t\tconst pp = p * p;\r\n\t\tconst ppp = pp * p;\r\n\t\tconst offset1 = i1 * stride3;\r\n\t\tconst offset0 = offset1 - stride3;\r\n\t\tconst s2 = - 2 * ppp + 3 * pp;\r\n\t\tconst s3 = ppp - pp;\r\n\t\tconst s0 = 1 - s2;\r\n\t\tconst s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\r\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\r\n\r\n\t\tfor (let i = 0; i !== stride; i++) {\r\n\r\n\t\t\tconst p0 = values[offset0 + i + stride]; // splineVertex_k\r\n\r\n\t\t\tconst m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\r\n\r\n\t\t\tconst p1 = values[offset1 + i + stride]; // splineVertex_k+1\r\n\r\n\t\t\tconst m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\r\n\r\n\t\t\tresult[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\tconst _q = new THREE.Quaternion();\r\n\r\n\tclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\r\n\r\n\t\tinterpolate_(i1, t0, t, t1) {\r\n\r\n\t\t\tconst result = super.interpolate_(i1, t0, t, t1);\r\n\r\n\t\t\t_q.fromArray(result).normalize().toArray(result);\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/*********************************/\r\n\r\n\t/********** INTERNALS ************/\r\n\r\n\t/*********************************/\r\n\r\n\t/* CONSTANTS */\r\n\r\n\r\n\tconst WEBGL_CONSTANTS = {\r\n\t\tFLOAT: 5126,\r\n\t\t//FLOAT_MAT2: 35674,\r\n\t\tFLOAT_MAT3: 35675,\r\n\t\tFLOAT_MAT4: 35676,\r\n\t\tFLOAT_VEC2: 35664,\r\n\t\tFLOAT_VEC3: 35665,\r\n\t\tFLOAT_VEC4: 35666,\r\n\t\tLINEAR: 9729,\r\n\t\tREPEAT: 10497,\r\n\t\tSAMPLER_2D: 35678,\r\n\t\tPOINTS: 0,\r\n\t\tLINES: 1,\r\n\t\tLINE_LOOP: 2,\r\n\t\tLINE_STRIP: 3,\r\n\t\tTRIANGLES: 4,\r\n\t\tTRIANGLE_STRIP: 5,\r\n\t\tTRIANGLE_FAN: 6,\r\n\t\tUNSIGNED_BYTE: 5121,\r\n\t\tUNSIGNED_SHORT: 5123\r\n\t};\r\n\tconst WEBGL_COMPONENT_TYPES = {\r\n\t\t5120: Int8Array,\r\n\t\t5121: Uint8Array,\r\n\t\t5122: Int16Array,\r\n\t\t5123: Uint16Array,\r\n\t\t5125: Uint32Array,\r\n\t\t5126: Float32Array\r\n\t};\r\n\tconst WEBGL_FILTERS = {\r\n\t\t9728: THREE.NearestFilter,\r\n\t\t9729: THREE.LinearFilter,\r\n\t\t9984: THREE.NearestMipmapNearestFilter,\r\n\t\t9985: THREE.LinearMipmapNearestFilter,\r\n\t\t9986: THREE.NearestMipmapLinearFilter,\r\n\t\t9987: THREE.LinearMipmapLinearFilter\r\n\t};\r\n\tconst WEBGL_WRAPPINGS = {\r\n\t\t33071: THREE.ClampToEdgeWrapping,\r\n\t\t33648: THREE.MirroredRepeatWrapping,\r\n\t\t10497: THREE.RepeatWrapping\r\n\t};\r\n\tconst WEBGL_TYPE_SIZES = {\r\n\t\t'SCALAR': 1,\r\n\t\t'VEC2': 2,\r\n\t\t'VEC3': 3,\r\n\t\t'VEC4': 4,\r\n\t\t'MAT2': 4,\r\n\t\t'MAT3': 9,\r\n\t\t'MAT4': 16\r\n\t};\r\n\tconst ATTRIBUTES = {\r\n\t\tPOSITION: 'position',\r\n\t\tNORMAL: 'normal',\r\n\t\tTANGENT: 'tangent',\r\n\t\tTEXCOORD_0: 'uv',\r\n\t\tTEXCOORD_1: 'uv2',\r\n\t\tCOLOR_0: 'color',\r\n\t\tWEIGHTS_0: 'skinWeight',\r\n\t\tJOINTS_0: 'skinIndex'\r\n\t};\r\n\tconst PATH_PROPERTIES = {\r\n\t\tscale: 'scale',\r\n\t\ttranslation: 'position',\r\n\t\trotation: 'quaternion',\r\n\t\tweights: 'morphTargetInfluences'\r\n\t};\r\n\tconst INTERPOLATION = {\r\n\t\tCUBICSPLINE: undefined,\r\n\t\t// We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\r\n\t\t// keyframe track will be initialized with a default interpolation type, then modified.\r\n\t\tLINEAR: THREE.InterpolateLinear,\r\n\t\tSTEP: THREE.InterpolateDiscrete\r\n\t};\r\n\tconst ALPHA_MODES = {\r\n\t\tOPAQUE: 'OPAQUE',\r\n\t\tMASK: 'MASK',\r\n\t\tBLEND: 'BLEND'\r\n\t};\r\n\t/* UTILITY FUNCTIONS */\r\n\r\n\tfunction resolveURL(url, path) {\r\n\r\n\t\t// Invalid URL\r\n\t\tif (typeof url !== 'string' || url === '') return ''; // Host Relative URL\r\n\r\n\t\tif (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\r\n\r\n\t\t\tpath = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\r\n\r\n\t\t} // Absolute URL http://,https://,//\r\n\r\n\r\n\t\tif (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\r\n\r\n\t\tif (/^data:.*,.*$/i.test(url)) return url; // Blob URL\r\n\r\n\t\tif (/^blob:.*$/i.test(url)) return url; // Relative URL\r\n\r\n\t\treturn path + url;\r\n\r\n\t}\r\n\t/**\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\r\n */\r\n\r\n\r\n\tfunction createDefaultMaterial(cache) {\r\n\r\n\t\tif (cache['DefaultMaterial'] === undefined) {\r\n\r\n\t\t\tcache['DefaultMaterial'] = new THREE.MeshStandardMaterial({\r\n\t\t\t\tcolor: 0xFFFFFF,\r\n\t\t\t\temissive: 0x000000,\r\n\t\t\t\tmetalness: 1,\r\n\t\t\t\troughness: 1,\r\n\t\t\t\ttransparent: false,\r\n\t\t\t\tdepthTest: true,\r\n\t\t\t\tside: THREE.FrontSide\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\treturn cache['DefaultMaterial'];\r\n\r\n\t}\r\n\r\n\tfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\r\n\r\n\t\t// Add unknown glTF extensions to an object's userData.\r\n\t\tfor (const name in objectDef.extensions) {\r\n\r\n\t\t\tif (knownExtensions[name] === undefined) {\r\n\r\n\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\r\n\t\t\t\tobject.userData.gltfExtensions[name] = objectDef.extensions[name];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * @param {Object3D|Material|BufferGeometry} object\r\n * @param {GLTF.definition} gltfDef\r\n */\r\n\r\n\r\n\tfunction assignExtrasToUserData(object, gltfDef) {\r\n\r\n\t\tif (gltfDef.extras !== undefined) {\r\n\r\n\t\t\tif (typeof gltfDef.extras === 'object') {\r\n\r\n\t\t\t\tObject.assign(object.userData, gltfDef.extras);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/**\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\r\n *\r\n * @param {BufferGeometry} geometry\r\n * @param {Array<GLTF.Target>} targets\r\n * @param {GLTFParser} parser\r\n * @return {Promise<BufferGeometry>}\r\n */\r\n\r\n\r\n\tfunction addMorphTargets(geometry, targets, parser) {\r\n\r\n\t\tlet hasMorphPosition = false;\r\n\t\tlet hasMorphNormal = false;\r\n\r\n\t\tfor (let i = 0, il = targets.length; i < il; i++) {\r\n\r\n\t\t\tconst target = targets[i];\r\n\t\t\tif (target.POSITION !== undefined) hasMorphPosition = true;\r\n\t\t\tif (target.NORMAL !== undefined) hasMorphNormal = true;\r\n\t\t\tif (hasMorphPosition && hasMorphNormal) break;\r\n\r\n\t\t}\r\n\r\n\t\tif (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\r\n\t\tconst pendingPositionAccessors = [];\r\n\t\tconst pendingNormalAccessors = [];\r\n\r\n\t\tfor (let i = 0, il = targets.length; i < il; i++) {\r\n\r\n\t\t\tconst target = targets[i];\r\n\r\n\t\t\tif (hasMorphPosition) {\r\n\r\n\t\t\t\tconst pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\r\n\t\t\t\tpendingPositionAccessors.push(pendingAccessor);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (hasMorphNormal) {\r\n\r\n\t\t\t\tconst pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\r\n\t\t\t\tpendingNormalAccessors.push(pendingAccessor);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\r\n\r\n\t\t\tconst morphPositions = accessors[0];\r\n\t\t\tconst morphNormals = accessors[1];\r\n\t\t\tif (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\r\n\t\t\tif (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\r\n\t\t\tgeometry.morphTargetsRelative = true;\r\n\t\t\treturn geometry;\r\n\r\n\t\t});\r\n\r\n\t}\r\n\t/**\r\n * @param {Mesh} mesh\r\n * @param {GLTF.Mesh} meshDef\r\n */\r\n\r\n\r\n\tfunction updateMorphTargets(mesh, meshDef) {\r\n\r\n\t\tmesh.updateMorphTargets();\r\n\r\n\t\tif (meshDef.weights !== undefined) {\r\n\r\n\t\t\tfor (let i = 0, il = meshDef.weights.length; i < il; i++) {\r\n\r\n\t\t\t\tmesh.morphTargetInfluences[i] = meshDef.weights[i];\r\n\r\n\t\t\t}\r\n\r\n\t\t} // .extras has user-defined data, so check that .extras.targetNames is an array.\r\n\r\n\r\n\t\tif (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\r\n\r\n\t\t\tconst targetNames = meshDef.extras.targetNames;\r\n\r\n\t\t\tif (mesh.morphTargetInfluences.length === targetNames.length) {\r\n\r\n\t\t\t\tmesh.morphTargetDictionary = {};\r\n\r\n\t\t\t\tfor (let i = 0, il = targetNames.length; i < il; i++) {\r\n\r\n\t\t\t\t\tmesh.morphTargetDictionary[targetNames[i]] = i;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createPrimitiveKey(primitiveDef) {\r\n\r\n\t\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\r\n\t\tlet geometryKey;\r\n\r\n\t\tif (dracoExtension) {\r\n\r\n\t\t\tgeometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\r\n\r\n\t\t}\r\n\r\n\t\treturn geometryKey;\r\n\r\n\t}\r\n\r\n\tfunction createAttributesKey(attributes) {\r\n\r\n\t\tlet attributesKey = '';\r\n\t\tconst keys = Object.keys(attributes).sort();\r\n\r\n\t\tfor (let i = 0, il = keys.length; i < il; i++) {\r\n\r\n\t\t\tattributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\r\n\r\n\t\t}\r\n\r\n\t\treturn attributesKey;\r\n\r\n\t}\r\n\r\n\tfunction getNormalizedComponentScale(constructor) {\r\n\r\n\t\t// Reference:\r\n\t\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\r\n\t\tswitch (constructor) {\r\n\r\n\t\t\tcase Int8Array:\r\n\t\t\t\treturn 1 / 127;\r\n\r\n\t\t\tcase Uint8Array:\r\n\t\t\t\treturn 1 / 255;\r\n\r\n\t\t\tcase Int16Array:\r\n\t\t\t\treturn 1 / 32767;\r\n\r\n\t\t\tcase Uint16Array:\r\n\t\t\t\treturn 1 / 65535;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t/* GLTF PARSER */\r\n\r\n\r\n\tclass GLTFParser {\r\n\r\n\t\tconstructor(json = {}, options = {}) {\r\n\r\n\t\t\tthis.json = json;\r\n\t\t\tthis.extensions = {};\r\n\t\t\tthis.plugins = {};\r\n\t\t\tthis.options = options; // loader object cache\r\n\r\n\t\t\tthis.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements\r\n\r\n\t\t\tthis.associations = new Map(); // THREE.BufferGeometry caching\r\n\r\n\t\t\tthis.primitiveCache = {}; // THREE.Object3D instance caches\r\n\r\n\t\t\tthis.meshCache = {\r\n\t\t\t\trefs: {},\r\n\t\t\t\tuses: {}\r\n\t\t\t};\r\n\t\t\tthis.cameraCache = {\r\n\t\t\t\trefs: {},\r\n\t\t\t\tuses: {}\r\n\t\t\t};\r\n\t\t\tthis.lightCache = {\r\n\t\t\t\trefs: {},\r\n\t\t\t\tuses: {}\r\n\t\t\t};\r\n\t\t\tthis.textureCache = {}; // Track node names, to ensure no duplicates\r\n\r\n\t\t\tthis.nodeNamesUsed = {}; // Use an THREE.ImageBitmapLoader if imageBitmaps are supported. Moves much of the\r\n\t\t\t// expensive work of uploading a texture to the GPU off the main thread.\r\n\r\n\t\t\tif (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {\r\n\r\n\t\t\t\tthis.textureLoader = new THREE.ImageBitmapLoader(this.options.manager);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.textureLoader = new THREE.TextureLoader(this.options.manager);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.textureLoader.setCrossOrigin(this.options.crossOrigin);\r\n\t\t\tthis.textureLoader.setRequestHeader(this.options.requestHeader);\r\n\t\t\tthis.fileLoader = new THREE.FileLoader(this.options.manager);\r\n\t\t\tthis.fileLoader.setResponseType('arraybuffer');\r\n\r\n\t\t\tif (this.options.crossOrigin === 'use-credentials') {\r\n\r\n\t\t\t\tthis.fileLoader.setWithCredentials(true);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsetExtensions(extensions) {\r\n\r\n\t\t\tthis.extensions = extensions;\r\n\r\n\t\t}\r\n\r\n\t\tsetPlugins(plugins) {\r\n\r\n\t\t\tthis.plugins = plugins;\r\n\r\n\t\t}\r\n\r\n\t\tparse(onLoad, onError) {\r\n\r\n\t\t\tconst parser = this;\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst extensions = this.extensions; // Clear the loader cache\r\n\r\n\t\t\tthis.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\r\n\r\n\t\t\tthis._invokeAll(function (ext) {\r\n\r\n\t\t\t\treturn ext._markDefs && ext._markDefs();\r\n\r\n\t\t\t});\r\n\r\n\t\t\tPromise.all(this._invokeAll(function (ext) {\r\n\r\n\t\t\t\treturn ext.beforeRoot && ext.beforeRoot();\r\n\r\n\t\t\t})).then(function () {\r\n\r\n\t\t\t\treturn Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);\r\n\r\n\t\t\t}).then(function (dependencies) {\r\n\r\n\t\t\t\tconst result = {\r\n\t\t\t\t\tscene: dependencies[0][json.scene || 0],\r\n\t\t\t\t\tscenes: dependencies[0],\r\n\t\t\t\t\tanimations: dependencies[1],\r\n\t\t\t\t\tcameras: dependencies[2],\r\n\t\t\t\t\tasset: json.asset,\r\n\t\t\t\t\tparser: parser,\r\n\t\t\t\t\tuserData: {}\r\n\t\t\t\t};\r\n\t\t\t\taddUnknownExtensionsToUserData(extensions, result, json);\r\n\t\t\t\tassignExtrasToUserData(result, json);\r\n\t\t\t\tPromise.all(parser._invokeAll(function (ext) {\r\n\r\n\t\t\t\t\treturn ext.afterRoot && ext.afterRoot(result);\r\n\r\n\t\t\t\t})).then(function () {\r\n\r\n\t\t\t\t\tonLoad(result);\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t}).catch(onError);\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Marks the special nodes/meshes in json for efficient parse.\r\n   */\r\n\r\n\r\n\t\t_markDefs() {\r\n\r\n\t\t\tconst nodeDefs = this.json.nodes || [];\r\n\t\t\tconst skinDefs = this.json.skins || [];\r\n\t\t\tconst meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a THREE.Bone or an\r\n\t\t\t// THREE.Object3D. Use the skins' joint references to mark bones.\r\n\r\n\t\t\tfor (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\r\n\r\n\t\t\t\tconst joints = skinDefs[skinIndex].joints;\r\n\r\n\t\t\t\tfor (let i = 0, il = joints.length; i < il; i++) {\r\n\r\n\t\t\t\t\tnodeDefs[joints[i]].isBone = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} // Iterate over all nodes, marking references to shared resources,\r\n\t\t\t// as well as skeleton joints.\r\n\r\n\r\n\t\t\tfor (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\r\n\r\n\t\t\t\tconst nodeDef = nodeDefs[nodeIndex];\r\n\r\n\t\t\t\tif (nodeDef.mesh !== undefined) {\r\n\r\n\t\t\t\t\tthis._addNodeRef(this.meshCache, nodeDef.mesh); // Nothing in the mesh definition indicates whether it is\r\n\t\t\t\t\t// a THREE.SkinnedMesh or THREE.Mesh. Use the node's mesh reference\r\n\t\t\t\t\t// to mark THREE.SkinnedMesh if node has skin.\r\n\r\n\r\n\t\t\t\t\tif (nodeDef.skin !== undefined) {\r\n\r\n\t\t\t\t\t\tmeshDefs[nodeDef.mesh].isSkinnedMesh = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (nodeDef.camera !== undefined) {\r\n\r\n\t\t\t\t\tthis._addNodeRef(this.cameraCache, nodeDef.camera);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Counts references to shared node / THREE.Object3D resources. These resources\r\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\r\n   * hierarchy. THREE.Mesh, Camera, and Light instances are instantiated and must\r\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\r\n   * Textures) can be reused directly and are not marked here.\r\n   *\r\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\r\n   */\r\n\r\n\r\n\t\t_addNodeRef(cache, index) {\r\n\r\n\t\t\tif (index === undefined) return;\r\n\r\n\t\t\tif (cache.refs[index] === undefined) {\r\n\r\n\t\t\t\tcache.refs[index] = cache.uses[index] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcache.refs[index]++;\r\n\r\n\t\t}\r\n\t\t/** Returns a reference to a shared resource, cloning it if necessary. */\r\n\r\n\r\n\t\t_getNodeRef(cache, index, object) {\r\n\r\n\t\t\tif (cache.refs[index] <= 1) return object;\r\n\t\t\tconst ref = object.clone();\r\n\t\t\tref.name += '_instance_' + cache.uses[index]++;\r\n\t\t\treturn ref;\r\n\r\n\t\t}\r\n\r\n\t\t_invokeOne(func) {\r\n\r\n\t\t\tconst extensions = Object.values(this.plugins);\r\n\t\t\textensions.push(this);\r\n\r\n\t\t\tfor (let i = 0; i < extensions.length; i++) {\r\n\r\n\t\t\t\tconst result = func(extensions[i]);\r\n\t\t\t\tif (result) return result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t_invokeAll(func) {\r\n\r\n\t\t\tconst extensions = Object.values(this.plugins);\r\n\t\t\textensions.unshift(this);\r\n\t\t\tconst pending = [];\r\n\r\n\t\t\tfor (let i = 0; i < extensions.length; i++) {\r\n\r\n\t\t\t\tconst result = func(extensions[i]);\r\n\t\t\t\tif (result) pending.push(result);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn pending;\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Requests the specified dependency asynchronously, with caching.\r\n   * @param {string} type\r\n   * @param {number} index\r\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\r\n   */\r\n\r\n\r\n\t\tgetDependency(type, index) {\r\n\r\n\t\t\tconst cacheKey = type + ':' + index;\r\n\t\t\tlet dependency = this.cache.get(cacheKey);\r\n\r\n\t\t\tif (!dependency) {\r\n\r\n\t\t\t\tswitch (type) {\r\n\r\n\t\t\t\t\tcase 'scene':\r\n\t\t\t\t\t\tdependency = this.loadScene(index);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'node':\r\n\t\t\t\t\t\tdependency = this.loadNode(index);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'mesh':\r\n\t\t\t\t\t\tdependency = this._invokeOne(function (ext) {\r\n\r\n\t\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh(index);\r\n\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'accessor':\r\n\t\t\t\t\t\tdependency = this.loadAccessor(index);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'bufferView':\r\n\t\t\t\t\t\tdependency = this._invokeOne(function (ext) {\r\n\r\n\t\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView(index);\r\n\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'buffer':\r\n\t\t\t\t\t\tdependency = this.loadBuffer(index);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'material':\r\n\t\t\t\t\t\tdependency = this._invokeOne(function (ext) {\r\n\r\n\t\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial(index);\r\n\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'texture':\r\n\t\t\t\t\t\tdependency = this._invokeOne(function (ext) {\r\n\r\n\t\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture(index);\r\n\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'skin':\r\n\t\t\t\t\t\tdependency = this.loadSkin(index);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'animation':\r\n\t\t\t\t\t\tdependency = this.loadAnimation(index);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'camera':\r\n\t\t\t\t\t\tdependency = this.loadCamera(index);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error('Unknown type: ' + type);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.cache.add(cacheKey, dependency);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn dependency;\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Requests all dependencies of the specified type asynchronously, with caching.\r\n   * @param {string} type\r\n   * @return {Promise<Array<Object>>}\r\n   */\r\n\r\n\r\n\t\tgetDependencies(type) {\r\n\r\n\t\t\tlet dependencies = this.cache.get(type);\r\n\r\n\t\t\tif (!dependencies) {\r\n\r\n\t\t\t\tconst parser = this;\r\n\t\t\t\tconst defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\r\n\t\t\t\tdependencies = Promise.all(defs.map(function (def, index) {\r\n\r\n\t\t\t\t\treturn parser.getDependency(type, index);\r\n\r\n\t\t\t\t}));\r\n\t\t\t\tthis.cache.add(type, dependencies);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn dependencies;\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n   * @param {number} bufferIndex\r\n   * @return {Promise<ArrayBuffer>}\r\n   */\r\n\r\n\r\n\t\tloadBuffer(bufferIndex) {\r\n\r\n\t\t\tconst bufferDef = this.json.buffers[bufferIndex];\r\n\t\t\tconst loader = this.fileLoader;\r\n\r\n\t\t\tif (bufferDef.type && bufferDef.type !== 'arraybuffer') {\r\n\r\n\t\t\t\tthrow new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\r\n\r\n\t\t\t} // If present, GLB container is required to be the first buffer.\r\n\r\n\r\n\t\t\tif (bufferDef.uri === undefined && bufferIndex === 0) {\r\n\r\n\t\t\t\treturn Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst options = this.options;\r\n\t\t\treturn new Promise(function (resolve, reject) {\r\n\r\n\t\t\t\tloader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\r\n\r\n\t\t\t\t\treject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n   * @param {number} bufferViewIndex\r\n   * @return {Promise<ArrayBuffer>}\r\n   */\r\n\r\n\r\n\t\tloadBufferView(bufferViewIndex) {\r\n\r\n\t\t\tconst bufferViewDef = this.json.bufferViews[bufferViewIndex];\r\n\t\t\treturn this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\r\n\r\n\t\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\r\n\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\r\n\t\t\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\r\n   * @param {number} accessorIndex\r\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\r\n   */\r\n\r\n\r\n\t\tloadAccessor(accessorIndex) {\r\n\r\n\t\t\tconst parser = this;\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst accessorDef = this.json.accessors[accessorIndex];\r\n\r\n\t\t\tif (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\r\n\r\n\t\t\t\t// Ignore empty accessors, which may be used to declare runtime\r\n\t\t\t\t// information about attributes coming from another source (e.g. Draco\r\n\t\t\t\t// compression extension).\r\n\t\t\t\treturn Promise.resolve(null);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pendingBufferViews = [];\r\n\r\n\t\t\tif (accessorDef.bufferView !== undefined) {\r\n\r\n\t\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tpendingBufferViews.push(null);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (accessorDef.sparse !== undefined) {\r\n\r\n\t\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\r\n\t\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(pendingBufferViews).then(function (bufferViews) {\r\n\r\n\t\t\t\tconst bufferView = bufferViews[0];\r\n\t\t\t\tconst itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\r\n\t\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\r\n\r\n\t\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\r\n\t\t\t\tconst itemBytes = elementBytes * itemSize;\r\n\t\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\r\n\t\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\r\n\t\t\t\tconst normalized = accessorDef.normalized === true;\r\n\t\t\t\tlet array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\r\n\r\n\t\t\t\tif (byteStride && byteStride !== itemBytes) {\r\n\r\n\t\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own THREE.InterleavedBuffer\r\n\t\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\r\n\t\t\t\t\tconst ibSlice = Math.floor(byteOffset / byteStride);\r\n\t\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\r\n\t\t\t\t\tlet ib = parser.cache.get(ibCacheKey);\r\n\r\n\t\t\t\t\tif (!ib) {\r\n\r\n\t\t\t\t\t\tarray = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\r\n\r\n\t\t\t\t\t\tib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\r\n\t\t\t\t\t\tparser.cache.add(ibCacheKey, ib);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif (bufferView === null) {\r\n\r\n\t\t\t\t\t\tarray = new TypedArray(accessorDef.count * itemSize);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tarray = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\r\n\r\n\t\t\t\t} // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\r\n\r\n\r\n\t\t\t\tif (accessorDef.sparse !== undefined) {\r\n\r\n\t\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\r\n\t\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\r\n\t\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\r\n\t\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\r\n\t\t\t\t\tconst sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\r\n\t\t\t\t\tconst sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\r\n\r\n\t\t\t\t\tif (bufferView !== null) {\r\n\r\n\t\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\r\n\t\t\t\t\t\tbufferAttribute = new THREE.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (let i = 0, il = sparseIndices.length; i < il; i++) {\r\n\r\n\t\t\t\t\t\tconst index = sparseIndices[i];\r\n\t\t\t\t\t\tbufferAttribute.setX(index, sparseValues[i * itemSize]);\r\n\t\t\t\t\t\tif (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\r\n\t\t\t\t\t\tif (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\r\n\t\t\t\t\t\tif (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\r\n\t\t\t\t\t\tif (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.');\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn bufferAttribute;\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\r\n   * @param {number} textureIndex\r\n   * @return {Promise<THREE.Texture>}\r\n   */\r\n\r\n\r\n\t\tloadTexture(textureIndex) {\r\n\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst options = this.options;\r\n\t\t\tconst textureDef = json.textures[textureIndex];\r\n\t\t\tconst source = json.images[textureDef.source];\r\n\t\t\tlet loader = this.textureLoader;\r\n\r\n\t\t\tif (source.uri) {\r\n\r\n\t\t\t\tconst handler = options.manager.getHandler(source.uri);\r\n\t\t\t\tif (handler !== null) loader = handler;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.loadTextureImage(textureIndex, source, loader);\r\n\r\n\t\t}\r\n\r\n\t\tloadTextureImage(textureIndex, source, loader) {\r\n\r\n\t\t\tconst parser = this;\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst options = this.options;\r\n\t\t\tconst textureDef = json.textures[textureIndex];\r\n\t\t\tconst cacheKey = (source.uri || source.bufferView) + ':' + textureDef.sampler;\r\n\r\n\t\t\tif (this.textureCache[cacheKey]) {\r\n\r\n\t\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\r\n\t\t\t\treturn this.textureCache[cacheKey];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst URL = self.URL || self.webkitURL;\r\n\t\t\tlet sourceURI = source.uri || '';\r\n\t\t\tlet isObjectURL = false;\r\n\t\t\tlet hasAlpha = true;\r\n\t\t\tconst isJPEG = sourceURI.search(/\\.jpe?g($|\\?)/i) > 0 || sourceURI.search(/^data\\:image\\/jpeg/) === 0;\r\n\t\t\tif (source.mimeType === 'image/jpeg' || isJPEG) hasAlpha = false;\r\n\r\n\t\t\tif (source.bufferView !== undefined) {\r\n\r\n\t\t\t\t// Load binary image data from bufferView, if provided.\r\n\t\t\t\tsourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\r\n\r\n\t\t\t\t\tif (source.mimeType === 'image/png') {\r\n\r\n\t\t\t\t\t\t// Inspect the PNG 'IHDR' chunk to determine whether the image could have an\r\n\t\t\t\t\t\t// alpha channel. This check is conservative  the image could have an alpha\r\n\t\t\t\t\t\t// channel with all values == 1, and the indexed type (colorType == 3) only\r\n\t\t\t\t\t\t// sometimes contains alpha.\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\r\n\t\t\t\t\t\tconst colorType = new DataView(bufferView, 25, 1).getUint8(0, false);\r\n\t\t\t\t\t\thasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tisObjectURL = true;\r\n\t\t\t\t\tconst blob = new Blob([bufferView], {\r\n\t\t\t\t\t\ttype: source.mimeType\r\n\t\t\t\t\t});\r\n\t\t\t\t\tsourceURI = URL.createObjectURL(blob);\r\n\t\t\t\t\treturn sourceURI;\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t} else if (source.uri === undefined) {\r\n\r\n\t\t\t\tthrow new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView');\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst promise = Promise.resolve(sourceURI).then(function (sourceURI) {\r\n\r\n\t\t\t\treturn new Promise(function (resolve, reject) {\r\n\r\n\t\t\t\t\tlet onLoad = resolve;\r\n\r\n\t\t\t\t\tif (loader.isImageBitmapLoader === true) {\r\n\r\n\t\t\t\t\t\tonLoad = function (imageBitmap) {\r\n\r\n\t\t\t\t\t\t\tconst texture = new THREE.Texture(imageBitmap);\r\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\t\t\tresolve(texture);\r\n\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tloader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t}).then(function (texture) {\r\n\r\n\t\t\t\t// Clean up resources and configure THREE.Texture.\r\n\t\t\t\tif (isObjectURL === true) {\r\n\r\n\t\t\t\t\tURL.revokeObjectURL(sourceURI);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.flipY = false;\r\n\t\t\t\tif (textureDef.name) texture.name = textureDef.name; // When there is definitely no alpha channel in the texture, set THREE.RGBFormat to save space.\r\n\r\n\t\t\t\tif (!hasAlpha) texture.format = THREE.RGBFormat;\r\n\t\t\t\tconst samplers = json.samplers || {};\r\n\t\t\t\tconst sampler = samplers[textureDef.sampler] || {};\r\n\t\t\t\ttexture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\r\n\t\t\t\ttexture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipmapLinearFilter;\r\n\t\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\r\n\t\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\r\n\t\t\t\tparser.associations.set(texture, {\r\n\t\t\t\t\ttype: 'textures',\r\n\t\t\t\t\tindex: textureIndex\r\n\t\t\t\t});\r\n\t\t\t\treturn texture;\r\n\r\n\t\t\t}).catch(function () {\r\n\r\n\t\t\t\tconsole.error('THREE.GLTFLoader: Couldn\\'t load texture', sourceURI);\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t});\r\n\t\t\tthis.textureCache[cacheKey] = promise;\r\n\t\t\treturn promise;\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Asynchronously assigns a texture to the given material parameters.\r\n   * @param {Object} materialParams\r\n   * @param {string} mapName\r\n   * @param {Object} mapDef\r\n   * @return {Promise<Texture>}\r\n   */\r\n\r\n\r\n\t\tassignTexture(materialParams, mapName, mapDef) {\r\n\r\n\t\t\tconst parser = this;\r\n\t\t\treturn this.getDependency('texture', mapDef.index).then(function (texture) {\r\n\r\n\t\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\r\n\t\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\r\n\t\t\t\tif (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\r\n\r\n\t\t\t\t\tconsole.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\r\n\r\n\t\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\r\n\r\n\t\t\t\t\tif (transform) {\r\n\r\n\t\t\t\t\t\tconst gltfReference = parser.associations.get(texture);\r\n\t\t\t\t\t\ttexture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\r\n\t\t\t\t\t\tparser.associations.set(texture, gltfReference);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterialParams[mapName] = texture;\r\n\t\t\t\treturn texture;\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Assigns final material to a THREE.Mesh, THREE.Line, or THREE.Points instance. The instance\r\n   * already has a material (generated from the glTF material options alone)\r\n   * but reuse of the same glTF material may require multiple threejs materials\r\n   * to accommodate different primitive types, defines, etc. New materials will\r\n   * be created if necessary, and reused from a cache.\r\n   * @param  {Object3D} mesh THREE.Mesh, THREE.Line, or THREE.Points instance.\r\n   */\r\n\r\n\r\n\t\tassignFinalMaterial(mesh) {\r\n\r\n\t\t\tconst geometry = mesh.geometry;\r\n\t\t\tlet material = mesh.material;\r\n\t\t\tconst useVertexTangents = geometry.attributes.tangent !== undefined;\r\n\t\t\tconst useVertexColors = geometry.attributes.color !== undefined;\r\n\t\t\tconst useFlatShading = geometry.attributes.normal === undefined;\r\n\r\n\t\t\tif (mesh.isPoints) {\r\n\r\n\t\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\r\n\t\t\t\tlet pointsMaterial = this.cache.get(cacheKey);\r\n\r\n\t\t\t\tif (!pointsMaterial) {\r\n\r\n\t\t\t\t\tpointsMaterial = new THREE.PointsMaterial();\r\n\t\t\t\t\tTHREE.Material.prototype.copy.call(pointsMaterial, material);\r\n\t\t\t\t\tpointsMaterial.color.copy(material.color);\r\n\t\t\t\t\tpointsMaterial.map = material.map;\r\n\t\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\r\n\r\n\t\t\t\t\tthis.cache.add(cacheKey, pointsMaterial);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterial = pointsMaterial;\r\n\r\n\t\t\t} else if (mesh.isLine) {\r\n\r\n\t\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\r\n\t\t\t\tlet lineMaterial = this.cache.get(cacheKey);\r\n\r\n\t\t\t\tif (!lineMaterial) {\r\n\r\n\t\t\t\t\tlineMaterial = new THREE.LineBasicMaterial();\r\n\t\t\t\t\tTHREE.Material.prototype.copy.call(lineMaterial, material);\r\n\t\t\t\t\tlineMaterial.color.copy(material.color);\r\n\t\t\t\t\tthis.cache.add(cacheKey, lineMaterial);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterial = lineMaterial;\r\n\r\n\t\t\t} // Clone the material if it will be modified\r\n\r\n\r\n\t\t\tif (useVertexTangents || useVertexColors || useFlatShading) {\r\n\r\n\t\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\r\n\t\t\t\tif (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\r\n\t\t\t\tif (useVertexTangents) cacheKey += 'vertex-tangents:';\r\n\t\t\t\tif (useVertexColors) cacheKey += 'vertex-colors:';\r\n\t\t\t\tif (useFlatShading) cacheKey += 'flat-shading:';\r\n\t\t\t\tlet cachedMaterial = this.cache.get(cacheKey);\r\n\r\n\t\t\t\tif (!cachedMaterial) {\r\n\r\n\t\t\t\t\tcachedMaterial = material.clone();\r\n\t\t\t\t\tif (useVertexColors) cachedMaterial.vertexColors = true;\r\n\t\t\t\t\tif (useFlatShading) cachedMaterial.flatShading = true;\r\n\r\n\t\t\t\t\tif (useVertexTangents) {\r\n\r\n\t\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\t\t\t\t\t\tif (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= - 1;\r\n\t\t\t\t\t\tif (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= - 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.cache.add(cacheKey, cachedMaterial);\r\n\t\t\t\t\tthis.associations.set(cachedMaterial, this.associations.get(material));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterial = cachedMaterial;\r\n\r\n\t\t\t} // workarounds for mesh and geometry\r\n\r\n\r\n\t\t\tif (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\r\n\r\n\t\t\t\tgeometry.setAttribute('uv2', geometry.attributes.uv);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmesh.material = material;\r\n\r\n\t\t}\r\n\r\n\t\tgetMaterialType() {\r\n\r\n\t\t\treturn THREE.MeshStandardMaterial;\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\r\n   * @param {number} materialIndex\r\n   * @return {Promise<Material>}\r\n   */\r\n\r\n\r\n\t\tloadMaterial(materialIndex) {\r\n\r\n\t\t\tconst parser = this;\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst extensions = this.extensions;\r\n\t\t\tconst materialDef = json.materials[materialIndex];\r\n\t\t\tlet materialType;\r\n\t\t\tconst materialParams = {};\r\n\t\t\tconst materialExtensions = materialDef.extensions || {};\r\n\t\t\tconst pending = [];\r\n\r\n\t\t\tif (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\r\n\r\n\t\t\t\tconst sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\r\n\t\t\t\tmaterialType = sgExtension.getMaterialType();\r\n\t\t\t\tpending.push(sgExtension.extendParams(materialParams, materialDef, parser));\r\n\r\n\t\t\t} else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\r\n\r\n\t\t\t\tconst kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\r\n\t\t\t\tmaterialType = kmuExtension.getMaterialType();\r\n\t\t\t\tpending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Specification:\r\n\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\r\n\t\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\r\n\t\t\t\tmaterialParams.color = new THREE.Color(1.0, 1.0, 1.0);\r\n\t\t\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\t\t\tif (Array.isArray(metallicRoughness.baseColorFactor)) {\r\n\r\n\t\t\t\t\tconst array = metallicRoughness.baseColorFactor;\r\n\t\t\t\t\tmaterialParams.color.fromArray(array);\r\n\t\t\t\t\tmaterialParams.opacity = array[3];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (metallicRoughness.baseColorTexture !== undefined) {\r\n\r\n\t\t\t\t\tpending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\r\n\t\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\r\n\r\n\t\t\t\tif (metallicRoughness.metallicRoughnessTexture !== undefined) {\r\n\r\n\t\t\t\t\tpending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\r\n\t\t\t\t\tpending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterialType = this._invokeOne(function (ext) {\r\n\r\n\t\t\t\t\treturn ext.getMaterialType && ext.getMaterialType(materialIndex);\r\n\r\n\t\t\t\t});\r\n\t\t\t\tpending.push(Promise.all(this._invokeAll(function (ext) {\r\n\r\n\t\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\r\n\r\n\t\t\t\t})));\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (materialDef.doubleSided === true) {\r\n\r\n\t\t\t\tmaterialParams.side = THREE.DoubleSide;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\r\n\r\n\t\t\tif (alphaMode === ALPHA_MODES.BLEND) {\r\n\r\n\t\t\t\tmaterialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706\r\n\r\n\t\t\t\tmaterialParams.depthWrite = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterialParams.format = THREE.RGBFormat;\r\n\t\t\t\tmaterialParams.transparent = false;\r\n\r\n\t\t\t\tif (alphaMode === ALPHA_MODES.MASK) {\r\n\r\n\t\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture)); // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\r\n\t\t\t\tmaterialParams.normalScale = new THREE.Vector2(1, - 1);\r\n\r\n\t\t\t\tif (materialDef.normalTexture.scale !== undefined) {\r\n\r\n\t\t\t\t\tmaterialParams.normalScale.set(materialDef.normalTexture.scale, - materialDef.normalTexture.scale);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\r\n\r\n\t\t\t\tif (materialDef.occlusionTexture.strength !== undefined) {\r\n\r\n\t\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\r\n\r\n\t\t\t\tmaterialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\r\n\r\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(pending).then(function () {\r\n\r\n\t\t\t\tlet material;\r\n\r\n\t\t\t\tif (materialType === GLTFMeshStandardSGMaterial) {\r\n\r\n\t\t\t\t\tmaterial = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = new materialType(materialParams);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\r\n\r\n\t\t\t\tif (material.map) material.map.encoding = THREE.sRGBEncoding;\r\n\t\t\t\tif (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;\r\n\t\t\t\tassignExtrasToUserData(material, materialDef);\r\n\t\t\t\tparser.associations.set(material, {\r\n\t\t\t\t\ttype: 'materials',\r\n\t\t\t\t\tindex: materialIndex\r\n\t\t\t\t});\r\n\t\t\t\tif (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\r\n\t\t\t\treturn material;\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\t/** When THREE.Object3D instances are targeted by animation, they need unique names. */\r\n\r\n\r\n\t\tcreateUniqueName(originalName) {\r\n\r\n\t\t\tconst sanitizedName = THREE.PropertyBinding.sanitizeNodeName(originalName || '');\r\n\t\t\tlet name = sanitizedName;\r\n\r\n\t\t\tfor (let i = 1; this.nodeNamesUsed[name]; ++i) {\r\n\r\n\t\t\t\tname = sanitizedName + '_' + i;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.nodeNamesUsed[name] = true;\r\n\t\t\treturn name;\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\r\n   *\r\n   * Creates BufferGeometries from primitives.\r\n   *\r\n   * @param {Array<GLTF.Primitive>} primitives\r\n   * @return {Promise<Array<BufferGeometry>>}\r\n   */\r\n\r\n\r\n\t\tloadGeometries(primitives) {\r\n\r\n\t\t\tconst parser = this;\r\n\t\t\tconst extensions = this.extensions;\r\n\t\t\tconst cache = this.primitiveCache;\r\n\r\n\t\t\tfunction createDracoPrimitive(primitive) {\r\n\r\n\t\t\t\treturn extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\r\n\r\n\t\t\t\t\treturn addPrimitiveAttributes(geometry, primitive, parser);\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pending = [];\r\n\r\n\t\t\tfor (let i = 0, il = primitives.length; i < il; i++) {\r\n\r\n\t\t\t\tconst primitive = primitives[i];\r\n\t\t\t\tconst cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\r\n\r\n\t\t\t\tconst cached = cache[cacheKey];\r\n\r\n\t\t\t\tif (cached) {\r\n\r\n\t\t\t\t\t// Use the cached geometry if it exists\r\n\t\t\t\t\tpending.push(cached.promise);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tlet geometryPromise;\r\n\r\n\t\t\t\t\tif (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\r\n\r\n\t\t\t\t\t\t// Use DRACO geometry if available\r\n\t\t\t\t\t\tgeometryPromise = createDracoPrimitive(primitive);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// Otherwise create a new geometry\r\n\t\t\t\t\t\tgeometryPromise = addPrimitiveAttributes(new THREE.BufferGeometry(), primitive, parser);\r\n\r\n\t\t\t\t\t} // Cache this geometry\r\n\r\n\r\n\t\t\t\t\tcache[cacheKey] = {\r\n\t\t\t\t\t\tprimitive: primitive,\r\n\t\t\t\t\t\tpromise: geometryPromise\r\n\t\t\t\t\t};\r\n\t\t\t\t\tpending.push(geometryPromise);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(pending);\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\r\n   * @param {number} meshIndex\r\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\r\n   */\r\n\r\n\r\n\t\tloadMesh(meshIndex) {\r\n\r\n\t\t\tconst parser = this;\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst extensions = this.extensions;\r\n\t\t\tconst meshDef = json.meshes[meshIndex];\r\n\t\t\tconst primitives = meshDef.primitives;\r\n\t\t\tconst pending = [];\r\n\r\n\t\t\tfor (let i = 0, il = primitives.length; i < il; i++) {\r\n\r\n\t\t\t\tconst material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\r\n\t\t\t\tpending.push(material);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tpending.push(parser.loadGeometries(primitives));\r\n\t\t\treturn Promise.all(pending).then(function (results) {\r\n\r\n\t\t\t\tconst materials = results.slice(0, results.length - 1);\r\n\t\t\t\tconst geometries = results[results.length - 1];\r\n\t\t\t\tconst meshes = [];\r\n\r\n\t\t\t\tfor (let i = 0, il = geometries.length; i < il; i++) {\r\n\r\n\t\t\t\t\tconst geometry = geometries[i];\r\n\t\t\t\t\tconst primitive = primitives[i]; // 1. create THREE.Mesh\r\n\r\n\t\t\t\t\tlet mesh;\r\n\t\t\t\t\tconst material = materials[i];\r\n\r\n\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\r\n\r\n\t\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\r\n\t\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh(geometry, material) : new THREE.Mesh(geometry, material);\r\n\r\n\t\t\t\t\t\tif (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\r\n\r\n\t\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\r\n\t\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\r\n\t\t\t\t\t\t\tmesh.normalizeSkinWeights();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\r\n\r\n\t\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE.TriangleStripDrawMode);\r\n\r\n\t\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\r\n\r\n\t\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE.TriangleFanDrawMode);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\r\n\r\n\t\t\t\t\t\tmesh = new THREE.LineSegments(geometry, material);\r\n\r\n\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\r\n\r\n\t\t\t\t\t\tmesh = new THREE.Line(geometry, material);\r\n\r\n\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\r\n\r\n\t\t\t\t\t\tmesh = new THREE.LineLoop(geometry, material);\r\n\r\n\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\r\n\r\n\t\t\t\t\t\tmesh = new THREE.Points(geometry, material);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthrow new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (Object.keys(mesh.geometry.morphAttributes).length > 0) {\r\n\r\n\t\t\t\t\t\tupdateMorphTargets(mesh, meshDef);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);\r\n\t\t\t\t\tassignExtrasToUserData(mesh, meshDef);\r\n\t\t\t\t\tif (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\r\n\t\t\t\t\tparser.assignFinalMaterial(mesh);\r\n\t\t\t\t\tmeshes.push(mesh);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (meshes.length === 1) {\r\n\r\n\t\t\t\t\treturn meshes[0];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst group = new THREE.Group();\r\n\r\n\t\t\t\tfor (let i = 0, il = meshes.length; i < il; i++) {\r\n\r\n\t\t\t\t\tgroup.add(meshes[i]);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn group;\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\r\n   * @param {number} cameraIndex\r\n   * @return {Promise<THREE.Camera>}\r\n   */\r\n\r\n\r\n\t\tloadCamera(cameraIndex) {\r\n\r\n\t\t\tlet camera;\r\n\t\t\tconst cameraDef = this.json.cameras[cameraIndex];\r\n\t\t\tconst params = cameraDef[cameraDef.type];\r\n\r\n\t\t\tif (!params) {\r\n\r\n\t\t\t\tconsole.warn('THREE.GLTFLoader: Missing camera parameters.');\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (cameraDef.type === 'perspective') {\r\n\r\n\t\t\t\tcamera = new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\r\n\r\n\t\t\t} else if (cameraDef.type === 'orthographic') {\r\n\r\n\t\t\t\tcamera = new THREE.OrthographicCamera(- params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\r\n\t\t\tassignExtrasToUserData(camera, cameraDef);\r\n\t\t\treturn Promise.resolve(camera);\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\r\n   * @param {number} skinIndex\r\n   * @return {Promise<Object>}\r\n   */\r\n\r\n\r\n\t\tloadSkin(skinIndex) {\r\n\r\n\t\t\tconst skinDef = this.json.skins[skinIndex];\r\n\t\t\tconst skinEntry = {\r\n\t\t\t\tjoints: skinDef.joints\r\n\t\t\t};\r\n\r\n\t\t\tif (skinDef.inverseBindMatrices === undefined) {\r\n\r\n\t\t\t\treturn Promise.resolve(skinEntry);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\r\n\r\n\t\t\t\tskinEntry.inverseBindMatrices = accessor;\r\n\t\t\t\treturn skinEntry;\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n   * @param {number} animationIndex\r\n   * @return {Promise<AnimationClip>}\r\n   */\r\n\r\n\r\n\t\tloadAnimation(animationIndex) {\r\n\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst animationDef = json.animations[animationIndex];\r\n\t\t\tconst pendingNodes = [];\r\n\t\t\tconst pendingInputAccessors = [];\r\n\t\t\tconst pendingOutputAccessors = [];\r\n\t\t\tconst pendingSamplers = [];\r\n\t\t\tconst pendingTargets = [];\r\n\r\n\t\t\tfor (let i = 0, il = animationDef.channels.length; i < il; i++) {\r\n\r\n\t\t\t\tconst channel = animationDef.channels[i];\r\n\t\t\t\tconst sampler = animationDef.samplers[channel.sampler];\r\n\t\t\t\tconst target = channel.target;\r\n\t\t\t\tconst name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\r\n\r\n\t\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\r\n\t\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\r\n\t\t\t\tpendingNodes.push(this.getDependency('node', name));\r\n\t\t\t\tpendingInputAccessors.push(this.getDependency('accessor', input));\r\n\t\t\t\tpendingOutputAccessors.push(this.getDependency('accessor', output));\r\n\t\t\t\tpendingSamplers.push(sampler);\r\n\t\t\t\tpendingTargets.push(target);\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\r\n\r\n\t\t\t\tconst nodes = dependencies[0];\r\n\t\t\t\tconst inputAccessors = dependencies[1];\r\n\t\t\t\tconst outputAccessors = dependencies[2];\r\n\t\t\t\tconst samplers = dependencies[3];\r\n\t\t\t\tconst targets = dependencies[4];\r\n\t\t\t\tconst tracks = [];\r\n\r\n\t\t\t\tfor (let i = 0, il = nodes.length; i < il; i++) {\r\n\r\n\t\t\t\t\tconst node = nodes[i];\r\n\t\t\t\t\tconst inputAccessor = inputAccessors[i];\r\n\t\t\t\t\tconst outputAccessor = outputAccessors[i];\r\n\t\t\t\t\tconst sampler = samplers[i];\r\n\t\t\t\t\tconst target = targets[i];\r\n\t\t\t\t\tif (node === undefined) continue;\r\n\t\t\t\t\tnode.updateMatrix();\r\n\t\t\t\t\tnode.matrixAutoUpdate = true;\r\n\t\t\t\t\tlet TypedKeyframeTrack;\r\n\r\n\t\t\t\t\tswitch (PATH_PROPERTIES[target.path]) {\r\n\r\n\t\t\t\t\t\tcase PATH_PROPERTIES.weights:\r\n\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.NumberKeyframeTrack;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase PATH_PROPERTIES.rotation:\r\n\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase PATH_PROPERTIES.position:\r\n\t\t\t\t\t\tcase PATH_PROPERTIES.scale:\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.VectorKeyframeTrack;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst targetName = node.name ? node.name : node.uuid;\r\n\t\t\t\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\r\n\t\t\t\t\tconst targetNames = [];\r\n\r\n\t\t\t\t\tif (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\r\n\r\n\t\t\t\t\t\t// Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.\r\n\t\t\t\t\t\tnode.traverse(function (object) {\r\n\r\n\t\t\t\t\t\t\tif (object.isMesh === true && object.morphTargetInfluences) {\r\n\r\n\t\t\t\t\t\t\t\ttargetNames.push(object.name ? object.name : object.uuid);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttargetNames.push(targetName);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet outputArray = outputAccessor.array;\r\n\r\n\t\t\t\t\tif (outputAccessor.normalized) {\r\n\r\n\t\t\t\t\t\tconst scale = getNormalizedComponentScale(outputArray.constructor);\r\n\t\t\t\t\t\tconst scaled = new Float32Array(outputArray.length);\r\n\r\n\t\t\t\t\t\tfor (let j = 0, jl = outputArray.length; j < jl; j++) {\r\n\r\n\t\t\t\t\t\t\tscaled[j] = outputArray[j] * scale;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\toutputArray = scaled;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (let j = 0, jl = targetNames.length; j < jl; j++) {\r\n\r\n\t\t\t\t\t\tconst track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\r\n\r\n\t\t\t\t\t\tif (sampler.interpolation === 'CUBICSPLINE') {\r\n\r\n\t\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\r\n\r\n\t\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\r\n\t\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\r\n\t\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\r\n\t\t\t\t\t\t\t\tconst interpolantType = this instanceof THREE.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\r\n\t\t\t\t\t\t\t\treturn new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\r\n\r\n\t\t\t\t\t\t\t}; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\r\n\r\n\r\n\t\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttracks.push(track);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\r\n\t\t\t\treturn new THREE.AnimationClip(name, undefined, tracks);\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tcreateNodeMesh(nodeIndex) {\r\n\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst parser = this;\r\n\t\t\tconst nodeDef = json.nodes[nodeIndex];\r\n\t\t\tif (nodeDef.mesh === undefined) return null;\r\n\t\t\treturn parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\r\n\r\n\t\t\t\tconst node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh); // if weights are provided on the node, override weights on the mesh.\r\n\r\n\r\n\t\t\t\tif (nodeDef.weights !== undefined) {\r\n\r\n\t\t\t\t\tnode.traverse(function (o) {\r\n\r\n\t\t\t\t\t\tif (!o.isMesh) return;\r\n\r\n\t\t\t\t\t\tfor (let i = 0, il = nodeDef.weights.length; i < il; i++) {\r\n\r\n\t\t\t\t\t\t\to.morphTargetInfluences[i] = nodeDef.weights[i];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn node;\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\r\n   * @param {number} nodeIndex\r\n   * @return {Promise<Object3D>}\r\n   */\r\n\r\n\r\n\t\tloadNode(nodeIndex) {\r\n\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst extensions = this.extensions;\r\n\t\t\tconst parser = this;\r\n\t\t\tconst nodeDef = json.nodes[nodeIndex]; // reserve node's name before its dependencies, so the root has the intended name.\r\n\r\n\t\t\tconst nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';\r\n\t\t\treturn function () {\r\n\r\n\t\t\t\tconst pending = [];\r\n\r\n\t\t\t\tconst meshPromise = parser._invokeOne(function (ext) {\r\n\r\n\t\t\t\t\treturn ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (meshPromise) {\r\n\r\n\t\t\t\t\tpending.push(meshPromise);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (nodeDef.camera !== undefined) {\r\n\r\n\t\t\t\t\tpending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {\r\n\r\n\t\t\t\t\t\treturn parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\r\n\r\n\t\t\t\t\t}));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparser._invokeAll(function (ext) {\r\n\r\n\t\t\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\r\n\r\n\t\t\t\t}).forEach(function (promise) {\r\n\r\n\t\t\t\t\tpending.push(promise);\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn Promise.all(pending);\r\n\r\n\t\t\t}().then(function (objects) {\r\n\r\n\t\t\t\tlet node; // .isBone isn't in glTF spec. See ._markDefs\r\n\r\n\t\t\t\tif (nodeDef.isBone === true) {\r\n\r\n\t\t\t\t\tnode = new THREE.Bone();\r\n\r\n\t\t\t\t} else if (objects.length > 1) {\r\n\r\n\t\t\t\t\tnode = new THREE.Group();\r\n\r\n\t\t\t\t} else if (objects.length === 1) {\r\n\r\n\t\t\t\t\tnode = objects[0];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnode = new THREE.Object3D();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (node !== objects[0]) {\r\n\r\n\t\t\t\t\tfor (let i = 0, il = objects.length; i < il; i++) {\r\n\r\n\t\t\t\t\t\tnode.add(objects[i]);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (nodeDef.name) {\r\n\r\n\t\t\t\t\tnode.userData.name = nodeDef.name;\r\n\t\t\t\t\tnode.name = nodeName;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tassignExtrasToUserData(node, nodeDef);\r\n\t\t\t\tif (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\r\n\r\n\t\t\t\tif (nodeDef.matrix !== undefined) {\r\n\r\n\t\t\t\t\tconst matrix = new THREE.Matrix4();\r\n\t\t\t\t\tmatrix.fromArray(nodeDef.matrix);\r\n\t\t\t\t\tnode.applyMatrix4(matrix);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif (nodeDef.translation !== undefined) {\r\n\r\n\t\t\t\t\t\tnode.position.fromArray(nodeDef.translation);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (nodeDef.rotation !== undefined) {\r\n\r\n\t\t\t\t\t\tnode.quaternion.fromArray(nodeDef.rotation);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (nodeDef.scale !== undefined) {\r\n\r\n\t\t\t\t\t\tnode.scale.fromArray(nodeDef.scale);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparser.associations.set(node, {\r\n\t\t\t\t\ttype: 'nodes',\r\n\t\t\t\t\tindex: nodeIndex\r\n\t\t\t\t});\r\n\t\t\t\treturn node;\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\t/**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\r\n   * @param {number} sceneIndex\r\n   * @return {Promise<Group>}\r\n   */\r\n\r\n\r\n\t\tloadScene(sceneIndex) {\r\n\r\n\t\t\tconst json = this.json;\r\n\t\t\tconst extensions = this.extensions;\r\n\t\t\tconst sceneDef = this.json.scenes[sceneIndex];\r\n\t\t\tconst parser = this; // THREE.Loader returns THREE.Group, not Scene.\r\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\r\n\r\n\t\t\tconst scene = new THREE.Group();\r\n\t\t\tif (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\r\n\t\t\tassignExtrasToUserData(scene, sceneDef);\r\n\t\t\tif (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\r\n\t\t\tconst nodeIds = sceneDef.nodes || [];\r\n\t\t\tconst pending = [];\r\n\r\n\t\t\tfor (let i = 0, il = nodeIds.length; i < il; i++) {\r\n\r\n\t\t\t\tpending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(pending).then(function () {\r\n\r\n\t\t\t\treturn scene;\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction buildNodeHierachy(nodeId, parentObject, json, parser) {\r\n\r\n\t\tconst nodeDef = json.nodes[nodeId];\r\n\t\treturn parser.getDependency('node', nodeId).then(function (node) {\r\n\r\n\t\t\tif (nodeDef.skin === undefined) return node; // build skeleton here as well\r\n\r\n\t\t\tlet skinEntry;\r\n\t\t\treturn parser.getDependency('skin', nodeDef.skin).then(function (skin) {\r\n\r\n\t\t\t\tskinEntry = skin;\r\n\t\t\t\tconst pendingJoints = [];\r\n\r\n\t\t\t\tfor (let i = 0, il = skinEntry.joints.length; i < il; i++) {\r\n\r\n\t\t\t\t\tpendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Promise.all(pendingJoints);\r\n\r\n\t\t\t}).then(function (jointNodes) {\r\n\r\n\t\t\t\tnode.traverse(function (mesh) {\r\n\r\n\t\t\t\t\tif (!mesh.isMesh) return;\r\n\t\t\t\t\tconst bones = [];\r\n\t\t\t\t\tconst boneInverses = [];\r\n\r\n\t\t\t\t\tfor (let j = 0, jl = jointNodes.length; j < jl; j++) {\r\n\r\n\t\t\t\t\t\tconst jointNode = jointNodes[j];\r\n\r\n\t\t\t\t\t\tif (jointNode) {\r\n\r\n\t\t\t\t\t\t\tbones.push(jointNode);\r\n\t\t\t\t\t\t\tconst mat = new THREE.Matrix4();\r\n\r\n\t\t\t\t\t\t\tif (skinEntry.inverseBindMatrices !== undefined) {\r\n\r\n\t\t\t\t\t\t\t\tmat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tboneInverses.push(mat);\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tconsole.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\r\n\r\n\t\t\t\t});\r\n\t\t\t\treturn node;\r\n\r\n\t\t\t});\r\n\r\n\t\t}).then(function (node) {\r\n\r\n\t\t\t// build node hierachy\r\n\t\t\tparentObject.add(node);\r\n\t\t\tconst pending = [];\r\n\r\n\t\t\tif (nodeDef.children) {\r\n\r\n\t\t\t\tconst children = nodeDef.children;\r\n\r\n\t\t\t\tfor (let i = 0, il = children.length; i < il; i++) {\r\n\r\n\t\t\t\t\tconst child = children[i];\r\n\t\t\t\t\tpending.push(buildNodeHierachy(child, node, json, parser));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(pending);\r\n\r\n\t\t});\r\n\r\n\t}\r\n\t/**\r\n * @param {BufferGeometry} geometry\r\n * @param {GLTF.Primitive} primitiveDef\r\n * @param {GLTFParser} parser\r\n */\r\n\r\n\r\n\tfunction computeBounds(geometry, primitiveDef, parser) {\r\n\r\n\t\tconst attributes = primitiveDef.attributes;\r\n\t\tconst box = new THREE.Box3();\r\n\r\n\t\tif (attributes.POSITION !== undefined) {\r\n\r\n\t\t\tconst accessor = parser.json.accessors[attributes.POSITION];\r\n\t\t\tconst min = accessor.min;\r\n\t\t\tconst max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n\t\t\tif (min !== undefined && max !== undefined) {\r\n\r\n\t\t\t\tbox.set(new THREE.Vector3(min[0], min[1], min[2]), new THREE.Vector3(max[0], max[1], max[2]));\r\n\r\n\t\t\t\tif (accessor.normalized) {\r\n\r\n\t\t\t\t\tconst boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\r\n\t\t\t\t\tbox.min.multiplyScalar(boxScale);\r\n\t\t\t\t\tbox.max.multiplyScalar(boxScale);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst targets = primitiveDef.targets;\r\n\r\n\t\tif (targets !== undefined) {\r\n\r\n\t\t\tconst maxDisplacement = new THREE.Vector3();\r\n\t\t\tconst vector = new THREE.Vector3();\r\n\r\n\t\t\tfor (let i = 0, il = targets.length; i < il; i++) {\r\n\r\n\t\t\t\tconst target = targets[i];\r\n\r\n\t\t\t\tif (target.POSITION !== undefined) {\r\n\r\n\t\t\t\t\tconst accessor = parser.json.accessors[target.POSITION];\r\n\t\t\t\t\tconst min = accessor.min;\r\n\t\t\t\t\tconst max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n\t\t\t\t\tif (min !== undefined && max !== undefined) {\r\n\r\n\t\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\r\n\t\t\t\t\t\tvector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\r\n\t\t\t\t\t\tvector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\r\n\t\t\t\t\t\tvector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\r\n\r\n\t\t\t\t\t\tif (accessor.normalized) {\r\n\r\n\t\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\r\n\t\t\t\t\t\t\tvector.multiplyScalar(boxScale);\r\n\r\n\t\t\t\t\t\t} // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\r\n\t\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\r\n\t\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\r\n\t\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\r\n\r\n\r\n\t\t\t\t\t\tmaxDisplacement.max(vector);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\r\n\r\n\r\n\t\t\tbox.expandByVector(maxDisplacement);\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.boundingBox = box;\r\n\t\tconst sphere = new THREE.Sphere();\r\n\t\tbox.getCenter(sphere.center);\r\n\t\tsphere.radius = box.min.distanceTo(box.max) / 2;\r\n\t\tgeometry.boundingSphere = sphere;\r\n\r\n\t}\r\n\t/**\r\n * @param {BufferGeometry} geometry\r\n * @param {GLTF.Primitive} primitiveDef\r\n * @param {GLTFParser} parser\r\n * @return {Promise<BufferGeometry>}\r\n */\r\n\r\n\r\n\tfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\r\n\r\n\t\tconst attributes = primitiveDef.attributes;\r\n\t\tconst pending = [];\r\n\r\n\t\tfunction assignAttributeAccessor(accessorIndex, attributeName) {\r\n\r\n\t\t\treturn parser.getDependency('accessor', accessorIndex).then(function (accessor) {\r\n\r\n\t\t\t\tgeometry.setAttribute(attributeName, accessor);\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tfor (const gltfAttributeName in attributes) {\r\n\r\n\t\t\tconst threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\r\n\r\n\t\t\tif (threeAttributeName in geometry.attributes) continue;\r\n\t\t\tpending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\r\n\r\n\t\t}\r\n\r\n\t\tif (primitiveDef.indices !== undefined && !geometry.index) {\r\n\r\n\t\t\tconst accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\r\n\r\n\t\t\t\tgeometry.setIndex(accessor);\r\n\r\n\t\t\t});\r\n\t\t\tpending.push(accessor);\r\n\r\n\t\t}\r\n\r\n\t\tassignExtrasToUserData(geometry, primitiveDef);\r\n\t\tcomputeBounds(geometry, primitiveDef, parser);\r\n\t\treturn Promise.all(pending).then(function () {\r\n\r\n\t\t\treturn primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\r\n\r\n\t\t});\r\n\r\n\t}\r\n\t/**\r\n * @param {BufferGeometry} geometry\r\n * @param {Number} drawMode\r\n * @return {BufferGeometry}\r\n */\r\n\r\n\r\n\tfunction toTrianglesDrawMode(geometry, drawMode) {\r\n\r\n\t\tlet index = geometry.getIndex(); // generate index if not present\r\n\r\n\t\tif (index === null) {\r\n\r\n\t\t\tconst indices = [];\r\n\t\t\tconst position = geometry.getAttribute('position');\r\n\r\n\t\t\tif (position !== undefined) {\r\n\r\n\t\t\t\tfor (let i = 0; i < position.count; i++) {\r\n\r\n\t\t\t\t\tindices.push(i);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.setIndex(indices);\r\n\t\t\t\tindex = geometry.getIndex();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\r\n\t\t\t\treturn geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t} //\r\n\r\n\r\n\t\tconst numberOfTriangles = index.count - 2;\r\n\t\tconst newIndices = [];\r\n\r\n\t\tif (drawMode === THREE.TriangleFanDrawMode) {\r\n\r\n\t\t\t// gl.TRIANGLE_FAN\r\n\t\t\tfor (let i = 1; i <= numberOfTriangles; i++) {\r\n\r\n\t\t\t\tnewIndices.push(index.getX(0));\r\n\t\t\t\tnewIndices.push(index.getX(i));\r\n\t\t\t\tnewIndices.push(index.getX(i + 1));\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// gl.TRIANGLE_STRIP\r\n\t\t\tfor (let i = 0; i < numberOfTriangles; i++) {\r\n\r\n\t\t\t\tif (i % 2 === 0) {\r\n\r\n\t\t\t\t\tnewIndices.push(index.getX(i));\r\n\t\t\t\t\tnewIndices.push(index.getX(i + 1));\r\n\t\t\t\t\tnewIndices.push(index.getX(i + 2));\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnewIndices.push(index.getX(i + 2));\r\n\t\t\t\t\tnewIndices.push(index.getX(i + 1));\r\n\t\t\t\t\tnewIndices.push(index.getX(i));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif (newIndices.length / 3 !== numberOfTriangles) {\r\n\r\n\t\t\tconsole.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\r\n\r\n\t\t} // build final geometry\r\n\r\n\r\n\t\tconst newGeometry = geometry.clone();\r\n\t\tnewGeometry.setIndex(newIndices);\r\n\t\treturn newGeometry;\r\n\r\n\t}\r\n\r\n\tTHREE.GLTFLoader = GLTFLoader;\r\n\r\n})();\r\n\r\nmodule.exports = exports = THREE.GLTFLoader;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
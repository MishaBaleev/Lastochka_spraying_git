{"ast":null,"code":"const THREE = require(\"../three.js\");\nconst utils = require(\"../utils/utils.js\");\nconst Objects = require('./objects.js');\nfunction line(obj) {\n  obj = utils._validate(obj, Objects.prototype._defaults.line);\n\n  // Geometry\n  var straightProject = utils.lnglatsToWorld(obj.geometry);\n  var normalized = utils.normalizeVertices(straightProject);\n  var flattenedArray = utils.flattenVectors(normalized.vertices);\n  //console.log('line', normalized.vertices)\n\n  var geometry = new THREE.LineGeometry();\n  geometry.setPositions(flattenedArray);\n\n  // Material\n  let matLine = new THREE.LineMaterial({\n    color: obj.color,\n    linewidth: obj.width,\n    // in pixels\n    dashed: false,\n    opacity: obj.opacity\n  });\n  matLine.resolution.set(window.innerWidth, window.innerHeight);\n  matLine.isMaterial = true;\n  matLine.transparent = true;\n  matLine.depthWrite = false;\n\n  // Mesh\n  line = new THREE.Line2(geometry, matLine);\n  line.position.copy(normalized.position);\n  line.computeLineDistances();\n  return line;\n}\nmodule.exports = exports = line;\n\n/**\r\n * custom line shader by WestLangley, sourced from https://github.com/mrdoob/three.js/tree/master/examples/js/lines\r\n *\r\n */\n\n(function () {\n  const _box = new THREE.Box3();\n  const _vector = new THREE.Vector3();\n  class LineSegmentsGeometry extends THREE.InstancedBufferGeometry {\n    constructor() {\n      super();\n      this.type = 'LineSegmentsGeometry';\n      const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n      const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n      const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n      this.setIndex(index);\n      this.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n      this.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n    }\n    applyMatrix4(matrix) {\n      const start = this.attributes.instanceStart;\n      const end = this.attributes.instanceEnd;\n      if (start !== undefined) {\n        start.applyMatrix4(matrix);\n        end.applyMatrix4(matrix);\n        start.needsUpdate = true;\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      return this;\n    }\n    setPositions(array) {\n      let lineSegments;\n      if (array instanceof Float32Array) {\n        lineSegments = array;\n      } else if (Array.isArray(array)) {\n        lineSegments = new Float32Array(array);\n      }\n      const instanceBuffer = new THREE.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n      this.setAttribute('instanceStart', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n      this.setAttribute('instanceEnd', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n      //\n\n      this.computeBoundingBox();\n      this.computeBoundingSphere();\n      return this;\n    }\n    setColors(array) {\n      let colors;\n      if (array instanceof Float32Array) {\n        colors = array;\n      } else if (Array.isArray(array)) {\n        colors = new Float32Array(array);\n      }\n      const instanceColorBuffer = new THREE.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n      this.setAttribute('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n      this.setAttribute('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n      return this;\n    }\n    fromWireframeGeometry(geometry) {\n      this.setPositions(geometry.attributes.position.array);\n      return this;\n    }\n    fromEdgesGeometry(geometry) {\n      this.setPositions(geometry.attributes.position.array);\n      return this;\n    }\n    fromMesh(mesh) {\n      this.fromWireframeGeometry(new THREE.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n      return this;\n    }\n    fromLineSegments(lineSegments) {\n      const geometry = lineSegments.geometry;\n      if (geometry.isGeometry) {\n        console.error('THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n        return;\n      } else if (geometry.isBufferGeometry) {\n        this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n      } // set colors, maybe\n\n      return this;\n    }\n    computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new THREE.Box3();\n      }\n      const start = this.attributes.instanceStart;\n      const end = this.attributes.instanceEnd;\n      if (start !== undefined && end !== undefined) {\n        this.boundingBox.setFromBufferAttribute(start);\n        _box.setFromBufferAttribute(end);\n        this.boundingBox.union(_box);\n      }\n    }\n    computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new THREE.Sphere();\n      }\n      if (this.boundingBox === null) {\n        this.computeBoundingBox();\n      }\n      const start = this.attributes.instanceStart;\n      const end = this.attributes.instanceEnd;\n      if (start !== undefined && end !== undefined) {\n        const center = this.boundingSphere.center;\n        this.boundingBox.getCenter(center);\n        let maxRadiusSq = 0;\n        for (let i = 0, il = start.count; i < il; i++) {\n          _vector.fromBufferAttribute(start, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n          _vector.fromBufferAttribute(end, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        }\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n        }\n      }\n    }\n    toJSON() {// todo\n    }\n    applyMatrix(matrix) {\n      console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n      return this.applyMatrix4(matrix);\n    }\n  }\n  LineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n  THREE.LineSegmentsGeometry = LineSegmentsGeometry;\n})();\n\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n */\n\n(function () {\n  class LineGeometry extends THREE.LineSegmentsGeometry {\n    constructor() {\n      super();\n      this.type = 'LineGeometry';\n    }\n    setPositions(array) {\n      // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n      var length = array.length - 3;\n      var points = new Float32Array(2 * length);\n      for (var i = 0; i < length; i += 3) {\n        points[2 * i] = array[i];\n        points[2 * i + 1] = array[i + 1];\n        points[2 * i + 2] = array[i + 2];\n        points[2 * i + 3] = array[i + 3];\n        points[2 * i + 4] = array[i + 4];\n        points[2 * i + 5] = array[i + 5];\n      }\n      super.setPositions(points);\n      return this;\n    }\n    setColors(array) {\n      // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n      var length = array.length - 3;\n      var colors = new Float32Array(2 * length);\n      for (var i = 0; i < length; i += 3) {\n        colors[2 * i] = array[i];\n        colors[2 * i + 1] = array[i + 1];\n        colors[2 * i + 2] = array[i + 2];\n        colors[2 * i + 3] = array[i + 3];\n        colors[2 * i + 4] = array[i + 4];\n        colors[2 * i + 5] = array[i + 5];\n      }\n      super.setColors(colors);\n      return this;\n    }\n    fromLine(line) {\n      var geometry = line.geometry;\n      if (geometry.isGeometry) {\n        console.error('THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n        return;\n      } else if (geometry.isBufferGeometry) {\n        this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n      } // set colors, maybe\n\n      return this;\n    }\n  }\n  LineGeometry.prototype.isLineGeometry = true;\n  THREE.LineGeometry = LineGeometry;\n})();\n\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n */\n\n(function () {\n  class WireframeGeometry2 extends THREE.LineSegmentsGeometry {\n    constructor(geometry) {\n      super();\n      this.type = 'WireframeGeometry2';\n      this.fromWireframeGeometry(new THREE.WireframeGeometry(geometry)); // set colors, maybe\n    }\n  }\n  WireframeGeometry2.prototype.isWireframeGeometry2 = true;\n  THREE.WireframeGeometry2 = WireframeGeometry2;\n})();\n\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  linewidth: <float>,\r\n *  dashed: <boolean>,\r\n *  dashScale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *  resolution: <Vector2>, // to be set by renderer\r\n * }\r\n */\n\n(function () {\n  /**\r\n  * parameters = {\r\n  *  color: <hex>,\r\n  *  linewidth: <float>,\r\n  *  dashed: <boolean>,\r\n  *  dashScale: <float>,\r\n  *  dashSize: <float>,\r\n  *  gapSize: <float>,\r\n  *  resolution: <Vector2>, // to be set by renderer\r\n  * }\r\n  */\n  THREE.UniformsLib.line = {\n    worldUnits: {\n      value: 1\n    },\n    linewidth: {\n      value: 1\n    },\n    resolution: {\n      value: new THREE.Vector2(1, 1)\n    },\n    dashScale: {\n      value: 1\n    },\n    dashSize: {\n      value: 1\n    },\n    gapSize: {\n      value: 1\n    } // todo FIX - maybe change to totalSize\n  };\n  THREE.ShaderLib['line'] = {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.line]),\n    vertexShader: /* glsl */\n    `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\tworldStart = start.xyz;\n\t\t\tworldEnd = end.xyz;\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segements overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n    fragmentShader: /* glsl */\n    `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n  };\n  class LineMaterial extends THREE.ShaderMaterial {\n    constructor(parameters) {\n      super({\n        type: 'LineMaterial',\n        uniforms: THREE.UniformsUtils.clone(THREE.ShaderLib['line'].uniforms),\n        vertexShader: THREE.ShaderLib['line'].vertexShader,\n        fragmentShader: THREE.ShaderLib['line'].fragmentShader,\n        clipping: true // required for clipping support\n      });\n      Object.defineProperties(this, {\n        color: {\n          enumerable: true,\n          get: function () {\n            return this.uniforms.diffuse.value;\n          },\n          set: function (value) {\n            this.uniforms.diffuse.value = value;\n          }\n        },\n        worldUnits: {\n          enumerable: true,\n          get: function () {\n            return 'WORLD_UNITS' in this.defines;\n          },\n          set: function (value) {\n            if (value === true) {\n              this.defines.WORLD_UNITS = '';\n            } else {\n              delete this.defines.WORLD_UNITS;\n            }\n          }\n        },\n        linewidth: {\n          enumerable: true,\n          get: function () {\n            return this.uniforms.linewidth.value;\n          },\n          set: function (value) {\n            this.uniforms.linewidth.value = value;\n          }\n        },\n        dashed: {\n          enumerable: true,\n          get: function () {\n            return Boolean('USE_DASH' in this.defines);\n          },\n          set(value) {\n            if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n              this.needsUpdate = true;\n            }\n            if (value === true) {\n              this.defines.USE_DASH = '';\n            } else {\n              delete this.defines.USE_DASH;\n            }\n          }\n        },\n        dashScale: {\n          enumerable: true,\n          get: function () {\n            return this.uniforms.dashScale.value;\n          },\n          set: function (value) {\n            this.uniforms.dashScale.value = value;\n          }\n        },\n        dashSize: {\n          enumerable: true,\n          get: function () {\n            return this.uniforms.dashSize.value;\n          },\n          set: function (value) {\n            this.uniforms.dashSize.value = value;\n          }\n        },\n        dashOffset: {\n          enumerable: true,\n          get: function () {\n            return this.uniforms.dashOffset.value;\n          },\n          set: function (value) {\n            this.uniforms.dashOffset.value = value;\n          }\n        },\n        gapSize: {\n          enumerable: true,\n          get: function () {\n            return this.uniforms.gapSize.value;\n          },\n          set: function (value) {\n            this.uniforms.gapSize.value = value;\n          }\n        },\n        opacity: {\n          enumerable: true,\n          get: function () {\n            return this.uniforms.opacity.value;\n          },\n          set: function (value) {\n            this.uniforms.opacity.value = value;\n          }\n        },\n        resolution: {\n          enumerable: true,\n          get: function () {\n            return this.uniforms.resolution.value;\n          },\n          set: function (value) {\n            this.uniforms.resolution.value.copy(value);\n          }\n        },\n        alphaToCoverage: {\n          enumerable: true,\n          get: function () {\n            return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n          },\n          set: function (value) {\n            if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n              this.needsUpdate = true;\n            }\n            if (value === true) {\n              this.defines.ALPHA_TO_COVERAGE = '';\n              this.extensions.derivatives = true;\n            } else {\n              delete this.defines.ALPHA_TO_COVERAGE;\n              this.extensions.derivatives = false;\n            }\n          }\n        }\n      });\n      this.setValues(parameters);\n    }\n  }\n  LineMaterial.prototype.isLineMaterial = true;\n  THREE.LineMaterial = LineMaterial;\n})();\n\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n */\n\n(function () {\n  const _start = new THREE.Vector3();\n  const _end = new THREE.Vector3();\n  const _start4 = new THREE.Vector4();\n  const _end4 = new THREE.Vector4();\n  const _ssOrigin = new THREE.Vector4();\n  const _ssOrigin3 = new THREE.Vector3();\n  const _mvMatrix = new THREE.Matrix4();\n  const _line = new THREE.Line3();\n  const _closestPoint = new THREE.Vector3();\n  const _box = new THREE.Box3();\n  const _sphere = new THREE.Sphere();\n  const _clipToWorldVector = new THREE.Vector4();\n  class LineSegments2 extends THREE.Mesh {\n    constructor(geometry = new THREE.LineSegmentsGeometry(), material = new THREE.LineMaterial({\n      color: Math.random() * 0xffffff\n    })) {\n      super(geometry, material);\n      this.type = 'LineSegments2';\n    } // for backwards-compatability, but could be a method of THREE.LineSegmentsGeometry...\n\n    computeLineDistances() {\n      const geometry = this.geometry;\n      const instanceStart = geometry.attributes.instanceStart;\n      const instanceEnd = geometry.attributes.instanceEnd;\n      const lineDistances = new Float32Array(2 * instanceStart.count);\n      for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n        _start.fromBufferAttribute(instanceStart, i);\n        _end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n      }\n      const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry.setAttribute('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n      geometry.setAttribute('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    }\n    raycast(raycaster, intersects) {\n      if (raycaster.camera === null) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n      }\n      const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n      const ray = raycaster.ray;\n      const camera = raycaster.camera;\n      const projectionMatrix = camera.projectionMatrix;\n      const matrixWorld = this.matrixWorld;\n      const geometry = this.geometry;\n      const material = this.material;\n      const resolution = material.resolution;\n      const lineWidth = material.linewidth + threshold;\n      const instanceStart = geometry.attributes.instanceStart;\n      const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n      const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n      // width in clip space\n\n      const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n      // check if we intersect the sphere bounds\n\n      if (geometry.boundingSphere === null) {\n        geometry.computeBoundingSphere();\n      }\n      _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n      _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n      _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n      _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n      const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n      _sphere.radius += sphereMargin;\n      if (raycaster.ray.intersectsSphere(_sphere) === false) {\n        return;\n      } //\n      // check if we intersect the box bounds\n\n      if (geometry.boundingBox === null) {\n        geometry.computeBoundingBox();\n      }\n      _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n      _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n      _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n      _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n      const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n      _box.max.x += boxMargin;\n      _box.max.y += boxMargin;\n      _box.max.z += boxMargin;\n      _box.min.x -= boxMargin;\n      _box.min.y -= boxMargin;\n      _box.min.z -= boxMargin;\n      if (raycaster.ray.intersectsBox(_box) === false) {\n        return;\n      } //\n      // pick a point 1 unit out along the ray to avoid the ray origin\n      // sitting at the camera origin which will cause \"w\" to be 0 when\n      // applying the projection matrix.\n\n      ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n      _ssOrigin.w = 1;\n      _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n      _ssOrigin.applyMatrix4(projectionMatrix);\n      _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n      _ssOrigin.x *= resolution.x / 2;\n      _ssOrigin.y *= resolution.y / 2;\n      _ssOrigin.z = 0;\n      _ssOrigin3.copy(_ssOrigin);\n      _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n      for (let i = 0, l = instanceStart.count; i < l; i++) {\n        _start4.fromBufferAttribute(instanceStart, i);\n        _end4.fromBufferAttribute(instanceEnd, i);\n        _start4.w = 1;\n        _end4.w = 1; // camera space\n\n        _start4.applyMatrix4(_mvMatrix);\n        _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n        var isBehindCameraNear = _start4.z > near && _end4.z > near;\n        if (isBehindCameraNear) {\n          continue;\n        } // trim the segment if it extends behind camera near\n\n        if (_start4.z > near) {\n          const deltaDist = _start4.z - _end4.z;\n          const t = (_start4.z - near) / deltaDist;\n          _start4.lerp(_end4, t);\n        } else if (_end4.z > near) {\n          const deltaDist = _end4.z - _start4.z;\n          const t = (_end4.z - near) / deltaDist;\n          _end4.lerp(_start4, t);\n        } // clip space\n\n        _start4.applyMatrix4(projectionMatrix);\n        _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n        _start4.multiplyScalar(1 / _start4.w);\n        _end4.multiplyScalar(1 / _end4.w); // screen space\n\n        _start4.x *= resolution.x / 2;\n        _start4.y *= resolution.y / 2;\n        _end4.x *= resolution.x / 2;\n        _end4.y *= resolution.y / 2; // create 2d segment\n\n        _line.start.copy(_start4);\n        _line.start.z = 0;\n        _line.end.copy(_end4);\n        _line.end.z = 0; // get closest point on ray to segment\n\n        const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n        _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n        const zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\n        const isInClipSpace = zPos >= -1 && zPos <= 1;\n        const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n        if (isInClipSpace && isInside) {\n          _line.start.fromBufferAttribute(instanceStart, i);\n          _line.end.fromBufferAttribute(instanceEnd, i);\n          _line.start.applyMatrix4(matrixWorld);\n          _line.end.applyMatrix4(matrixWorld);\n          const pointOnLine = new THREE.Vector3();\n          const point = new THREE.Vector3();\n          ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n          intersects.push({\n            point: point,\n            pointOnLine: pointOnLine,\n            distance: ray.origin.distanceTo(point),\n            object: this,\n            face: null,\n            faceIndex: i,\n            uv: null,\n            uv2: null\n          });\n        }\n      }\n    }\n  }\n  LineSegments2.prototype.LineSegments2 = true;\n  THREE.LineSegments2 = LineSegments2;\n})();\n\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n */\n\n(function () {\n  class Line2 extends THREE.LineSegments2 {\n    constructor(geometry = new THREE.LineGeometry(), material = new THREE.LineMaterial({\n      color: Math.random() * 0xffffff\n    })) {\n      super(geometry, material);\n      this.type = 'Line2';\n    }\n  }\n  Line2.prototype.isLine2 = true;\n  THREE.Line2 = Line2;\n})();\n\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n */\n\n(function () {\n  const _start = new THREE.Vector3();\n  const _end = new THREE.Vector3();\n  class Wireframe extends THREE.Mesh {\n    constructor(geometry = new THREE.LineSegmentsGeometry(), material = new THREE.LineMaterial({\n      color: Math.random() * 0xffffff\n    })) {\n      super(geometry, material);\n      this.type = 'Wireframe';\n    } // for backwards-compatability, but could be a method of THREE.LineSegmentsGeometry...\n\n    computeLineDistances() {\n      const geometry = this.geometry;\n      const instanceStart = geometry.attributes.instanceStart;\n      const instanceEnd = geometry.attributes.instanceEnd;\n      const lineDistances = new Float32Array(2 * instanceStart.count);\n      for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n        _start.fromBufferAttribute(instanceStart, i);\n        _end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n      }\n      const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry.setAttribute('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n      geometry.setAttribute('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    }\n  }\n  Wireframe.prototype.isWireframe = true;\n  THREE.Wireframe = Wireframe;\n})();","map":{"version":3,"names":["THREE","require","utils","Objects","line","obj","_validate","prototype","_defaults","straightProject","lnglatsToWorld","geometry","normalized","normalizeVertices","flattenedArray","flattenVectors","vertices","LineGeometry","setPositions","matLine","LineMaterial","color","linewidth","width","dashed","opacity","resolution","set","window","innerWidth","innerHeight","isMaterial","transparent","depthWrite","Line2","position","copy","computeLineDistances","module","exports","_box","Box3","_vector","Vector3","LineSegmentsGeometry","InstancedBufferGeometry","constructor","type","positions","uvs","index","setIndex","setAttribute","Float32BufferAttribute","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","undefined","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","setColors","colors","instanceColorBuffer","fromWireframeGeometry","fromEdgesGeometry","fromMesh","mesh","WireframeGeometry","fromLineSegments","isGeometry","console","error","isBufferGeometry","setFromBufferAttribute","union","Sphere","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","toJSON","applyMatrix","warn","isLineSegmentsGeometry","length","points","fromLine","isLineGeometry","WireframeGeometry2","isWireframeGeometry2","UniformsLib","worldUnits","value","Vector2","dashScale","dashSize","gapSize","ShaderLib","uniforms","UniformsUtils","merge","common","fog","vertexShader","fragmentShader","ShaderMaterial","parameters","clone","clipping","Object","defineProperties","enumerable","get","diffuse","defines","WORLD_UNITS","Boolean","USE_DASH","dashOffset","alphaToCoverage","ALPHA_TO_COVERAGE","extensions","derivatives","setValues","isLineMaterial","_start","_end","_start4","Vector4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_sphere","_clipToWorldVector","LineSegments2","Mesh","material","random","lineDistances","j","l","distanceTo","instanceDistanceBuffer","raycast","raycaster","intersects","camera","threshold","params","ray","projectionMatrix","matrixWorld","lineWidth","near","ssMaxWidth","height","distanceToSphere","distanceToPoint","origin","multiplyScalar","w","projectionMatrixInverse","sphereMargin","abs","intersectsSphere","distanceToBox","boxMargin","x","y","z","min","intersectsBox","at","matrixWorldInverse","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","MathUtils","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","object","face","faceIndex","uv","uv2","isLine2","Wireframe","isWireframe"],"sources":["/Users/mihailbaleev/Documents/GitHub/lastochka_spraying/node_modules/threebox-plugin/src/objects/line.js"],"sourcesContent":["const THREE = require(\"../three.js\");\r\nconst utils = require(\"../utils/utils.js\");\r\nconst Objects = require('./objects.js');\r\n\r\nfunction line(obj){\r\n\r\n\tobj = utils._validate(obj, Objects.prototype._defaults.line);\r\n\r\n\t// Geometry\r\n    var straightProject = utils.lnglatsToWorld(obj.geometry);\r\n\tvar normalized = utils.normalizeVertices(straightProject);\r\n    var flattenedArray = utils.flattenVectors(normalized.vertices);\r\n\t//console.log('line', normalized.vertices)\r\n\r\n\tvar geometry = new THREE.LineGeometry();\r\n\tgeometry.setPositions( flattenedArray );\r\n\r\n\t// Material\r\n\tlet matLine = new THREE.LineMaterial( {\r\n\t\tcolor: obj.color,\r\n\t\tlinewidth: obj.width, // in pixels\r\n\t\tdashed: false,\r\n\t\topacity: obj.opacity\r\n\t} );\r\n\t\r\n\tmatLine.resolution.set( window.innerWidth, window.innerHeight );\r\n\tmatLine.isMaterial = true;\r\n\tmatLine.transparent = true;\r\n\tmatLine.depthWrite = false;\r\n\r\n\t// Mesh\r\n\tline = new THREE.Line2( geometry, matLine );\r\n\tline.position.copy(normalized.position)\r\n\tline.computeLineDistances();\r\n\r\n\treturn line\r\n}\r\n\r\nmodule.exports = exports = line;\r\n\r\n/**\r\n * custom line shader by WestLangley, sourced from https://github.com/mrdoob/three.js/tree/master/examples/js/lines\r\n *\r\n */\r\n\r\n(function () {\r\n\r\n\tconst _box = new THREE.Box3();\r\n\r\n\tconst _vector = new THREE.Vector3();\r\n\r\n\tclass LineSegmentsGeometry extends THREE.InstancedBufferGeometry {\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper();\r\n\t\t\tthis.type = 'LineSegmentsGeometry';\r\n\t\t\tconst positions = [- 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0];\r\n\t\t\tconst uvs = [- 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2];\r\n\t\t\tconst index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\r\n\t\t\tthis.setIndex(index);\r\n\t\t\tthis.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n\t\t\tthis.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\r\n\r\n\t\t}\r\n\r\n\t\tapplyMatrix4(matrix) {\r\n\r\n\t\t\tconst start = this.attributes.instanceStart;\r\n\t\t\tconst end = this.attributes.instanceEnd;\r\n\r\n\t\t\tif (start !== undefined) {\r\n\r\n\t\t\t\tstart.applyMatrix4(matrix);\r\n\t\t\t\tend.applyMatrix4(matrix);\r\n\t\t\t\tstart.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (this.boundingBox !== null) {\r\n\r\n\t\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (this.boundingSphere !== null) {\r\n\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tsetPositions(array) {\r\n\r\n\t\t\tlet lineSegments;\r\n\r\n\t\t\tif (array instanceof Float32Array) {\r\n\r\n\t\t\t\tlineSegments = array;\r\n\r\n\t\t\t} else if (Array.isArray(array)) {\r\n\r\n\t\t\t\tlineSegments = new Float32Array(array);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst instanceBuffer = new THREE.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\r\n\r\n\t\t\tthis.setAttribute('instanceStart', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\r\n\r\n\t\t\tthis.setAttribute('instanceEnd', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\r\n\t\t\t//\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\t\t\tthis.computeBoundingSphere();\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tsetColors(array) {\r\n\r\n\t\t\tlet colors;\r\n\r\n\t\t\tif (array instanceof Float32Array) {\r\n\r\n\t\t\t\tcolors = array;\r\n\r\n\t\t\t} else if (Array.isArray(array)) {\r\n\r\n\t\t\t\tcolors = new Float32Array(array);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst instanceColorBuffer = new THREE.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\r\n\r\n\t\t\tthis.setAttribute('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\r\n\r\n\t\t\tthis.setAttribute('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tfromWireframeGeometry(geometry) {\r\n\r\n\t\t\tthis.setPositions(geometry.attributes.position.array);\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tfromEdgesGeometry(geometry) {\r\n\r\n\t\t\tthis.setPositions(geometry.attributes.position.array);\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tfromMesh(mesh) {\r\n\r\n\t\t\tthis.fromWireframeGeometry(new THREE.WireframeGeometry(mesh.geometry)); // set colors, maybe\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tfromLineSegments(lineSegments) {\r\n\r\n\t\t\tconst geometry = lineSegments.geometry;\r\n\r\n\t\t\tif (geometry.isGeometry) {\r\n\r\n\t\t\t\tconsole.error('THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} else if (geometry.isBufferGeometry) {\r\n\r\n\t\t\t\tthis.setPositions(geometry.attributes.position.array); // assumes non-indexed\r\n\r\n\t\t\t} // set colors, maybe\r\n\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tcomputeBoundingBox() {\r\n\r\n\t\t\tif (this.boundingBox === null) {\r\n\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst start = this.attributes.instanceStart;\r\n\t\t\tconst end = this.attributes.instanceEnd;\r\n\r\n\t\t\tif (start !== undefined && end !== undefined) {\r\n\r\n\t\t\t\tthis.boundingBox.setFromBufferAttribute(start);\r\n\r\n\t\t\t\t_box.setFromBufferAttribute(end);\r\n\r\n\t\t\t\tthis.boundingBox.union(_box);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcomputeBoundingSphere() {\r\n\r\n\t\t\tif (this.boundingSphere === null) {\r\n\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (this.boundingBox === null) {\r\n\r\n\t\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst start = this.attributes.instanceStart;\r\n\t\t\tconst end = this.attributes.instanceEnd;\r\n\r\n\t\t\tif (start !== undefined && end !== undefined) {\r\n\r\n\t\t\t\tconst center = this.boundingSphere.center;\r\n\t\t\t\tthis.boundingBox.getCenter(center);\r\n\t\t\t\tlet maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor (let i = 0, il = start.count; i < il; i++) {\r\n\r\n\t\t\t\t\t_vector.fromBufferAttribute(start, i);\r\n\r\n\t\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\r\n\r\n\t\t\t\t\t_vector.fromBufferAttribute(end, i);\r\n\r\n\t\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt(maxRadiusSq);\r\n\r\n\t\t\t\tif (isNaN(this.boundingSphere.radius)) {\r\n\r\n\t\t\t\t\tconsole.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ttoJSON() { // todo\r\n\t\t}\r\n\r\n\t\tapplyMatrix(matrix) {\r\n\r\n\t\t\tconsole.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\r\n\t\t\treturn this.applyMatrix4(matrix);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\r\n\r\n\tTHREE.LineSegmentsGeometry = LineSegmentsGeometry;\r\n\r\n})();\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n */\r\n\r\n(function () {\r\n\r\n\tclass LineGeometry extends THREE.LineSegmentsGeometry {\r\n\r\n\t\tconstructor() {\r\n\r\n\t\t\tsuper();\r\n\t\t\tthis.type = 'LineGeometry';\r\n\r\n\t\t}\r\n\r\n\t\tsetPositions(array) {\r\n\r\n\t\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\r\n\t\t\tvar length = array.length - 3;\r\n\t\t\tvar points = new Float32Array(2 * length);\r\n\r\n\t\t\tfor (var i = 0; i < length; i += 3) {\r\n\r\n\t\t\t\tpoints[2 * i] = array[i];\r\n\t\t\t\tpoints[2 * i + 1] = array[i + 1];\r\n\t\t\t\tpoints[2 * i + 2] = array[i + 2];\r\n\t\t\t\tpoints[2 * i + 3] = array[i + 3];\r\n\t\t\t\tpoints[2 * i + 4] = array[i + 4];\r\n\t\t\t\tpoints[2 * i + 5] = array[i + 5];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsuper.setPositions(points);\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tsetColors(array) {\r\n\r\n\t\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\r\n\t\t\tvar length = array.length - 3;\r\n\t\t\tvar colors = new Float32Array(2 * length);\r\n\r\n\t\t\tfor (var i = 0; i < length; i += 3) {\r\n\r\n\t\t\t\tcolors[2 * i] = array[i];\r\n\t\t\t\tcolors[2 * i + 1] = array[i + 1];\r\n\t\t\t\tcolors[2 * i + 2] = array[i + 2];\r\n\t\t\t\tcolors[2 * i + 3] = array[i + 3];\r\n\t\t\t\tcolors[2 * i + 4] = array[i + 4];\r\n\t\t\t\tcolors[2 * i + 5] = array[i + 5];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsuper.setColors(colors);\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tfromLine(line) {\r\n\r\n\t\t\tvar geometry = line.geometry;\r\n\r\n\t\t\tif (geometry.isGeometry) {\r\n\r\n\t\t\t\tconsole.error('THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} else if (geometry.isBufferGeometry) {\r\n\r\n\t\t\t\tthis.setPositions(geometry.attributes.position.array); // assumes non-indexed\r\n\r\n\t\t\t} // set colors, maybe\r\n\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tLineGeometry.prototype.isLineGeometry = true;\r\n\r\n\tTHREE.LineGeometry = LineGeometry;\r\n\r\n})();\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n */\r\n\r\n(function () {\r\n\r\n\tclass WireframeGeometry2 extends THREE.LineSegmentsGeometry {\r\n\r\n\t\tconstructor(geometry) {\r\n\r\n\t\t\tsuper();\r\n\t\t\tthis.type = 'WireframeGeometry2';\r\n\t\t\tthis.fromWireframeGeometry(new THREE.WireframeGeometry(geometry)); // set colors, maybe\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tWireframeGeometry2.prototype.isWireframeGeometry2 = true;\r\n\r\n\tTHREE.WireframeGeometry2 = WireframeGeometry2;\r\n\r\n})();\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  linewidth: <float>,\r\n *  dashed: <boolean>,\r\n *  dashScale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *  resolution: <Vector2>, // to be set by renderer\r\n * }\r\n */\r\n\r\n(function () {\r\n\r\n\t/**\r\n * parameters = {\r\n *  color: <hex>,\r\n *  linewidth: <float>,\r\n *  dashed: <boolean>,\r\n *  dashScale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *  resolution: <Vector2>, // to be set by renderer\r\n * }\r\n */\r\n\tTHREE.UniformsLib.line = {\r\n\t\tworldUnits: {\r\n\t\t\tvalue: 1\r\n\t\t},\r\n\t\tlinewidth: {\r\n\t\t\tvalue: 1\r\n\t\t},\r\n\t\tresolution: {\r\n\t\t\tvalue: new THREE.Vector2(1, 1)\r\n\t\t},\r\n\t\tdashScale: {\r\n\t\t\tvalue: 1\r\n\t\t},\r\n\t\tdashSize: {\r\n\t\t\tvalue: 1\r\n\t\t},\r\n\t\tgapSize: {\r\n\t\t\tvalue: 1\r\n\t\t} // todo FIX - maybe change to totalSize\r\n\r\n\t};\r\n\tTHREE.ShaderLib['line'] = {\r\n\t\tuniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.line]),\r\n\t\tvertexShader:\r\n\t\t\t/* glsl */\r\n\t\t\t`\r\n\t\t#include <common>\r\n\t\t#include <color_pars_vertex>\r\n\t\t#include <fog_pars_vertex>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\t\t#include <clipping_planes_pars_vertex>\r\n\r\n\t\tuniform float linewidth;\r\n\t\tuniform vec2 resolution;\r\n\r\n\t\tattribute vec3 instanceStart;\r\n\t\tattribute vec3 instanceEnd;\r\n\r\n\t\tattribute vec3 instanceColorStart;\r\n\t\tattribute vec3 instanceColorEnd;\r\n\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec4 worldPos;\r\n\t\tvarying vec3 worldStart;\r\n\t\tvarying vec3 worldEnd;\r\n\r\n\t\t#ifdef USE_DASH\r\n\r\n\t\t\tuniform float dashScale;\r\n\t\t\tattribute float instanceDistanceStart;\r\n\t\t\tattribute float instanceDistanceEnd;\r\n\t\t\tvarying float vLineDistance;\r\n\r\n\t\t#endif\r\n\r\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\r\n\r\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\r\n\r\n\t\t\t// conservative estimate of the near plane\r\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\r\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\r\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\r\n\r\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\r\n\r\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#ifdef USE_COLOR\r\n\r\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tfloat aspect = resolution.x / resolution.y;\r\n\r\n\t\t\tvUv = uv;\r\n\r\n\t\t\t// camera space\r\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\r\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\r\n\r\n\t\t\tworldStart = start.xyz;\r\n\t\t\tworldEnd = end.xyz;\r\n\r\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\r\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\r\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\r\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\r\n\r\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\r\n\r\n\t\t\tif ( perspective ) {\r\n\r\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\r\n\r\n\t\t\t\t\ttrimSegment( start, end );\r\n\r\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\r\n\r\n\t\t\t\t\ttrimSegment( end, start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// clip space\r\n\t\t\tvec4 clipStart = projectionMatrix * start;\r\n\t\t\tvec4 clipEnd = projectionMatrix * end;\r\n\r\n\t\t\t// ndc space\r\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\r\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\r\n\r\n\t\t\t// direction\r\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\r\n\r\n\t\t\t// account for clip-space aspect ratio\r\n\t\t\tdir.x *= aspect;\r\n\t\t\tdir = normalize( dir );\r\n\r\n\t\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\t\t// get the offset direction as perpendicular to the view vector\r\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\r\n\t\t\t\tvec3 offset;\r\n\t\t\t\tif ( position.y < 0.5 ) {\r\n\r\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// sign flip\r\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\r\n\r\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\r\n\r\n\t\t\t\t// don't extend the line if we're rendering dashes because we\r\n\t\t\t\t// won't be rendering the endcaps\r\n\t\t\t\t#ifndef USE_DASH\r\n\r\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\r\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\r\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\r\n\r\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\r\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\r\n\t\t\t\t\toffset.z += 0.5;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// endcaps\r\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\r\n\r\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// adjust for linewidth\r\n\t\t\t\toffset *= linewidth * 0.5;\r\n\r\n\t\t\t\t// set the world position\r\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\r\n\t\t\t\tworldPos.xyz += offset;\r\n\r\n\t\t\t\t// project the worldpos\r\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\r\n\r\n\t\t\t\t// shift the depth of the projected points so the line\r\n\t\t\t\t// segements overlap neatly\r\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\r\n\t\t\t\tclip.z = clipPose.z * clip.w;\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\r\n\t\t\t\t// undo aspect ratio adjustment\r\n\t\t\t\tdir.x /= aspect;\r\n\t\t\t\toffset.x /= aspect;\r\n\r\n\t\t\t\t// sign flip\r\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\r\n\r\n\t\t\t\t// endcaps\r\n\t\t\t\tif ( position.y < 0.0 ) {\r\n\r\n\t\t\t\t\toffset += - dir;\r\n\r\n\t\t\t\t} else if ( position.y > 1.0 ) {\r\n\r\n\t\t\t\t\toffset += dir;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// adjust for linewidth\r\n\t\t\t\toffset *= linewidth;\r\n\r\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\r\n\t\t\t\toffset /= resolution.y;\r\n\r\n\t\t\t\t// select end\r\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\r\n\r\n\t\t\t\t// back to clip space\r\n\t\t\t\toffset *= clip.w;\r\n\r\n\t\t\t\tclip.xy += offset;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tgl_Position = clip;\r\n\r\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t#include <clipping_planes_vertex>\r\n\t\t\t#include <fog_vertex>\r\n\r\n\t\t}\r\n\t\t`,\r\n\t\tfragmentShader:\r\n\t\t\t/* glsl */\r\n\t\t\t`\r\n\t\tuniform vec3 diffuse;\r\n\t\tuniform float opacity;\r\n\t\tuniform float linewidth;\r\n\r\n\t\t#ifdef USE_DASH\r\n\r\n\t\t\tuniform float dashSize;\r\n\t\t\tuniform float gapSize;\r\n\r\n\t\t#endif\r\n\r\n\t\tvarying float vLineDistance;\r\n\t\tvarying vec4 worldPos;\r\n\t\tvarying vec3 worldStart;\r\n\t\tvarying vec3 worldEnd;\r\n\r\n\t\t#include <common>\r\n\t\t#include <color_pars_fragment>\r\n\t\t#include <fog_pars_fragment>\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\t\t#include <clipping_planes_pars_fragment>\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\r\n\r\n\t\t\tfloat mua;\r\n\t\t\tfloat mub;\r\n\r\n\t\t\tvec3 p13 = p1 - p3;\r\n\t\t\tvec3 p43 = p4 - p3;\r\n\r\n\t\t\tvec3 p21 = p2 - p1;\r\n\r\n\t\t\tfloat d1343 = dot( p13, p43 );\r\n\t\t\tfloat d4321 = dot( p43, p21 );\r\n\t\t\tfloat d1321 = dot( p13, p21 );\r\n\t\t\tfloat d4343 = dot( p43, p43 );\r\n\t\t\tfloat d2121 = dot( p21, p21 );\r\n\r\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\r\n\r\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\r\n\r\n\t\t\tmua = numer / denom;\r\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\r\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\r\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\r\n\r\n\t\t\treturn vec2( mua, mub );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <clipping_planes_fragment>\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\r\n\r\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tfloat alpha = opacity;\r\n\r\n\t\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\t\t// Find the closest points on the view ray and the line segment\r\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\r\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\r\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\r\n\r\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\r\n\t\t\t\tvec3 p2 = rayEnd * params.y;\r\n\t\t\t\tvec3 delta = p1 - p2;\r\n\t\t\t\tfloat len = length( delta );\r\n\t\t\t\tfloat norm = len / linewidth;\r\n\r\n\t\t\t\t#ifndef USE_DASH\r\n\r\n\t\t\t\t\t#ifdef ALPHA_TO_COVERAGE\r\n\r\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\r\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\r\n\r\n\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\tif ( norm > 0.5 ) {\r\n\r\n\t\t\t\t\t\t\tdiscard;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\t#ifdef ALPHA_TO_COVERAGE\r\n\r\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\r\n\t\t\t\t\tfloat a = vUv.x;\r\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n\t\t\t\t\tfloat len2 = a * a + b * b;\r\n\t\t\t\t\tfloat dlen = fwidth( len2 );\r\n\r\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\r\n\r\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t#else\r\n\r\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\r\n\r\n\t\t\t\t\t\tfloat a = vUv.x;\r\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\r\n\r\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\t\t\t#include <color_fragment>\r\n\r\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\t\t\t#include <fog_fragment>\r\n\t\t\t#include <premultiplied_alpha_fragment>\r\n\r\n\t\t}\r\n\t\t`\r\n\t};\r\n\r\n\tclass LineMaterial extends THREE.ShaderMaterial {\r\n\r\n\t\tconstructor(parameters) {\r\n\r\n\t\t\tsuper({\r\n\t\t\t\ttype: 'LineMaterial',\r\n\t\t\t\tuniforms: THREE.UniformsUtils.clone(THREE.ShaderLib['line'].uniforms),\r\n\t\t\t\tvertexShader: THREE.ShaderLib['line'].vertexShader,\r\n\t\t\t\tfragmentShader: THREE.ShaderLib['line'].fragmentShader,\r\n\t\t\t\tclipping: true // required for clipping support\r\n\r\n\t\t\t});\r\n\t\t\tObject.defineProperties(this, {\r\n\t\t\t\tcolor: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this.uniforms.diffuse.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (value) {\r\n\r\n\t\t\t\t\t\tthis.uniforms.diffuse.value = value;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tworldUnits: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn 'WORLD_UNITS' in this.defines;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (value) {\r\n\r\n\t\t\t\t\t\tif (value === true) {\r\n\r\n\t\t\t\t\t\t\tthis.defines.WORLD_UNITS = '';\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tdelete this.defines.WORLD_UNITS;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tlinewidth: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this.uniforms.linewidth.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (value) {\r\n\r\n\t\t\t\t\t\tthis.uniforms.linewidth.value = value;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tdashed: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn Boolean('USE_DASH' in this.defines);\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tset(value) {\r\n\r\n\t\t\t\t\t\tif (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\r\n\r\n\t\t\t\t\t\t\tthis.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (value === true) {\r\n\r\n\t\t\t\t\t\t\tthis.defines.USE_DASH = '';\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tdelete this.defines.USE_DASH;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\t\t\t\tdashScale: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this.uniforms.dashScale.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (value) {\r\n\r\n\t\t\t\t\t\tthis.uniforms.dashScale.value = value;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tdashSize: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this.uniforms.dashSize.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (value) {\r\n\r\n\t\t\t\t\t\tthis.uniforms.dashSize.value = value;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tdashOffset: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this.uniforms.dashOffset.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (value) {\r\n\r\n\t\t\t\t\t\tthis.uniforms.dashOffset.value = value;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tgapSize: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this.uniforms.gapSize.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (value) {\r\n\r\n\t\t\t\t\t\tthis.uniforms.gapSize.value = value;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\topacity: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this.uniforms.opacity.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (value) {\r\n\r\n\t\t\t\t\t\tthis.uniforms.opacity.value = value;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tresolution: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this.uniforms.resolution.value;\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (value) {\r\n\r\n\t\t\t\t\t\tthis.uniforms.resolution.value.copy(value);\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\talphaToCoverage: {\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn Boolean('ALPHA_TO_COVERAGE' in this.defines);\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function (value) {\r\n\r\n\t\t\t\t\t\tif (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\r\n\r\n\t\t\t\t\t\t\tthis.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (value === true) {\r\n\r\n\t\t\t\t\t\t\tthis.defines.ALPHA_TO_COVERAGE = '';\r\n\t\t\t\t\t\t\tthis.extensions.derivatives = true;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tdelete this.defines.ALPHA_TO_COVERAGE;\r\n\t\t\t\t\t\t\tthis.extensions.derivatives = false;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tthis.setValues(parameters);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tLineMaterial.prototype.isLineMaterial = true;\r\n\r\n\tTHREE.LineMaterial = LineMaterial;\r\n\r\n})();\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n */\r\n\r\n(function () {\r\n\r\n\tconst _start = new THREE.Vector3();\r\n\r\n\tconst _end = new THREE.Vector3();\r\n\r\n\tconst _start4 = new THREE.Vector4();\r\n\r\n\tconst _end4 = new THREE.Vector4();\r\n\r\n\tconst _ssOrigin = new THREE.Vector4();\r\n\r\n\tconst _ssOrigin3 = new THREE.Vector3();\r\n\r\n\tconst _mvMatrix = new THREE.Matrix4();\r\n\r\n\tconst _line = new THREE.Line3();\r\n\r\n\tconst _closestPoint = new THREE.Vector3();\r\n\r\n\tconst _box = new THREE.Box3();\r\n\r\n\tconst _sphere = new THREE.Sphere();\r\n\r\n\tconst _clipToWorldVector = new THREE.Vector4();\r\n\r\n\tclass LineSegments2 extends THREE.Mesh {\r\n\r\n\t\tconstructor(geometry = new THREE.LineSegmentsGeometry(), material = new THREE.LineMaterial({\r\n\t\t\tcolor: Math.random() * 0xffffff\r\n\t\t})) {\r\n\r\n\t\t\tsuper(geometry, material);\r\n\t\t\tthis.type = 'LineSegments2';\r\n\r\n\t\t} // for backwards-compatability, but could be a method of THREE.LineSegmentsGeometry...\r\n\r\n\r\n\t\tcomputeLineDistances() {\r\n\r\n\t\t\tconst geometry = this.geometry;\r\n\t\t\tconst instanceStart = geometry.attributes.instanceStart;\r\n\t\t\tconst instanceEnd = geometry.attributes.instanceEnd;\r\n\t\t\tconst lineDistances = new Float32Array(2 * instanceStart.count);\r\n\r\n\t\t\tfor (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\r\n\r\n\t\t\t\t_start.fromBufferAttribute(instanceStart, i);\r\n\r\n\t\t\t\t_end.fromBufferAttribute(instanceEnd, i);\r\n\r\n\t\t\t\tlineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\r\n\t\t\t\tlineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\r\n\r\n\t\t\tgeometry.setAttribute('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\r\n\r\n\t\t\tgeometry.setAttribute('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\traycast(raycaster, intersects) {\r\n\r\n\t\t\tif (raycaster.camera === null) {\r\n\r\n\t\t\t\tconsole.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\r\n\t\t\tconst ray = raycaster.ray;\r\n\t\t\tconst camera = raycaster.camera;\r\n\t\t\tconst projectionMatrix = camera.projectionMatrix;\r\n\t\t\tconst matrixWorld = this.matrixWorld;\r\n\t\t\tconst geometry = this.geometry;\r\n\t\t\tconst material = this.material;\r\n\t\t\tconst resolution = material.resolution;\r\n\t\t\tconst lineWidth = material.linewidth + threshold;\r\n\t\t\tconst instanceStart = geometry.attributes.instanceStart;\r\n\t\t\tconst instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\r\n\r\n\t\t\tconst near = - camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\r\n\t\t\t// width in clip space\r\n\r\n\t\t\tconst ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\r\n\t\t\t// check if we intersect the sphere bounds\r\n\r\n\t\t\tif (geometry.boundingSphere === null) {\r\n\r\n\t\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\r\n\r\n\t\t\tconst distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\r\n\r\n\t\t\t_clipToWorldVector.set(0, 0, - distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\r\n\r\n\t\t\t_clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\r\n\r\n\t\t\t_clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\r\n\r\n\r\n\t\t\tconst sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\r\n\t\t\t_sphere.radius += sphereMargin;\r\n\r\n\t\t\tif (raycaster.ray.intersectsSphere(_sphere) === false) {\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} //\r\n\t\t\t// check if we intersect the box bounds\r\n\r\n\r\n\t\t\tif (geometry.boundingBox === null) {\r\n\r\n\t\t\t\tgeometry.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\r\n\r\n\t\t\tconst distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\r\n\r\n\t\t\t_clipToWorldVector.set(0, 0, - distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\r\n\r\n\t\t\t_clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\r\n\r\n\t\t\t_clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\r\n\r\n\r\n\t\t\tconst boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\r\n\t\t\t_box.max.x += boxMargin;\r\n\t\t\t_box.max.y += boxMargin;\r\n\t\t\t_box.max.z += boxMargin;\r\n\t\t\t_box.min.x -= boxMargin;\r\n\t\t\t_box.min.y -= boxMargin;\r\n\t\t\t_box.min.z -= boxMargin;\r\n\r\n\t\t\tif (raycaster.ray.intersectsBox(_box) === false) {\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} //\r\n\t\t\t// pick a point 1 unit out along the ray to avoid the ray origin\r\n\t\t\t// sitting at the camera origin which will cause \"w\" to be 0 when\r\n\t\t\t// applying the projection matrix.\r\n\r\n\r\n\t\t\tray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\r\n\r\n\t\t\t_ssOrigin.w = 1;\r\n\r\n\t\t\t_ssOrigin.applyMatrix4(camera.matrixWorldInverse);\r\n\r\n\t\t\t_ssOrigin.applyMatrix4(projectionMatrix);\r\n\r\n\t\t\t_ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\r\n\r\n\r\n\t\t\t_ssOrigin.x *= resolution.x / 2;\r\n\t\t\t_ssOrigin.y *= resolution.y / 2;\r\n\t\t\t_ssOrigin.z = 0;\r\n\r\n\t\t\t_ssOrigin3.copy(_ssOrigin);\r\n\r\n\t\t\t_mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\r\n\r\n\t\t\tfor (let i = 0, l = instanceStart.count; i < l; i++) {\r\n\r\n\t\t\t\t_start4.fromBufferAttribute(instanceStart, i);\r\n\r\n\t\t\t\t_end4.fromBufferAttribute(instanceEnd, i);\r\n\r\n\t\t\t\t_start4.w = 1;\r\n\t\t\t\t_end4.w = 1; // camera space\r\n\r\n\t\t\t\t_start4.applyMatrix4(_mvMatrix);\r\n\r\n\t\t\t\t_end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\r\n\r\n\r\n\t\t\t\tvar isBehindCameraNear = _start4.z > near && _end4.z > near;\r\n\r\n\t\t\t\tif (isBehindCameraNear) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t} // trim the segment if it extends behind camera near\r\n\r\n\r\n\t\t\t\tif (_start4.z > near) {\r\n\r\n\t\t\t\t\tconst deltaDist = _start4.z - _end4.z;\r\n\t\t\t\t\tconst t = (_start4.z - near) / deltaDist;\r\n\r\n\t\t\t\t\t_start4.lerp(_end4, t);\r\n\r\n\t\t\t\t} else if (_end4.z > near) {\r\n\r\n\t\t\t\t\tconst deltaDist = _end4.z - _start4.z;\r\n\t\t\t\t\tconst t = (_end4.z - near) / deltaDist;\r\n\r\n\t\t\t\t\t_end4.lerp(_start4, t);\r\n\r\n\t\t\t\t} // clip space\r\n\r\n\r\n\t\t\t\t_start4.applyMatrix4(projectionMatrix);\r\n\r\n\t\t\t\t_end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\r\n\r\n\r\n\t\t\t\t_start4.multiplyScalar(1 / _start4.w);\r\n\r\n\t\t\t\t_end4.multiplyScalar(1 / _end4.w); // screen space\r\n\r\n\r\n\t\t\t\t_start4.x *= resolution.x / 2;\r\n\t\t\t\t_start4.y *= resolution.y / 2;\r\n\t\t\t\t_end4.x *= resolution.x / 2;\r\n\t\t\t\t_end4.y *= resolution.y / 2; // create 2d segment\r\n\r\n\t\t\t\t_line.start.copy(_start4);\r\n\r\n\t\t\t\t_line.start.z = 0;\r\n\r\n\t\t\t\t_line.end.copy(_end4);\r\n\r\n\t\t\t\t_line.end.z = 0; // get closest point on ray to segment\r\n\r\n\t\t\t\tconst param = _line.closestPointToPointParameter(_ssOrigin3, true);\r\n\r\n\t\t\t\t_line.at(param, _closestPoint); // check if the intersection point is within clip space\r\n\r\n\r\n\t\t\t\tconst zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\r\n\t\t\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\r\n\t\t\t\tconst isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\r\n\r\n\t\t\t\tif (isInClipSpace && isInside) {\r\n\r\n\t\t\t\t\t_line.start.fromBufferAttribute(instanceStart, i);\r\n\r\n\t\t\t\t\t_line.end.fromBufferAttribute(instanceEnd, i);\r\n\r\n\t\t\t\t\t_line.start.applyMatrix4(matrixWorld);\r\n\r\n\t\t\t\t\t_line.end.applyMatrix4(matrixWorld);\r\n\r\n\t\t\t\t\tconst pointOnLine = new THREE.Vector3();\r\n\t\t\t\t\tconst point = new THREE.Vector3();\r\n\t\t\t\t\tray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\r\n\t\t\t\t\tintersects.push({\r\n\t\t\t\t\t\tpoint: point,\r\n\t\t\t\t\t\tpointOnLine: pointOnLine,\r\n\t\t\t\t\t\tdistance: ray.origin.distanceTo(point),\r\n\t\t\t\t\t\tobject: this,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: i,\r\n\t\t\t\t\t\tuv: null,\r\n\t\t\t\t\t\tuv2: null\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tLineSegments2.prototype.LineSegments2 = true;\r\n\r\n\tTHREE.LineSegments2 = LineSegments2;\r\n\r\n})();\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n */\r\n\r\n(function () {\r\n\r\n\tclass Line2 extends THREE.LineSegments2 {\r\n\r\n\t\tconstructor(geometry = new THREE.LineGeometry(), material = new THREE.LineMaterial({\r\n\t\t\tcolor: Math.random() * 0xffffff\r\n\t\t})) {\r\n\r\n\t\t\tsuper(geometry, material);\r\n\t\t\tthis.type = 'Line2';\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tLine2.prototype.isLine2 = true;\r\n\r\n\tTHREE.Line2 = Line2;\r\n\r\n})();\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n */\r\n\r\n(function () {\r\n\r\n\tconst _start = new THREE.Vector3();\r\n\r\n\tconst _end = new THREE.Vector3();\r\n\r\n\tclass Wireframe extends THREE.Mesh {\r\n\r\n\t\tconstructor(geometry = new THREE.LineSegmentsGeometry(), material = new THREE.LineMaterial({\r\n\t\t\tcolor: Math.random() * 0xffffff\r\n\t\t})) {\r\n\r\n\t\t\tsuper(geometry, material);\r\n\t\t\tthis.type = 'Wireframe';\r\n\r\n\t\t} // for backwards-compatability, but could be a method of THREE.LineSegmentsGeometry...\r\n\r\n\r\n\t\tcomputeLineDistances() {\r\n\r\n\t\t\tconst geometry = this.geometry;\r\n\t\t\tconst instanceStart = geometry.attributes.instanceStart;\r\n\t\t\tconst instanceEnd = geometry.attributes.instanceEnd;\r\n\t\t\tconst lineDistances = new Float32Array(2 * instanceStart.count);\r\n\r\n\t\t\tfor (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\r\n\r\n\t\t\t\t_start.fromBufferAttribute(instanceStart, i);\r\n\r\n\t\t\t\t_end.fromBufferAttribute(instanceEnd, i);\r\n\r\n\t\t\t\tlineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\r\n\t\t\t\tlineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\r\n\r\n\t\t\tgeometry.setAttribute('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\r\n\r\n\t\t\tgeometry.setAttribute('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tWireframe.prototype.isWireframe = true;\r\n\r\n\tTHREE.Wireframe = Wireframe;\r\n\r\n})();\r\n"],"mappings":"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ACTH,KAAK,EAAE;IACR,CAAC;IACDI,OAAO,EAAE;MACRJ,KAAK,EAAE;IACR,CAAC,CAAC;EAEH,CAAC;EACDpH,KAAK,CAACyH,SAAS,CAAC,MAAM,CAAC,GAAG;IACzBC,QAAQ,EAAE1H,KAAK,CAAC2H,aAAa,CAACC,KAAK,CAAC,CAAC5H,KAAK,CAACkH,WAAW,CAACW,MAAM,EAAE7H,KAAK,CAACkH,WAAW,CAACY,GAAG,EAAE9H,KAAK,CAACkH,WAAW,CAAC9G,IAAI,CAAC,CAAC;IAC9G2H,YAAY,EACX;IACA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;IACDC,cAAc,EACb;IACA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,CAAC;EAED,MAAM5G,YAAY,SAASpB,KAAK,CAACiI,cAAc,CAAC;IAE/CnF,WAAWA,CAACoF,UAAU,EAAE;MAEvB,KAAK,CAAC;QACLnF,IAAI,EAAE,cAAc;QACpB2E,QAAQ,EAAE1H,KAAK,CAAC2H,aAAa,CAACQ,KAAK,CAACnI,KAAK,CAACyH,SAAS,CAAC,MAAM,CAAC,CAACC,QAAQ,CAAC;QACrEK,YAAY,EAAE/H,KAAK,CAACyH,SAAS,CAAC,MAAM,CAAC,CAACM,YAAY;QA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}